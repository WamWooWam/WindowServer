/*
 * This is a very hasty port of filer.js to work with ESM.
 * It's not pretty, but it works.
 */

const __exports = {};

// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
var parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, globalThis);
    }

    return cache[name].exports;

    function localRequire(x) {
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x) {
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;
      // RequireJS
    } else if (typeof define === "function" && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      __exports[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({
  "b1ZG": [function (require, module, exports) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.promisify = promisify;
    var customArgumentsToken = "__ES6-PROMISIFY--CUSTOM-ARGUMENTS__";

    function promisify(a) {
      if ("function" != typeof a) throw new TypeError("Argument to promisify must be a function");
      var b = a[customArgumentsToken],
        c = promisify.Promise || Promise;
      if ("function" != typeof c) throw new Error("No Promise implementation found; do you need a polyfill?");
      return function () {
        var _this = this;

        for (var d = arguments.length, e = Array(d), f = 0; f < d; f++) {
          e[f] = arguments[f];
        }

        return new c(function (c, d) {
          e.push(function (a) {
            if (a) return d(a);

            for (var e = arguments.length, f = Array(1 < e ? e - 1 : 0), g = 1; g < e; g++) {
              f[g - 1] = arguments[g];
            }

            if (1 === f.length || !b) return c(f[0]);
            var h = {};
            f.forEach(function (a, c) {
              var d = b[c];
              d && (h[d] = a);
            }), c(h);
          }), a.apply(_this, e);
        });
      };
    }

    promisify.argumentNames = "__ES6-PROMISIFY--CUSTOM-ARGUMENTS__", promisify.Promise = void 0;
  }, {}], "pBGv": [function (require, module, exports) {

    // shim for using process in browser
    var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
    // don't break things.  But we need to wrap it in a try catch in case it is
    // wrapped in strict mode code which doesn't define any globals.  It's inside a
    // function because try/catches deoptimize in certain engines.

    var cachedSetTimeout;
    var cachedClearTimeout;

    function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
    }

    function defaultClearTimeout() {
      throw new Error('clearTimeout has not been defined');
    }

    (function () {
      try {
        if (typeof setTimeout === 'function') {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }

      try {
        if (typeof clearTimeout === 'function') {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();

    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
      } // if setTimeout wasn't available but was latter defined


      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }

      try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
          // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }

    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
      } // if clearTimeout wasn't available but was latter defined


      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }

      try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
          return cachedClearTimeout.call(null, marker);
        } catch (e) {
          // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
          // Some versions of I.E. have different rules for clearTimeout vs setTimeout
          return cachedClearTimeout.call(this, marker);
        }
      }
    }

    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }

      draining = false;

      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }

      if (queue.length) {
        drainQueue();
      }
    }

    function drainQueue() {
      if (draining) {
        return;
      }

      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;

      while (len) {
        currentQueue = queue;
        queue = [];

        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }

        queueIndex = -1;
        len = queue.length;
      }

      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }

    process.nextTick = function (fun) {
      var args = new Array(arguments.length - 1);

      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }

      queue.push(new Item(fun, args));

      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    }; // v8 likes predictible objects


    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }

    Item.prototype.run = function () {
      this.fun.apply(null, this.array);
    };

    process.title = 'browser';
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues

    process.versions = {};

    function noop() { }

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.prependListener = noop;
    process.prependOnceListener = noop;

    process.listeners = function (name) {
      return [];
    };

    process.binding = function (name) {
      throw new Error('process.binding is not supported');
    };

    process.cwd = function () {
      return '/';
    };

    process.chdir = function (dir) {
      throw new Error('process.chdir is not supported');
    };

    process.umask = function () {
      return 0;
    };
  }, {}], "UUq2": [function (require, module, exports) {
    var process = require("process");
    // .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
    // backported and transplited with Babel, with backwards-compat fixes

    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.

    // resolves . and .. elements in a path array with directory names there
    // must be no slashes, empty elements, or device names (c:\) in the array
    // (so also no leading and trailing slashes - it does not distinguish
    // relative and absolute paths)
    function normalizeArray(parts, allowAboveRoot) {
      // if the path tries to go above the root, `up` ends up > 0
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === '.') {
          parts.splice(i, 1);
        } else if (last === '..') {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }

      // if the path is allowed to go above the root, restore leading ..s
      if (allowAboveRoot) {
        for (; up--; up) {
          parts.unshift('..');
        }
      }

      return parts;
    }

    // path.resolve([from ...], to)
    // posix version
    exports.resolve = function () {
      var resolvedPath = '',
        resolvedAbsolute = false;

      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = (i >= 0) ? arguments[i] : process.cwd();

        // Skip empty and invalid entries
        if (typeof path !== 'string') {
          throw new TypeError('Arguments to path.resolve must be strings');
        } else if (!path) {
          continue;
        }

        resolvedPath = path + '/' + resolvedPath;
        resolvedAbsolute = path.charAt(0) === '/';
      }

      // At this point the path should be resolved to a full absolute path, but
      // handle relative paths to be safe (might happen when process.cwd() fails)

      // Normalize the path
      resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
        return !!p;
      }), !resolvedAbsolute).join('/');

      return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
    };

    // path.normalize(path)
    // posix version
    exports.normalize = function (path) {
      var isAbsolute = exports.isAbsolute(path),
        trailingSlash = substr(path, -1) === '/';

      // Normalize the path
      path = normalizeArray(filter(path.split('/'), function (p) {
        return !!p;
      }), !isAbsolute).join('/');

      if (!path && !isAbsolute) {
        path = '.';
      }
      if (path && trailingSlash) {
        path += '/';
      }

      return (isAbsolute ? '/' : '') + path;
    };

    // posix version
    exports.isAbsolute = function (path) {
      return path.charAt(0) === '/';
    };

    // posix version
    exports.join = function () {
      var paths = Array.prototype.slice.call(arguments, 0);
      return exports.normalize(filter(paths, function (p, index) {
        if (typeof p !== 'string') {
          throw new TypeError('Arguments to path.join must be strings');
        }
        return p;
      }).join('/'));
    };


    // path.relative(from, to)
    // posix version
    exports.relative = function (from, to) {
      from = exports.resolve(from).substr(1);
      to = exports.resolve(to).substr(1);

      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== '') break;
        }

        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== '') break;
        }

        if (start > end) return [];
        return arr.slice(start, end - start + 1);
      }

      var fromParts = trim(from.split('/'));
      var toParts = trim(to.split('/'));

      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }

      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push('..');
      }

      outputParts = outputParts.concat(toParts.slice(samePartsLength));

      return outputParts.join('/');
    };

    exports.sep = '/';
    exports.delimiter = ':';

    exports.dirname = function (path) {
      if (typeof path !== 'string') path = path + '';
      if (path.length === 0) return '.';
      var code = path.charCodeAt(0);
      var hasRoot = code === 47 /*/*/;
      var end = -1;
      var matchedSlash = true;
      for (var i = path.length - 1; i >= 1; --i) {
        code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
          // We saw the first non-path separator
          matchedSlash = false;
        }
      }

      if (end === -1) return hasRoot ? '/' : '.';
      if (hasRoot && end === 1) {
        // return '//';
        // Backwards-compat fix:
        return '/';
      }
      return path.slice(0, end);
    };

    function basename(path) {
      if (typeof path !== 'string') path = path + '';

      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i;

      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }

      if (end === -1) return '';
      return path.slice(start, end);
    }

    // Uses a mixed approach for backwards-compatibility, as ext behavior changed
    // in new Node.js versions, so only basename() above is backported here
    exports.basename = function (path, ext) {
      var f = basename(path);
      if (ext && f.substr(-1 * ext.length) === ext) {
        f = f.substr(0, f.length - ext.length);
      }
      return f;
    };

    exports.extname = function (path) {
      if (typeof path !== 'string') path = path + '';
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      // Track the state of characters (if any) we see before our first dot and
      // after any path separator we find
      var preDotState = 0;
      for (var i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // extension
          matchedSlash = false;
          end = i + 1;
        }
        if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          // We saw a non-dot and non-path separator before our dot, so we should
          // have a good chance at having a non-empty extension
          preDotState = -1;
        }
      }

      if (startDot === -1 || end === -1 ||
        // We saw a non-dot character immediately before the dot
        preDotState === 0 ||
        // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return '';
      }
      return path.slice(startDot, end);
    };

    function filter(xs, f) {
      if (xs.filter) return xs.filter(f);
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
      }
      return res;
    }

    // String.prototype.substr - negative index don't work in IE8
    var substr = 'ab'.substr(-1) === 'b'
      ? function (str, start, len) { return str.substr(start, len) }
      : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
      }
      ;

  }, { "process": "pBGv" }], "UzoP": [function (require, module, exports) {
    var process = require("process");
    /**
     * Patch process to add process.cwd(), always giving the root dir.
     * NOTE: this line needs to happen *before* we require in `path`.
     */
    process.cwd = function () {
      return '/';
    };
    /**
     * https://github.com/browserify/path-browserify via Parcel.
     * We use is as a base for our own Filer.Path, and patch/add
     * a few things we need for the browser environment.
     */


    var nodePath = require('path');

    var filerPath = Object.assign({}, nodePath);
    /**
     * Patch path.basename() to return / vs. ''
     */

    filerPath.basename = function (path, ext) {
      var basename = nodePath.basename(path, ext);
      return basename === '' ? '/' : basename;
    };
    /**
     * Patch path.normalize() to not add a trailing /
     */


    filerPath.normalize = function (path) {
      path = nodePath.normalize(path);
      return path === '/' ? path : filerPath.removeTrailing(path);
    };
    /**
     * Add new utility method isNull() to path: check for null paths.
     */


    filerPath.isNull = function (path) {
      return ('' + path).indexOf("\0") !== -1;
    };
    /**
     * Add new utility method addTrailing() to add trailing / without doubling to //.
     */


    filerPath.addTrailing = function (path) {
      return path.replace(/\/*$/, '/');
    };
    /**
     * Add new utility method removeTrailing() to remove trailing /, dealing with multiple
     */


    filerPath.removeTrailing = function (path) {
      path = path.replace(/\/*$/, '');
      return path === '' ? '/' : path;
    };

    module.exports = filerPath;
  }, { "path": "UUq2", "process": "pBGv" }], "iJA9": [function (require, module, exports) {
    var O_READ = 'READ';
    var O_WRITE = 'WRITE';
    var O_CREATE = 'CREATE';
    var O_EXCLUSIVE = 'EXCLUSIVE';
    var O_TRUNCATE = 'TRUNCATE';
    var O_APPEND = 'APPEND';
    var XATTR_CREATE = 'CREATE';
    var XATTR_REPLACE = 'REPLACE';
    module.exports = {
      FILE_SYSTEM_NAME: 'local',
      FILE_STORE_NAME: 'files',
      IDB_RO: 'readonly',
      IDB_RW: 'readwrite',
      WSQL_VERSION: '1',
      WSQL_SIZE: 5 * 1024 * 1024,
      WSQL_DESC: 'FileSystem Storage',
      NODE_TYPE_FILE: 'FILE',
      NODE_TYPE_DIRECTORY: 'DIRECTORY',
      NODE_TYPE_SYMBOLIC_LINK: 'SYMLINK',
      NODE_TYPE_META: 'META',
      DEFAULT_DIR_PERMISSIONS: 0x1ED,
      // 755
      DEFAULT_FILE_PERMISSIONS: 0x1A4,
      // 644
      FULL_READ_WRITE_EXEC_PERMISSIONS: 0x1FF,
      // 777
      READ_WRITE_PERMISSIONS: 0x1B6,
      /// 666
      SYMLOOP_MAX: 10,
      BINARY_MIME_TYPE: 'application/octet-stream',
      JSON_MIME_TYPE: 'application/json',
      ROOT_DIRECTORY_NAME: '/',
      // basename(normalize(path))
      // FS Mount Flags
      FS_FORMAT: 'FORMAT',
      FS_NOCTIME: 'NOCTIME',
      FS_NOMTIME: 'NOMTIME',
      FS_NODUPEIDCHECK: 'FS_NODUPEIDCHECK',
      // FS File Open Flags
      O_READ: O_READ,
      O_WRITE: O_WRITE,
      O_CREATE: O_CREATE,
      O_EXCLUSIVE: O_EXCLUSIVE,
      O_TRUNCATE: O_TRUNCATE,
      O_APPEND: O_APPEND,
      O_FLAGS: {
        'r': [O_READ],
        'r+': [O_READ, O_WRITE],
        'w': [O_WRITE, O_CREATE, O_TRUNCATE],
        'w+': [O_WRITE, O_READ, O_CREATE, O_TRUNCATE],
        'wx': [O_WRITE, O_CREATE, O_EXCLUSIVE, O_TRUNCATE],
        'wx+': [O_WRITE, O_READ, O_CREATE, O_EXCLUSIVE, O_TRUNCATE],
        'a': [O_WRITE, O_CREATE, O_APPEND],
        'a+': [O_WRITE, O_READ, O_CREATE, O_APPEND],
        'ax': [O_WRITE, O_CREATE, O_EXCLUSIVE, O_APPEND],
        'ax+': [O_WRITE, O_READ, O_CREATE, O_EXCLUSIVE, O_APPEND]
      },
      XATTR_CREATE: XATTR_CREATE,
      XATTR_REPLACE: XATTR_REPLACE,
      FS_READY: 'READY',
      FS_PENDING: 'PENDING',
      FS_ERROR: 'ERROR',
      SUPER_NODE_ID: '00000000-0000-0000-0000-000000000000',
      // Reserved File Descriptors for streams
      STDIN: 0,
      STDOUT: 1,
      STDERR: 2,
      FIRST_DESCRIPTOR: 3,
      ENVIRONMENT: {
        TMP: '/tmp',
        PATH: ''
      },
      // Duplicate Node's fs.constants
      fsConstants: {
        O_RDONLY: 0,
        O_WRONLY: 1,
        O_RDWR: 2,
        S_IFMT: 61440,
        S_IFREG: 32768,
        S_IFDIR: 16384,
        S_IFCHR: 8192,
        S_IFBLK: 24576,
        S_IFIFO: 4096,
        S_IFLNK: 40960,
        S_IFSOCK: 49152,
        O_CREAT: 512,
        O_EXCL: 2048,
        O_NOCTTY: 131072,
        O_TRUNC: 1024,
        O_APPEND: 8,
        O_DIRECTORY: 1048576,
        O_NOFOLLOW: 256,
        O_SYNC: 128,
        O_DSYNC: 4194304,
        O_SYMLINK: 2097152,
        O_NONBLOCK: 4,
        S_IRWXU: 448,
        S_IRUSR: 256,
        S_IWUSR: 128,
        S_IXUSR: 64,
        S_IRWXG: 56,
        S_IRGRP: 32,
        S_IWGRP: 16,
        S_IXGRP: 8,
        S_IRWXO: 7,
        S_IROTH: 4,
        S_IWOTH: 2,
        S_IXOTH: 1,
        F_OK: 0,
        R_OK: 4,
        W_OK: 2,
        X_OK: 1,
        UV_FS_COPYFILE_EXCL: 1,
        COPYFILE_EXCL: 1
      }
    };
  }, {}], "yh9p": [function (require, module, exports) {
    'use strict'

    exports.byteLength = byteLength
    exports.toByteArray = toByteArray
    exports.fromByteArray = fromByteArray

    var lookup = []
    var revLookup = []
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i]
      revLookup[code.charCodeAt(i)] = i
    }

    // Support decoding URL-safe base64 strings, as Node.js does.
    // See: https://en.wikipedia.org/wiki/Base64#URL_applications
    revLookup['-'.charCodeAt(0)] = 62
    revLookup['_'.charCodeAt(0)] = 63

    function getLens(b64) {
      var len = b64.length

      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
      }

      // Trim off extra bytes after placeholder bytes are found
      // See: https://github.com/beatgammit/base64-js/issues/42
      var validLen = b64.indexOf('=')
      if (validLen === -1) validLen = len

      var placeHoldersLen = validLen === len
        ? 0
        : 4 - (validLen % 4)

      return [validLen, placeHoldersLen]
    }

    // base64 is 4/3 + up to two characters of the original data
    function byteLength(b64) {
      var lens = getLens(b64)
      var validLen = lens[0]
      var placeHoldersLen = lens[1]
      return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
    }

    function _byteLength(b64, validLen, placeHoldersLen) {
      return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
    }

    function toByteArray(b64) {
      var tmp
      var lens = getLens(b64)
      var validLen = lens[0]
      var placeHoldersLen = lens[1]

      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

      var curByte = 0

      // if there are placeholders, only get up to the last complete 4 chars
      var len = placeHoldersLen > 0
        ? validLen - 4
        : validLen

      var i
      for (i = 0; i < len; i += 4) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 18) |
          (revLookup[b64.charCodeAt(i + 1)] << 12) |
          (revLookup[b64.charCodeAt(i + 2)] << 6) |
          revLookup[b64.charCodeAt(i + 3)]
        arr[curByte++] = (tmp >> 16) & 0xFF
        arr[curByte++] = (tmp >> 8) & 0xFF
        arr[curByte++] = tmp & 0xFF
      }

      if (placeHoldersLen === 2) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 2) |
          (revLookup[b64.charCodeAt(i + 1)] >> 4)
        arr[curByte++] = tmp & 0xFF
      }

      if (placeHoldersLen === 1) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 10) |
          (revLookup[b64.charCodeAt(i + 1)] << 4) |
          (revLookup[b64.charCodeAt(i + 2)] >> 2)
        arr[curByte++] = (tmp >> 8) & 0xFF
        arr[curByte++] = tmp & 0xFF
      }

      return arr
    }

    function tripletToBase64(num) {
      return lookup[num >> 18 & 0x3F] +
        lookup[num >> 12 & 0x3F] +
        lookup[num >> 6 & 0x3F] +
        lookup[num & 0x3F]
    }

    function encodeChunk(uint8, start, end) {
      var tmp
      var output = []
      for (var i = start; i < end; i += 3) {
        tmp =
          ((uint8[i] << 16) & 0xFF0000) +
          ((uint8[i + 1] << 8) & 0xFF00) +
          (uint8[i + 2] & 0xFF)
        output.push(tripletToBase64(tmp))
      }
      return output.join('')
    }

    function fromByteArray(uint8) {
      var tmp
      var len = uint8.length
      var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
      var parts = []
      var maxChunkLength = 16383 // must be multiple of 3

      // go through the array every three bytes, we'll deal with trailing stuff later
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
      }

      // pad the end with zeros, but make sure to not forget the extra bytes
      if (extraBytes === 1) {
        tmp = uint8[len - 1]
        parts.push(
          lookup[tmp >> 2] +
          lookup[(tmp << 4) & 0x3F] +
          '=='
        )
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1]
        parts.push(
          lookup[tmp >> 10] +
          lookup[(tmp >> 4) & 0x3F] +
          lookup[(tmp << 2) & 0x3F] +
          '='
        )
      }

      return parts.join('')
    }

  }, {}], "JgNJ": [function (require, module, exports) {
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    exports.read = function (buffer, offset, isLE, mLen, nBytes) {
      var e, m
      var eLen = (nBytes * 8) - mLen - 1
      var eMax = (1 << eLen) - 1
      var eBias = eMax >> 1
      var nBits = -7
      var i = isLE ? (nBytes - 1) : 0
      var d = isLE ? -1 : 1
      var s = buffer[offset + i]

      i += d

      e = s & ((1 << (-nBits)) - 1)
      s >>= (-nBits)
      nBits += eLen
      for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) { }

      m = e & ((1 << (-nBits)) - 1)
      e >>= (-nBits)
      nBits += mLen
      for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) { }

      if (e === 0) {
        e = 1 - eBias
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity)
      } else {
        m = m + Math.pow(2, mLen)
        e = e - eBias
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    }

    exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c
      var eLen = (nBytes * 8) - mLen - 1
      var eMax = (1 << eLen) - 1
      var eBias = eMax >> 1
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
      var i = isLE ? 0 : (nBytes - 1)
      var d = isLE ? 1 : -1
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

      value = Math.abs(value)

      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0
        e = eMax
      } else {
        e = Math.floor(Math.log(value) / Math.LN2)
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--
          c *= 2
        }
        if (e + eBias >= 1) {
          value += rt / c
        } else {
          value += rt * Math.pow(2, 1 - eBias)
        }
        if (value * c >= 2) {
          e++
          c /= 2
        }

        if (e + eBias >= eMax) {
          m = 0
          e = eMax
        } else if (e + eBias >= 1) {
          m = ((value * c) - 1) * Math.pow(2, mLen)
          e = e + eBias
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
          e = 0
        }
      }

      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) { }

      e = (e << mLen) | m
      eLen += mLen
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) { }

      buffer[offset + i - d] |= s * 128
    }

  }, {}], "REa7": [function (require, module, exports) {
    var toString = {}.toString;

    module.exports = Array.isArray || function (arr) {
      return toString.call(arr) == '[object Array]';
    };

  }, {}], "dskh": [function (require, module, exports) {

    var global = arguments[3];
    /*!
      * The buffer module from node.js, for the browser.
      *
      * @author   Feross Aboukhadijeh <http://feross.org>
      * @license  MIT
      */
    /* eslint-disable no-proto */

    'use strict'

    var base64 = require('base64-js')
    var ieee754 = require('ieee754')
    var isArray = require('isarray')

    exports.Buffer = Buffer
    exports.SlowBuffer = SlowBuffer
    exports.INSPECT_MAX_BYTES = 50

    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Use Object implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * Due to various browser bugs, sometimes the Object implementation will be used even
     * when the browser supports typed arrays.
     *
     * Note:
     *
     *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
     *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
     *
     *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
     *
     *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
     *     incorrect length in some situations.
    
      * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
      * get the Object implementation, which is slower but behaves correctly.
      */
    Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
      ? global.TYPED_ARRAY_SUPPORT
      : typedArraySupport()

    /*
      * Export kMaxLength after typed array support is determined.
      */
    exports.kMaxLength = kMaxLength()

    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1)
        arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
        return arr.foo() === 42 && // typed array instances can be augmented
          typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
          arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
      } catch (e) {
        return false
      }
    }

    function kMaxLength() {
      return Buffer.TYPED_ARRAY_SUPPORT
        ? 0x7fffffff
        : 0x3fffffff
    }

    function createBuffer(that, length) {
      if (kMaxLength() < length) {
        throw new RangeError('Invalid typed array length')
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = new Uint8Array(length)
        that.__proto__ = Buffer.prototype
      } else {
        // Fallback: Return an object instance of the Buffer class
        if (that === null) {
          that = new Buffer(length)
        }
        that.length = length
      }

      return that
    }

    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */

    function Buffer(arg, encodingOrOffset, length) {
      if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
        return new Buffer(arg, encodingOrOffset, length)
      }

      // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new Error(
            'If encoding is specified then the first argument must be a string'
          )
        }
        return allocUnsafe(this, arg)
      }
      return from(this, arg, encodingOrOffset, length)
    }

    Buffer.poolSize = 8192 // not used by this implementation

    // TODO: Legacy, not needed anymore. Remove in next major version.
    Buffer._augment = function (arr) {
      arr.__proto__ = Buffer.prototype
      return arr
    }

    function from(that, value, encodingOrOffset, length) {
      if (typeof value === 'number') {
        throw new TypeError('"value" argument must not be a number')
      }

      if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
        return fromArrayBuffer(that, value, encodingOrOffset, length)
      }

      if (typeof value === 'string') {
        return fromString(that, value, encodingOrOffset)
      }

      return fromObject(that, value)
    }

    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/
    Buffer.from = function (value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length)
    }

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      Buffer.prototype.__proto__ = Uint8Array.prototype
      Buffer.__proto__ = Uint8Array
      if (typeof Symbol !== 'undefined' && Symbol.species &&
        Buffer[Symbol.species] === Buffer) {
        // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
        Object.defineProperty(Buffer, Symbol.species, {
          value: null,
          configurable: true
        })
      }
    }

    function assertSize(size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be a number')
      } else if (size < 0) {
        throw new RangeError('"size" argument must not be negative')
      }
    }

    function alloc(that, size, fill, encoding) {
      assertSize(size)
      if (size <= 0) {
        return createBuffer(that, size)
      }
      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpretted as a start offset.
        return typeof encoding === 'string'
          ? createBuffer(that, size).fill(fill, encoding)
          : createBuffer(that, size).fill(fill)
      }
      return createBuffer(that, size)
    }

    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/
    Buffer.alloc = function (size, fill, encoding) {
      return alloc(null, size, fill, encoding)
    }

    function allocUnsafe(that, size) {
      assertSize(size)
      that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
      if (!Buffer.TYPED_ARRAY_SUPPORT) {
        for (var i = 0; i < size; ++i) {
          that[i] = 0
        }
      }
      return that
    }

    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */
    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(null, size)
    }
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */
    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(null, size)
    }

    function fromString(that, string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8'
      }

      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding')
      }

      var length = byteLength(string, encoding) | 0
      that = createBuffer(that, length)

      var actual = that.write(string, encoding)

      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        that = that.slice(0, actual)
      }

      return that
    }

    function fromArrayLike(that, array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0
      that = createBuffer(that, length)
      for (var i = 0; i < length; i += 1) {
        that[i] = array[i] & 255
      }
      return that
    }

    function fromArrayBuffer(that, array, byteOffset, length) {
      array.byteLength // this throws if `array` is not a valid ArrayBuffer

      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('\'offset\' is out of bounds')
      }

      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('\'length\' is out of bounds')
      }

      if (byteOffset === undefined && length === undefined) {
        array = new Uint8Array(array)
      } else if (length === undefined) {
        array = new Uint8Array(array, byteOffset)
      } else {
        array = new Uint8Array(array, byteOffset, length)
      }

      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = array
        that.__proto__ = Buffer.prototype
      } else {
        // Fallback: Return an object instance of the Buffer class
        that = fromArrayLike(that, array)
      }
      return that
    }

    function fromObject(that, obj) {
      if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0
        that = createBuffer(that, len)

        if (that.length === 0) {
          return that
        }

        obj.copy(that, 0, 0, len)
        return that
      }

      if (obj) {
        if ((typeof ArrayBuffer !== 'undefined' &&
          obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
          if (typeof obj.length !== 'number' || isnan(obj.length)) {
            return createBuffer(that, 0)
          }
          return fromArrayLike(that, obj)
        }

        if (obj.type === 'Buffer' && isArray(obj.data)) {
          return fromArrayLike(that, obj.data)
        }
      }

      throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
    }

    function checked(length) {
      // Note: cannot use `length < kMaxLength()` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= kMaxLength()) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
          'size: 0x' + kMaxLength().toString(16) + ' bytes')
      }
      return length | 0
    }

    function SlowBuffer(length) {
      if (+length != length) { // eslint-disable-line eqeqeq
        length = 0
      }
      return Buffer.alloc(+length)
    }

    Buffer.isBuffer = function isBuffer(b) {
      return !!(b != null && b._isBuffer)
    }

    Buffer.compare = function compare(a, b) {
      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError('Arguments must be Buffers')
      }

      if (a === b) return 0

      var x = a.length
      var y = b.length

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i]
          y = b[i]
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    }

    Buffer.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true
        default:
          return false
      }
    }

    Buffer.concat = function concat(list, length) {
      if (!isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }

      if (list.length === 0) {
        return Buffer.alloc(0)
      }

      var i
      if (length === undefined) {
        length = 0
        for (i = 0; i < list.length; ++i) {
          length += list[i].length
        }
      }

      var buffer = Buffer.allocUnsafe(length)
      var pos = 0
      for (i = 0; i < list.length; ++i) {
        var buf = list[i]
        if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        }
        buf.copy(buffer, pos)
        pos += buf.length
      }
      return buffer
    }

    function byteLength(string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length
      }
      if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
        (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength
      }
      if (typeof string !== 'string') {
        string = '' + string
      }

      var len = string.length
      if (len === 0) return 0

      // Use a for loop to avoid recursion
      var loweredCase = false
      for (; ;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len
          case 'utf8':
          case 'utf-8':
          case undefined:
            return utf8ToBytes(string).length
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2
          case 'hex':
            return len >>> 1
          case 'base64':
            return base64ToBytes(string).length
          default:
            if (loweredCase) return utf8ToBytes(string).length // assume utf8
            encoding = ('' + encoding).toLowerCase()
            loweredCase = true
        }
      }
    }
    Buffer.byteLength = byteLength

    function slowToString(encoding, start, end) {
      var loweredCase = false

      // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.

      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
      if (start === undefined || start < 0) {
        start = 0
      }
      // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.
      if (start > this.length) {
        return ''
      }

      if (end === undefined || end > this.length) {
        end = this.length
      }

      if (end <= 0) {
        return ''
      }

      // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
      end >>>= 0
      start >>>= 0

      if (end <= start) {
        return ''
      }

      if (!encoding) encoding = 'utf8'

      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end)

          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end)

          case 'ascii':
            return asciiSlice(this, start, end)

          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end)

          case 'base64':
            return base64Slice(this, start, end)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = (encoding + '').toLowerCase()
            loweredCase = true
        }
      }
    }

    // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
    // Buffer instances.
    Buffer.prototype._isBuffer = true

    function swap(b, n, m) {
      var i = b[n]
      b[n] = b[m]
      b[m] = i
    }

    Buffer.prototype.swap16 = function swap16() {
      var len = this.length
      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits')
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1)
      }
      return this
    }

    Buffer.prototype.swap32 = function swap32() {
      var len = this.length
      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits')
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3)
        swap(this, i + 1, i + 2)
      }
      return this
    }

    Buffer.prototype.swap64 = function swap64() {
      var len = this.length
      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits')
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7)
        swap(this, i + 1, i + 6)
        swap(this, i + 2, i + 5)
        swap(this, i + 3, i + 4)
      }
      return this
    }

    Buffer.prototype.toString = function toString() {
      var length = this.length | 0
      if (length === 0) return ''
      if (arguments.length === 0) return utf8Slice(this, 0, length)
      return slowToString.apply(this, arguments)
    }

    Buffer.prototype.equals = function equals(b) {
      if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
      if (this === b) return true
      return Buffer.compare(this, b) === 0
    }

    Buffer.prototype.inspect = function inspect() {
      var str = ''
      var max = exports.INSPECT_MAX_BYTES
      if (this.length > 0) {
        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
        if (this.length > max) str += ' ... '
      }
      return '<Buffer ' + str + '>'
    }

    Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (!Buffer.isBuffer(target)) {
        throw new TypeError('Argument must be a Buffer')
      }

      if (start === undefined) {
        start = 0
      }
      if (end === undefined) {
        end = target ? target.length : 0
      }
      if (thisStart === undefined) {
        thisStart = 0
      }
      if (thisEnd === undefined) {
        thisEnd = this.length
      }

      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index')
      }

      if (thisStart >= thisEnd && start >= end) {
        return 0
      }
      if (thisStart >= thisEnd) {
        return -1
      }
      if (start >= end) {
        return 1
      }

      start >>>= 0
      end >>>= 0
      thisStart >>>= 0
      thisEnd >>>= 0

      if (this === target) return 0

      var x = thisEnd - thisStart
      var y = end - start
      var len = Math.min(x, y)

      var thisCopy = this.slice(thisStart, thisEnd)
      var targetCopy = target.slice(start, end)

      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i]
          y = targetCopy[i]
          break
        }
      }

      if (x < y) return -1
      if (y < x) return 1
      return 0
    }

    // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1

      // Normalize byteOffset
      if (typeof byteOffset === 'string') {
        encoding = byteOffset
        byteOffset = 0
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000
      }
      byteOffset = +byteOffset  // Coerce to Number.
      if (isNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : (buffer.length - 1)
      }

      // Normalize byteOffset: negative offsets start from the end of the buffer
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset
      if (byteOffset >= buffer.length) {
        if (dir) return -1
        else byteOffset = buffer.length - 1
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0
        else return -1
      }

      // Normalize val
      if (typeof val === 'string') {
        val = Buffer.from(val, encoding)
      }

      // Finally, search either indexOf (if dir is true) or lastIndexOf
      if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
      } else if (typeof val === 'number') {
        val = val & 0xFF // Search for a byte value [0-255]
        if (Buffer.TYPED_ARRAY_SUPPORT &&
          typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
      }

      throw new TypeError('val must be string, number or Buffer')
    }

    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1
      var arrLength = arr.length
      var valLength = val.length

      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase()
        if (encoding === 'ucs2' || encoding === 'ucs-2' ||
          encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1
          }
          indexSize = 2
          arrLength /= 2
          valLength /= 2
          byteOffset /= 2
        }
      }

      function read(buf, i) {
        if (indexSize === 1) {
          return buf[i]
        } else {
          return buf.readUInt16BE(i * indexSize)
        }
      }

      var i
      if (dir) {
        var foundIndex = -1
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
          } else {
            if (foundIndex !== -1) i -= i - foundIndex
            foundIndex = -1
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
        for (i = byteOffset; i >= 0; i--) {
          var found = true
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false
              break
            }
          }
          if (found) return i
        }
      }

      return -1
    }

    Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1
    }

    Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
    }

    Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
    }

    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0
      var remaining = buf.length - offset
      if (!length) {
        length = remaining
      } else {
        length = Number(length)
        if (length > remaining) {
          length = remaining
        }
      }

      // must be an even number of digits
      var strLen = string.length
      if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

      if (length > strLen / 2) {
        length = strLen / 2
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16)
        if (isNaN(parsed)) return i
        buf[offset + i] = parsed
      }
      return i
    }

    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
    }

    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length)
    }

    function latin1Write(buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length)
    }

    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length)
    }

    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
    }

    Buffer.prototype.write = function write(string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8'
        length = this.length
        offset = 0
        // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset
        length = this.length
        offset = 0
        // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset | 0
        if (isFinite(length)) {
          length = length | 0
          if (encoding === undefined) encoding = 'utf8'
        } else {
          encoding = length
          length = undefined
        }
        // legacy write(string, encoding, offset, length) - remove in v0.13
      } else {
        throw new Error(
          'Buffer.write(string, encoding, offset[, length]) is no longer supported'
        )
      }

      var remaining = this.length - offset
      if (length === undefined || length > remaining) length = remaining

      if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds')
      }

      if (!encoding) encoding = 'utf8'

      var loweredCase = false
      for (; ;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length)

          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length)

          case 'ascii':
            return asciiWrite(this, string, offset, length)

          case 'latin1':
          case 'binary':
            return latin1Write(this, string, offset, length)

          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length)

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length)

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = ('' + encoding).toLowerCase()
            loweredCase = true
        }
      }
    }

    Buffer.prototype.toJSON = function toJSON() {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    }

    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf)
      } else {
        return base64.fromByteArray(buf.slice(start, end))
      }
    }

    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end)
      var res = []

      var i = start
      while (i < end) {
        var firstByte = buf[i]
        var codePoint = null
        var bytesPerSequence = (firstByte > 0xEF) ? 4
          : (firstByte > 0xDF) ? 3
            : (firstByte > 0xBF) ? 2
              : 1

        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint

          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte
              }
              break
            case 2:
              secondByte = buf[i + 1]
              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint
                }
              }
              break
            case 3:
              secondByte = buf[i + 1]
              thirdByte = buf[i + 2]
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint
                }
              }
              break
            case 4:
              secondByte = buf[i + 1]
              thirdByte = buf[i + 2]
              fourthByte = buf[i + 3]
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint
                }
              }
          }
        }

        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD
          bytesPerSequence = 1
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000
          res.push(codePoint >>> 10 & 0x3FF | 0xD800)
          codePoint = 0xDC00 | codePoint & 0x3FF
        }

        res.push(codePoint)
        i += bytesPerSequence
      }

      return decodeCodePointsArray(res)
    }

    // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety
    var MAX_ARGUMENTS_LENGTH = 0x1000

    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
      }

      // Decode in chunks to avoid "call stack size exceeded".
      var res = ''
      var i = 0
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        )
      }
      return res
    }

    function asciiSlice(buf, start, end) {
      var ret = ''
      end = Math.min(buf.length, end)

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F)
      }
      return ret
    }

    function latin1Slice(buf, start, end) {
      var ret = ''
      end = Math.min(buf.length, end)

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i])
      }
      return ret
    }

    function hexSlice(buf, start, end) {
      var len = buf.length

      if (!start || start < 0) start = 0
      if (!end || end < 0 || end > len) end = len

      var out = ''
      for (var i = start; i < end; ++i) {
        out += toHex(buf[i])
      }
      return out
    }

    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end)
      var res = ''
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
      }
      return res
    }

    Buffer.prototype.slice = function slice(start, end) {
      var len = this.length
      start = ~~start
      end = end === undefined ? len : ~~end

      if (start < 0) {
        start += len
        if (start < 0) start = 0
      } else if (start > len) {
        start = len
      }

      if (end < 0) {
        end += len
        if (end < 0) end = 0
      } else if (end > len) {
        end = len
      }

      if (end < start) end = start

      var newBuf
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end)
        newBuf.__proto__ = Buffer.prototype
      } else {
        var sliceLen = end - start
        newBuf = new Buffer(sliceLen, undefined)
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start]
        }
      }

      return newBuf
    }

    /*
      * Need to make sure that buffer isn't trying to write out of bounds.
      */
    function checkOffset(offset, ext, length) {
      if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
    }

    Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) checkOffset(offset, byteLength, this.length)

      var val = this[offset]
      var mul = 1
      var i = 0
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul
      }

      return val
    }

    Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length)
      }

      var val = this[offset + --byteLength]
      var mul = 1
      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul
      }

      return val
    }

    Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length)
      return this[offset]
    }

    Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length)
      return this[offset] | (this[offset + 1] << 8)
    }

    Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length)
      return (this[offset] << 8) | this[offset + 1]
    }

    Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)

      return ((this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16)) +
        (this[offset + 3] * 0x1000000)
    }

    Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)

      return (this[offset] * 0x1000000) +
        ((this[offset + 1] << 16) |
          (this[offset + 2] << 8) |
          this[offset + 3])
    }

    Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) checkOffset(offset, byteLength, this.length)

      var val = this[offset]
      var mul = 1
      var i = 0
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul
      }
      mul *= 0x80

      if (val >= mul) val -= Math.pow(2, 8 * byteLength)

      return val
    }

    Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) checkOffset(offset, byteLength, this.length)

      var i = byteLength
      var mul = 1
      var val = this[offset + --i]
      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul
      }
      mul *= 0x80

      if (val >= mul) val -= Math.pow(2, 8 * byteLength)

      return val
    }

    Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length)
      if (!(this[offset] & 0x80)) return (this[offset])
      return ((0xff - this[offset] + 1) * -1)
    }

    Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length)
      var val = this[offset] | (this[offset + 1] << 8)
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    }

    Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length)
      var val = this[offset + 1] | (this[offset] << 8)
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    }

    Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)

      return (this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16) |
        (this[offset + 3] << 24)
    }

    Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)

      return (this[offset] << 24) |
        (this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        (this[offset + 3])
    }

    Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)
      return ieee754.read(this, offset, true, 23, 4)
    }

    Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)
      return ieee754.read(this, offset, false, 23, 4)
    }

    Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length)
      return ieee754.read(this, offset, true, 52, 8)
    }

    Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length)
      return ieee754.read(this, offset, false, 52, 8)
    }

    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
    }

    Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
      value = +value
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1
        checkInt(this, value, offset, byteLength, maxBytes, 0)
      }

      var mul = 1
      var i = 0
      this[offset] = value & 0xFF
      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF
      }

      return offset + byteLength
    }

    Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
      value = +value
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1
        checkInt(this, value, offset, byteLength, maxBytes, 0)
      }

      var i = byteLength - 1
      var mul = 1
      this[offset + i] = value & 0xFF
      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF
      }

      return offset + byteLength
    }

    Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
      this[offset] = (value & 0xff)
      return offset + 1
    }

    function objectWriteUInt16(buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffff + value + 1
      for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
        buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
          (littleEndian ? i : 1 - i) * 8
      }
    }

    Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff)
        this[offset + 1] = (value >>> 8)
      } else {
        objectWriteUInt16(this, value, offset, true)
      }
      return offset + 2
    }

    Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8)
        this[offset + 1] = (value & 0xff)
      } else {
        objectWriteUInt16(this, value, offset, false)
      }
      return offset + 2
    }

    function objectWriteUInt32(buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffffffff + value + 1
      for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
        buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
      }
    }

    Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = (value >>> 24)
        this[offset + 2] = (value >>> 16)
        this[offset + 1] = (value >>> 8)
        this[offset] = (value & 0xff)
      } else {
        objectWriteUInt32(this, value, offset, true)
      }
      return offset + 4
    }

    Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24)
        this[offset + 1] = (value >>> 16)
        this[offset + 2] = (value >>> 8)
        this[offset + 3] = (value & 0xff)
      } else {
        objectWriteUInt32(this, value, offset, false)
      }
      return offset + 4
    }

    Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1)

        checkInt(this, value, offset, byteLength, limit - 1, -limit)
      }

      var i = 0
      var mul = 1
      var sub = 0
      this[offset] = value & 0xFF
      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
      }

      return offset + byteLength
    }

    Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1)

        checkInt(this, value, offset, byteLength, limit - 1, -limit)
      }

      var i = byteLength - 1
      var mul = 1
      var sub = 0
      this[offset + i] = value & 0xFF
      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
      }

      return offset + byteLength
    }

    Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
      if (value < 0) value = 0xff + value + 1
      this[offset] = (value & 0xff)
      return offset + 1
    }

    Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff)
        this[offset + 1] = (value >>> 8)
      } else {
        objectWriteUInt16(this, value, offset, true)
      }
      return offset + 2
    }

    Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8)
        this[offset + 1] = (value & 0xff)
      } else {
        objectWriteUInt16(this, value, offset, false)
      }
      return offset + 2
    }

    Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff)
        this[offset + 1] = (value >>> 8)
        this[offset + 2] = (value >>> 16)
        this[offset + 3] = (value >>> 24)
      } else {
        objectWriteUInt32(this, value, offset, true)
      }
      return offset + 4
    }

    Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
      if (value < 0) value = 0xffffffff + value + 1
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24)
        this[offset + 1] = (value >>> 16)
        this[offset + 2] = (value >>> 8)
        this[offset + 3] = (value & 0xff)
      } else {
        objectWriteUInt32(this, value, offset, false)
      }
      return offset + 4
    }

    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
      if (offset < 0) throw new RangeError('Index out of range')
    }

    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4)
      return offset + 4
    }

    Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert)
    }

    Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert)
    }

    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8)
      return offset + 8
    }

    Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert)
    }

    Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert)
    }

    // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    Buffer.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start) start = 0
      if (!end && end !== 0) end = this.length
      if (targetStart >= target.length) targetStart = target.length
      if (!targetStart) targetStart = 0
      if (end > 0 && end < start) end = start

      // Copy 0 bytes; we're done
      if (end === start) return 0
      if (target.length === 0 || this.length === 0) return 0

      // Fatal error conditions
      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds')
      }
      if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
      if (end < 0) throw new RangeError('sourceEnd out of bounds')

      // Are we oob?
      if (end > this.length) end = this.length
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start
      }

      var len = end - start
      var i

      if (this === target && start < targetStart && targetStart < end) {
        // descending copy from end
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start]
        }
      } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
        // ascending copy from start
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start]
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        )
      }

      return len
    }

    // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])
    Buffer.prototype.fill = function fill(val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start
          start = 0
          end = this.length
        } else if (typeof end === 'string') {
          encoding = end
          end = this.length
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0)
          if (code < 256) {
            val = code
          }
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string')
        }
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding)
        }
      } else if (typeof val === 'number') {
        val = val & 255
      }

      // Invalid ranges are not set to a default, so can range check early.
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index')
      }

      if (end <= start) {
        return this
      }

      start = start >>> 0
      end = end === undefined ? this.length : end >>> 0

      if (!val) val = 0

      var i
      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val
        }
      } else {
        var bytes = Buffer.isBuffer(val)
          ? val
          : utf8ToBytes(new Buffer(val, encoding).toString())
        var len = bytes.length
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len]
        }
      }

      return this
    }

    // HELPER FUNCTIONS
    // ================

    var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

    function base64clean(str) {
      // Node strips out invalid characters like \n and \t from the string, base64-js does not
      str = stringtrim(str).replace(INVALID_BASE64_RE, '')
      // Node converts strings with length < 2 to ''
      if (str.length < 2) return ''
      // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
      while (str.length % 4 !== 0) {
        str = str + '='
      }
      return str
    }

    function stringtrim(str) {
      if (str.trim) return str.trim()
      return str.replace(/^\s+|\s+$/g, '')
    }

    function toHex(n) {
      if (n < 16) return '0' + n.toString(16)
      return n.toString(16)
    }

    function utf8ToBytes(string, units) {
      units = units || Infinity
      var codePoint
      var length = string.length
      var leadSurrogate = null
      var bytes = []

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i)

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
              continue
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
              continue
            }

            // valid lead
            leadSurrogate = codePoint

            continue
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
            leadSurrogate = codePoint
            continue
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        }

        leadSurrogate = null

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          bytes.push(codePoint)
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          bytes.push(
            codePoint >> 0x6 | 0xC0,
            codePoint & 0x3F | 0x80
          )
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          bytes.push(
            codePoint >> 0xC | 0xE0,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          )
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          bytes.push(
            codePoint >> 0x12 | 0xF0,
            codePoint >> 0xC & 0x3F | 0x80,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          )
        } else {
          throw new Error('Invalid code point')
        }
      }

      return bytes
    }

    function asciiToBytes(str) {
      var byteArray = []
      for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF)
      }
      return byteArray
    }

    function utf16leToBytes(str, units) {
      var c, hi, lo
      var byteArray = []
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break

        c = str.charCodeAt(i)
        hi = c >> 8
        lo = c % 256
        byteArray.push(lo)
        byteArray.push(hi)
      }

      return byteArray
    }

    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str))
    }

    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if ((i + offset >= dst.length) || (i >= src.length)) break
        dst[i + offset] = src[i]
      }
      return i
    }

    function isnan(val) {
      return val !== val // eslint-disable-line no-self-compare
    }

  }, { "base64-js": "yh9p", "ieee754": "JgNJ", "isarray": "REa7", "buffer": "dskh" }], "QO4x": [function (require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var global = arguments[3];
    var FILE_SYSTEM_NAME = require('../constants.js').FILE_SYSTEM_NAME;

    var FILE_STORE_NAME = require('../constants.js').FILE_STORE_NAME;

    var IDB_RW = require('../constants.js').IDB_RW;

    var IDB_RO = require('../constants.js').IDB_RO;

    function IndexedDBContext(db, mode) {
      this.db = db;
      this.mode = mode;
    }

    IndexedDBContext.prototype._getObjectStore = function () {
      if (this.objectStore) {
        return this.objectStore;
      }

      var transaction = this.db.transaction(FILE_STORE_NAME, this.mode);
      this.objectStore = transaction.objectStore(FILE_STORE_NAME);
      return this.objectStore;
    };

    IndexedDBContext.prototype.clear = function (callback) {
      try {
        var objectStore = this._getObjectStore();

        var request = objectStore.clear();

        request.onsuccess = function () {
          callback();
        };

        request.onerror = function (event) {
          event.preventDefault();
          callback(event.error);
        };
      } catch (err) {
        callback(err);
      }
    };

    IndexedDBContext.prototype._get = function (key, callback) {
      try {
        var objectStore = this._getObjectStore();

        var request = objectStore.get(key);

        request.onsuccess = function onsuccess(event) {
          var result = event.target.result;
          callback(null, result);
        };

        request.onerror = function (event) {
          event.preventDefault();
          callback(event.error);
        };
      } catch (err) {
        callback(err);
      }
    };

    IndexedDBContext.prototype.getObject = function (key, callback) {
      this._get(key, callback);
    };

    IndexedDBContext.prototype.getBuffer = function (key, callback) {
      this._get(key, function (err, arrayBuffer) {
        if (err) {
          return callback(err);
        }

        callback(null, Buffer.from(arrayBuffer));
      });
    };

    IndexedDBContext.prototype._put = function (key, value, callback) {
      try {
        var objectStore = this._getObjectStore();

        var request = objectStore.put(value, key);

        request.onsuccess = function onsuccess(event) {
          var result = event.target.result;
          callback(null, result);
        };

        request.onerror = function (event) {
          event.preventDefault();
          callback(event.error);
        };
      } catch (err) {
        callback(err);
      }
    };

    IndexedDBContext.prototype.putObject = function (key, value, callback) {
      this._put(key, value, callback);
    };

    IndexedDBContext.prototype.putBuffer = function (key, uint8BackedBuffer, callback) {
      var buf = uint8BackedBuffer.buffer;

      this._put(key, buf, callback);
    };

    IndexedDBContext.prototype.delete = function (key, callback) {
      try {
        var objectStore = this._getObjectStore();

        var request = objectStore.delete(key);

        request.onsuccess = function onsuccess(event) {
          var result = event.target.result;
          callback(null, result);
        };

        request.onerror = function (event) {
          event.preventDefault();
          callback(event.error);
        };
      } catch (err) {
        callback(err);
      }
    };

    function IndexedDB(name) {
      this.name = name || FILE_SYSTEM_NAME;
      this.db = null;
    }

    IndexedDB.isSupported = function () {
      var indexedDB = global.indexedDB || global.mozIndexedDB || global.webkitIndexedDB || global.msIndexedDB;
      return !!indexedDB;
    };

    IndexedDB.prototype.open = function (callback) {
      var that = this; // Bail if we already have a db open

      if (that.db) {
        return callback();
      }

      try {
        var indexedDB = global.indexedDB || global.mozIndexedDB || global.webkitIndexedDB || global.msIndexedDB; // NOTE: we're not using versioned databases.

        var openRequest = indexedDB.open(that.name); // If the db doesn't exist, we'll create it

        openRequest.onupgradeneeded = function onupgradeneeded(event) {
          var db = event.target.result;

          if (db.objectStoreNames.contains(FILE_STORE_NAME)) {
            db.deleteObjectStore(FILE_STORE_NAME);
          }

          db.createObjectStore(FILE_STORE_NAME);
        };

        openRequest.onsuccess = function onsuccess(event) {
          that.db = event.target.result;
          callback();
        };

        openRequest.onerror = function onerror(event) {
          event.preventDefault();
          callback(event.error);
        };
      } catch (err) {
        callback(err);
      }
    };

    IndexedDB.prototype.getReadOnlyContext = function () {
      return new IndexedDBContext(this.db, IDB_RO);
    };

    IndexedDB.prototype.getReadWriteContext = function () {
      return new IndexedDBContext(this.db, IDB_RW);
    };

    module.exports = IndexedDB;
  }, { "../constants.js": "iJA9", "buffer": "dskh" }], "u4Zs": [function (require, module, exports) {
    var process = require("process");
    var define;
    /*global setImmediate: false, setTimeout: false, console: false */

    /**
     * async.js shim, based on https://raw.github.com/caolan/async/master/lib/async.js Feb 18, 2014
     * Used under MIT - https://github.com/caolan/async/blob/master/LICENSE
     */
    (function () {
      var async = {}; // async.js functions used in Filer
      //// nextTick implementation with browser-compatible fallback ////

      if (typeof process === 'undefined' || !process.nextTick) {
        if (typeof setImmediate === 'function') {
          async.nextTick = function (fn) {
            // not a direct alias for IE10 compatibility
            setImmediate(fn);
          };

          async.setImmediate = async.nextTick;
        } else {
          async.nextTick = function (fn) {
            setTimeout(fn, 0);
          };

          async.setImmediate = async.nextTick;
        }
      } else {
        async.nextTick = process.nextTick;

        if (typeof setImmediate !== 'undefined') {
          async.setImmediate = function (fn) {
            // not a direct alias for IE10 compatibility
            setImmediate(fn);
          };
        } else {
          async.setImmediate = async.nextTick;
        }
      }

      async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () { };

        if (!arr.length) {
          return callback();
        }

        var completed = 0;

        var iterate = function iterate() {
          iterator(arr[completed], function (err) {
            if (err) {
              callback(err);

              callback = function callback() { };
            } else {
              completed += 1;

              if (completed >= arr.length) {
                callback();
              } else {
                iterate();
              }
            }
          });
        };

        iterate();
      };

      async.forEachSeries = async.eachSeries; // AMD / RequireJS

      if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
          return async;
        });
      } // Node.js
      else if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
      } // included directly via <script> tag
      else {
        root.async = async;
      }
    })();
  }, { "process": "pBGv" }], "OWym": [function (require, module, exports) {
    var FILE_SYSTEM_NAME = require('../constants.js').FILE_SYSTEM_NAME; // NOTE: prefer setImmediate to nextTick for proper recursion yielding.
    // see https://github.com/js-platform/filer/pull/24


    var asyncCallback = require('../../lib/async.js').setImmediate;
    /**
     * Make shared in-memory DBs possible when using the same name.
     */


    var createDB = function () {
      var pool = {};
      return function getOrCreate(name) {
        if (!Object.prototype.hasOwnProperty.call(pool, name)) {
          pool[name] = {};
        }

        return pool[name];
      };
    }();

    function MemoryContext(db, readOnly) {
      this.readOnly = readOnly;
      this.objectStore = db;
    }

    MemoryContext.prototype.clear = function (callback) {
      if (this.readOnly) {
        asyncCallback(function () {
          callback('[MemoryContext] Error: write operation on read only context');
        });
        return;
      }

      var objectStore = this.objectStore;
      Object.keys(objectStore).forEach(function (key) {
        delete objectStore[key];
      });
      asyncCallback(callback);
    }; // Memory context doesn't care about differences between Object and Buffer


    MemoryContext.prototype.getObject = MemoryContext.prototype.getBuffer = function (key, callback) {
      var that = this;
      asyncCallback(function () {
        callback(null, that.objectStore[key]);
      });
    };

    MemoryContext.prototype.putObject = MemoryContext.prototype.putBuffer = function (key, value, callback) {
      if (this.readOnly) {
        asyncCallback(function () {
          callback('[MemoryContext] Error: write operation on read only context');
        });
        return;
      }

      this.objectStore[key] = value;
      asyncCallback(callback);
    };

    MemoryContext.prototype.delete = function (key, callback) {
      if (this.readOnly) {
        asyncCallback(function () {
          callback('[MemoryContext] Error: write operation on read only context');
        });
        return;
      }

      delete this.objectStore[key];
      asyncCallback(callback);
    };

    function Memory(name) {
      this.name = name || FILE_SYSTEM_NAME;
    }

    Memory.isSupported = function () {
      return true;
    };

    Memory.prototype.open = function (callback) {
      this.db = createDB(this.name);
      asyncCallback(callback);
    };

    Memory.prototype.getReadOnlyContext = function () {
      return new MemoryContext(this.db, true);
    };

    Memory.prototype.getReadWriteContext = function () {
      return new MemoryContext(this.db, false);
    };

    module.exports = Memory;
  }, { "../constants.js": "iJA9", "../../lib/async.js": "u4Zs" }], "AiW7": [function (require, module, exports) {
    var IndexedDB = require('./indexeddb.js');

    var Memory = require('./memory.js');

    module.exports = {
      IndexedDB: IndexedDB,
      Default: IndexedDB,
      Memory: Memory
    };
  }, { "./indexeddb.js": "QO4x", "./memory.js": "OWym" }], "p8GN": [function (require, module, exports) {
    var errors = {};
    [
      /**
       * node.js errors - we only use some of these, add as needed.
       */
      //'-1:UNKNOWN:unknown error',
      //'0:OK:success',
      //'1:EOF:end of file',
      //'2:EADDRINFO:getaddrinfo error',
      '3:EACCES:permission denied', //'4:EAGAIN:resource temporarily unavailable',
      //'5:EADDRINUSE:address already in use',
      //'6:EADDRNOTAVAIL:address not available',
      //'7:EAFNOSUPPORT:address family not supported',
      //'8:EALREADY:connection already in progress',
      '9:EBADF:bad file descriptor', '10:EBUSY:resource busy or locked', //'11:ECONNABORTED:software caused connection abort',
      //'12:ECONNREFUSED:connection refused',
      //'13:ECONNRESET:connection reset by peer',
      //'14:EDESTADDRREQ:destination address required',
      //'15:EFAULT:bad address in system call argument',
      //'16:EHOSTUNREACH:host is unreachable',
      //'17:EINTR:interrupted system call',
      '18:EINVAL:invalid argument', //'19:EISCONN:socket is already connected',
      //'20:EMFILE:too many open files',
      //'21:EMSGSIZE:message too long',
      //'22:ENETDOWN:network is down',
      //'23:ENETUNREACH:network is unreachable',
      //'24:ENFILE:file table overflow',
      //'25:ENOBUFS:no buffer space available',
      //'26:ENOMEM:not enough memory',
      '27:ENOTDIR:not a directory', '28:EISDIR:illegal operation on a directory', //'29:ENONET:machine is not on the network',
      // errno 30 skipped, as per https://github.com/rvagg/node-errno/blob/master/errno.js
      //'31:ENOTCONN:socket is not connected',
      //'32:ENOTSOCK:socket operation on non-socket',
      //'33:ENOTSUP:operation not supported on socket',
      '34:ENOENT:no such file or directory', //'35:ENOSYS:function not implemented',
      //'36:EPIPE:broken pipe',
      //'37:EPROTO:protocol error',
      //'38:EPROTONOSUPPORT:protocol not supported',
      //'39:EPROTOTYPE:protocol wrong type for socket',
      //'40:ETIMEDOUT:connection timed out',
      //'41:ECHARSET:invalid Unicode character',
      //'42:EAIFAMNOSUPPORT:address family for hostname not supported',
      // errno 43 skipped, as per https://github.com/rvagg/node-errno/blob/master/errno.js
      //'44:EAISERVICE:servname not supported for ai_socktype',
      //'45:EAISOCKTYPE:ai_socktype not supported',
      //'46:ESHUTDOWN:cannot send after transport endpoint shutdown',
      '47:EEXIST:file already exists', //'48:ESRCH:no such process',
      //'49:ENAMETOOLONG:name too long',
      '50:EPERM:operation not permitted', '51:ELOOP:too many symbolic links encountered', //'52:EXDEV:cross-device link not permitted',
      '53:ENOTEMPTY:directory not empty', //'54:ENOSPC:no space left on device',
      '55:EIO:i/o error', //'56:EROFS:read-only file system',
      //'57:ENODEV:no such device',
      //'58:ESPIPE:invalid seek',
      //'59:ECANCELED:operation canceled',

      /**
       * Filer specific errors
       */
      '1000:ENOTMOUNTED:not mounted', '1001:EFILESYSTEMERROR:missing super node, use \'FORMAT\' flag to format filesystem.', '1002:ENOATTR:attribute does not exist'].forEach(function (e) {
        e = e.split(':');
        var errno = +e[0];
        var errName = e[1];
        var defaultMessage = e[2];

        function FilerError(msg, path) {
          Error.call(this);
          this.name = errName;
          this.code = errName;
          this.errno = errno;
          this.message = msg || defaultMessage;

          if (path) {
            this.path = path;
          }

          this.stack = new Error(this.message).stack;
        }

        FilerError.prototype = Object.create(Error.prototype);
        FilerError.prototype.constructor = FilerError;

        FilerError.prototype.toString = function () {
          var pathInfo = this.path ? ', \'' + this.path + '\'' : '';
          return this.name + ': ' + this.message + pathInfo;
        }; // We expose the error as both Errors.EINVAL and Errors[18]


        errors[errName] = errors[errno] = FilerError;
      });
    module.exports = errors;
  }, {}], "QMiB": [function (require, module, exports) {
    'use strict';

    var defaults = require('../constants.js').ENVIRONMENT;

    module.exports = function Environment(env) {
      env = env || {};
      env.TMP = env.TMP || defaults.TMP;
      env.PATH = env.PATH || defaults.PATH;

      this.get = function (name) {
        return env[name];
      };

      this.set = function (name, value) {
        env[name] = value;
      };
    };
  }, { "../constants.js": "iJA9" }], "bQx9": [function (require, module, exports) {
    module.exports = function (xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
      }
      return res;
    };

    var isArray = Array.isArray || function (xs) {
      return Object.prototype.toString.call(xs) === '[object Array]';
    };

  }, {}], "D9yG": [function (require, module, exports) {
    'use strict';
    module.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp) a = maybeMatch(a, str);
      if (b instanceof RegExp) b = maybeMatch(b, str);

      var r = range(a, b, str);

      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }

    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }

    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;

      if (ai >= 0 && bi > 0) {
        begs = [];
        left = str.length;

        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }

            bi = str.indexOf(b, i + 1);
          }

          i = ai < bi && ai >= 0 ? ai : bi;
        }

        if (begs.length) {
          result = [left, right];
        }
      }

      return result;
    }

  }, {}], "dwXQ": [function (require, module, exports) {
    var concatMap = require('concat-map');
    var balanced = require('balanced-match');

    module.exports = expandTop;

    var escSlash = '\0SLASH' + Math.random() + '\0';
    var escOpen = '\0OPEN' + Math.random() + '\0';
    var escClose = '\0CLOSE' + Math.random() + '\0';
    var escComma = '\0COMMA' + Math.random() + '\0';
    var escPeriod = '\0PERIOD' + Math.random() + '\0';

    function numeric(str) {
      return parseInt(str, 10) == str
        ? parseInt(str, 10)
        : str.charCodeAt(0);
    }

    function escapeBraces(str) {
      return str.split('\\\\').join(escSlash)
        .split('\\{').join(escOpen)
        .split('\\}').join(escClose)
        .split('\\,').join(escComma)
        .split('\\.').join(escPeriod);
    }

    function unescapeBraces(str) {
      return str.split(escSlash).join('\\')
        .split(escOpen).join('{')
        .split(escClose).join('}')
        .split(escComma).join(',')
        .split(escPeriod).join('.');
    }


    // Basically just str.split(","), but handling cases
    // where we have nested braced sections, which should be
    // treated as individual members, like {a,{b,c},d}
    function parseCommaParts(str) {
      if (!str)
        return [''];

      var parts = [];
      var m = balanced('{', '}', str);

      if (!m)
        return str.split(',');

      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(',');

      p[p.length - 1] += '{' + body + '}';
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }

      parts.push.apply(parts, p);

      return parts;
    }

    function expandTop(str) {
      if (!str)
        return [];

      // I don't know why Bash 4.3 does this, but it does.
      // Anything starting with {} will have the first two bytes preserved
      // but *only* at the top level, so {},a}b will not expand to anything,
      // but a{},b}c will be expanded to [a}c,abc].
      // One could argue that this is a bug in Bash, but since the goal of
      // this module is to match Bash's rules, we escape a leading {}
      if (str.substr(0, 2) === '{}') {
        str = '\\{\\}' + str.substr(2);
      }

      return expand(escapeBraces(str), true).map(unescapeBraces);
    }

    function identity(e) {
      return e;
    }

    function embrace(str) {
      return '{' + str + '}';
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }

    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }

    function expand(str, isTop) {
      var expansions = [];

      var m = balanced('{', '}', str);
      if (!m || /\$$/.test(m.pre)) return [str];

      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(',') >= 0;
      if (!isSequence && !isOptions) {
        // {a},b}
        if (m.post.match(/,.*\}/)) {
          str = m.pre + '{' + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }

      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          // x{{a,b}}y ==> x{a}y x{b}y
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length
              ? expand(m.post, false)
              : [''];
            return post.map(function (p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }

      // at this point, n is the parts, and we know it's not a comma set
      // with a single entry.

      // no need to expand pre, since it is guaranteed to be free of brace-sets
      var pre = m.pre;
      var post = m.post.length
        ? expand(m.post, false)
        : [''];

      var N;

      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length)
        var incr = n.length == 3
          ? Math.abs(numeric(n[2]))
          : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);

        N = [];

        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === '\\')
              c = '';
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join('0');
                if (i < 0)
                  c = '-' + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function (el) { return expand(el, false) });
      }

      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }

      return expansions;
    }


  }, { "concat-map": "bQx9", "balanced-match": "D9yG" }], "NtKi": [function (require, module, exports) {
    module.exports = minimatch
    minimatch.Minimatch = Minimatch

    var path = { sep: '/' }
    try {
      path = require('path')
    } catch (er) { }

    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
    var expand = require('brace-expansion')

    var plTypes = {
      '!': { open: '(?:(?!(?:', close: '))[^/]*?)' },
      '?': { open: '(?:', close: ')?' },
      '+': { open: '(?:', close: ')+' },
      '*': { open: '(?:', close: ')*' },
      '@': { open: '(?:', close: ')' }
    }

    // any single thing other than /
    // don't need to escape / when using new RegExp()
    var qmark = '[^/]'

    // * => any number of characters
    var star = qmark + '*?'

    // ** when dots are allowed.  Anything goes, except .. and .
    // not (^ or / followed by one or two dots followed by $ or /),
    // followed by anything, any number of times.
    var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

    // not a ^ or / followed by a dot,
    // followed by anything, any number of times.
    var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

    // characters that need to be escaped in RegExp.
    var reSpecials = charSet('().*{}+?[]^$\\!')

    // "abc" -> { a:true, b:true, c:true }
    function charSet(s) {
      return s.split('').reduce(function (set, c) {
        set[c] = true
        return set
      }, {})
    }

    // normalizes slashes.
    var slashSplit = /\/+/

    minimatch.filter = filter
    function filter(pattern, options) {
      options = options || {}
      return function (p, i, list) {
        return minimatch(p, pattern, options)
      }
    }

    function ext(a, b) {
      a = a || {}
      b = b || {}
      var t = {}
      Object.keys(b).forEach(function (k) {
        t[k] = b[k]
      })
      Object.keys(a).forEach(function (k) {
        t[k] = a[k]
      })
      return t
    }

    minimatch.defaults = function (def) {
      if (!def || !Object.keys(def).length) return minimatch

      var orig = minimatch

      var m = function minimatch(p, pattern, options) {
        return orig.minimatch(p, pattern, ext(def, options))
      }

      m.Minimatch = function Minimatch(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options))
      }

      return m
    }

    Minimatch.defaults = function (def) {
      if (!def || !Object.keys(def).length) return Minimatch
      return minimatch.defaults(def).Minimatch
    }

    function minimatch(p, pattern, options) {
      if (typeof pattern !== 'string') {
        throw new TypeError('glob pattern string required')
      }

      if (!options) options = {}

      // shortcut: comments match nothing.
      if (!options.nocomment && pattern.charAt(0) === '#') {
        return false
      }

      // "" only matches ""
      if (pattern.trim() === '') return p === ''

      return new Minimatch(pattern, options).match(p)
    }

    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options)
      }

      if (typeof pattern !== 'string') {
        throw new TypeError('glob pattern string required')
      }

      if (!options) options = {}
      pattern = pattern.trim()

      // windows support: need to use /, not \
      if (path.sep !== '/') {
        pattern = pattern.split(path.sep).join('/')
      }

      this.options = options
      this.set = []
      this.pattern = pattern
      this.regexp = null
      this.negate = false
      this.comment = false
      this.empty = false

      // make the set of regexps etc.
      this.make()
    }

    Minimatch.prototype.debug = function () { }

    Minimatch.prototype.make = make
    function make() {
      // don't do it more than once.
      if (this._made) return

      var pattern = this.pattern
      var options = this.options

      // empty patterns and comments match nothing.
      if (!options.nocomment && pattern.charAt(0) === '#') {
        this.comment = true
        return
      }
      if (!pattern) {
        this.empty = true
        return
      }

      // step 1: figure out negation, etc.
      this.parseNegate()

      // step 2: expand braces
      var set = this.globSet = this.braceExpand()

      if (options.debug) this.debug = console.error

      this.debug(this.pattern, set)

      // step 3: now we have a set, so turn each one into a series of path-portion
      // matching patterns.
      // These will be regexps, except in the case of "**", which is
      // set to the GLOBSTAR object for globstar behavior,
      // and will not contain any / characters
      set = this.globParts = set.map(function (s) {
        return s.split(slashSplit)
      })

      this.debug(this.pattern, set)

      // glob --> regexps
      set = set.map(function (s, si, set) {
        return s.map(this.parse, this)
      }, this)

      this.debug(this.pattern, set)

      // filter out everything that didn't compile properly.
      set = set.filter(function (s) {
        return s.indexOf(false) === -1
      })

      this.debug(this.pattern, set)

      this.set = set
    }

    Minimatch.prototype.parseNegate = parseNegate
    function parseNegate() {
      var pattern = this.pattern
      var negate = false
      var options = this.options
      var negateOffset = 0

      if (options.nonegate) return

      for (var i = 0, l = pattern.length
        ; i < l && pattern.charAt(i) === '!'
        ; i++) {
        negate = !negate
        negateOffset++
      }

      if (negateOffset) this.pattern = pattern.substr(negateOffset)
      this.negate = negate
    }

    // Brace expansion:
    // a{b,c}d -> abd acd
    // a{b,}c -> abc ac
    // a{0..3}d -> a0d a1d a2d a3d
    // a{b,c{d,e}f}g -> abg acdfg acefg
    // a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
    //
    // Invalid sets are not expanded.
    // a{2..}b -> a{2..}b
    // a{b}c -> a{b}c
    minimatch.braceExpand = function (pattern, options) {
      return braceExpand(pattern, options)
    }

    Minimatch.prototype.braceExpand = braceExpand

    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options
        } else {
          options = {}
        }
      }

      pattern = typeof pattern === 'undefined'
        ? this.pattern : pattern

      if (typeof pattern === 'undefined') {
        throw new TypeError('undefined pattern')
      }

      if (options.nobrace ||
        !pattern.match(/\{.*\}/)) {
        // shortcut. no need to expand.
        return [pattern]
      }

      return expand(pattern)
    }

    // parse a component of the expanded set.
    // At this point, no pattern may contain "/" in it
    // so we're going to return a 2d array, where each entry is the full
    // pattern, split on '/', and then turned into a regular expression.
    // A regexp is made at the end which joins each array with an
    // escaped /, and another full one which joins each regexp with |.
    //
    // Following the lead of Bash 4.1, note that "**" only has special meaning
    // when it is the *only* thing in a path portion.  Otherwise, any series
    // of * is equivalent to a single *.  Globstar behavior is enabled by
    // default, and can be disabled by setting options.noglobstar.
    Minimatch.prototype.parse = parse
    var SUBPARSE = {}
    function parse(pattern, isSub) {
      if (pattern.length > 1024 * 64) {
        throw new TypeError('pattern is too long')
      }

      var options = this.options

      // shortcuts
      if (!options.noglobstar && pattern === '**') return GLOBSTAR
      if (pattern === '') return ''

      var re = ''
      var hasMagic = !!options.nocase
      var escaping = false
      // ? => one single character
      var patternListStack = []
      var negativeLists = []
      var stateChar
      var inClass = false
      var reClassStart = -1
      var classStart = -1
      // . and .. never match anything that doesn't start with .,
      // even when options.dot is set.
      var patternStart = pattern.charAt(0) === '.' ? '' // anything
        // not (start or / followed by . or .. followed by / or end)
        : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
          : '(?!\\.)'
      var self = this

      function clearStateChar() {
        if (stateChar) {
          // we had some state-tracking character
          // that wasn't consumed by this pass.
          switch (stateChar) {
            case '*':
              re += star
              hasMagic = true
              break
            case '?':
              re += qmark
              hasMagic = true
              break
            default:
              re += '\\' + stateChar
              break
          }
          self.debug('clearStateChar %j %j', stateChar, re)
          stateChar = false
        }
      }

      for (var i = 0, len = pattern.length, c
        ; (i < len) && (c = pattern.charAt(i))
        ; i++) {
        this.debug('%s\t%s %s %j', pattern, i, re, c)

        // skip over any that are escaped.
        if (escaping && reSpecials[c]) {
          re += '\\' + c
          escaping = false
          continue
        }

        switch (c) {
          case '/':
            // completely not allowed, even escaped.
            // Should already be path-split by now.
            return false

          case '\\':
            clearStateChar()
            escaping = true
            continue

          // the various stateChar values
          // for the "extglob" stuff.
          case '?':
          case '*':
          case '+':
          case '@':
          case '!':
            this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

            // all of those are literals inside a class, except that
            // the glob [!a] means [^a] in regexp
            if (inClass) {
              this.debug('  in class')
              if (c === '!' && i === classStart + 1) c = '^'
              re += c
              continue
            }

            // if we already have a stateChar, then it means
            // that there was something like ** or +? in there.
            // Handle the stateChar, then proceed with this one.
            self.debug('call clearStateChar %j', stateChar)
            clearStateChar()
            stateChar = c
            // if extglob is disabled, then +(asdf|foo) isn't a thing.
            // just clear the statechar *now*, rather than even diving into
            // the patternList stuff.
            if (options.noext) clearStateChar()
            continue

          case '(':
            if (inClass) {
              re += '('
              continue
            }

            if (!stateChar) {
              re += '\\('
              continue
            }

            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            })
            // negation is (?:(?!js)[^/]*)
            re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
            this.debug('plType %j %j', stateChar, re)
            stateChar = false
            continue

          case ')':
            if (inClass || !patternListStack.length) {
              re += '\\)'
              continue
            }

            clearStateChar()
            hasMagic = true
            var pl = patternListStack.pop()
            // negation is (?:(?!js)[^/]*)
            // The others are (?:<pattern>)<type>
            re += pl.close
            if (pl.type === '!') {
              negativeLists.push(pl)
            }
            pl.reEnd = re.length
            continue

          case '|':
            if (inClass || !patternListStack.length || escaping) {
              re += '\\|'
              escaping = false
              continue
            }

            clearStateChar()
            re += '|'
            continue

          // these are mostly the same in regexp and glob
          case '[':
            // swallow any state-tracking char before the [
            clearStateChar()

            if (inClass) {
              re += '\\' + c
              continue
            }

            inClass = true
            classStart = i
            reClassStart = re.length
            re += c
            continue

          case ']':
            //  a right bracket shall lose its special
            //  meaning and represent itself in
            //  a bracket expression if it occurs
            //  first in the list.  -- POSIX.2 2.8.3.2
            if (i === classStart + 1 || !inClass) {
              re += '\\' + c
              escaping = false
              continue
            }

            // handle the case where we left a class open.
            // "[z-a]" is valid, equivalent to "\[z-a\]"
            if (inClass) {
              // split where the last [ was, make sure we don't have
              // an invalid re. if so, re-walk the contents of the
              // would-be class to re-translate any characters that
              // were passed through as-is
              // TODO: It would probably be faster to determine this
              // without a try/catch and a new RegExp, but it's tricky
              // to do safely.  For now, this is safe and works.
              var cs = pattern.substring(classStart + 1, i)
              try {
                RegExp('[' + cs + ']')
              } catch (er) {
                // not a valid class!
                var sp = this.parse(cs, SUBPARSE)
                re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
                hasMagic = hasMagic || sp[1]
                inClass = false
                continue
              }
            }

            // finish up the class.
            hasMagic = true
            inClass = false
            re += c
            continue

          default:
            // swallow any state char that wasn't consumed
            clearStateChar()

            if (escaping) {
              // no need
              escaping = false
            } else if (reSpecials[c]
              && !(c === '^' && inClass)) {
              re += '\\'
            }

            re += c

        } // switch
      } // for

      // handle the case where we left a class open.
      // "[abc" is valid, equivalent to "\[abc"
      if (inClass) {
        // split where the last [ was, and escape it
        // this is a huge pita.  We now have to re-walk
        // the contents of the would-be class to re-translate
        // any characters that were passed through as-is
        cs = pattern.substr(classStart + 1)
        sp = this.parse(cs, SUBPARSE)
        re = re.substr(0, reClassStart) + '\\[' + sp[0]
        hasMagic = hasMagic || sp[1]
      }

      // handle the case where we had a +( thing at the *end*
      // of the pattern.
      // each pattern list stack adds 3 chars, and we need to go through
      // and escape any | chars that were passed through as-is for the regexp.
      // Go through and escape them, taking care not to double-escape any
      // | chars that were already escaped.
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length)
        this.debug('setting tail', re, pl)
        // maybe some even number of \, then maybe 1 \, followed by a |
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
          if (!$2) {
            // the | isn't already escaped, so escape it.
            $2 = '\\'
          }

          // need to escape all those slashes *again*, without escaping the
          // one that we need for escaping the | character.  As it works out,
          // escaping an even number of slashes can be done by simply repeating
          // it exactly after itself.  That's why this trick works.
          //
          // I am sorry that you have to see this.
          return $1 + $1 + $2 + '|'
        })

        this.debug('tail=%j\n   %s', tail, tail, pl, re)
        var t = pl.type === '*' ? star
          : pl.type === '?' ? qmark
            : '\\' + pl.type

        hasMagic = true
        re = re.slice(0, pl.reStart) + t + '\\(' + tail
      }

      // handle trailing things that only matter at the very end.
      clearStateChar()
      if (escaping) {
        // trailing \\
        re += '\\\\'
      }

      // only need to apply the nodot start if the re starts with
      // something that could conceivably capture a dot
      var addPatternStart = false
      switch (re.charAt(0)) {
        case '.':
        case '[':
        case '(': addPatternStart = true
      }

      // Hack to work around lack of negative lookbehind in JS
      // A pattern like: *.!(x).!(y|z) needs to ensure that a name
      // like 'a.xyz.yz' doesn't match.  So, the first negative
      // lookahead, has to look ALL the way ahead, to the end of
      // the pattern.
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n]

        var nlBefore = re.slice(0, nl.reStart)
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
        var nlAfter = re.slice(nl.reEnd)

        nlLast += nlAfter

        // Handle nested stuff like *(*.js|!(*.json)), where open parens
        // mean that we should *not* include the ) in the bit that is considered
        // "after" the negated section.
        var openParensBefore = nlBefore.split('(').length - 1
        var cleanAfter = nlAfter
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
        }
        nlAfter = cleanAfter

        var dollar = ''
        if (nlAfter === '' && isSub !== SUBPARSE) {
          dollar = '$'
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
        re = newRe
      }

      // if the re is not "" at this point, then we need to make sure
      // it doesn't match against an empty path part.
      // Otherwise a/* will match a/, which it should not.
      if (re !== '' && hasMagic) {
        re = '(?=.)' + re
      }

      if (addPatternStart) {
        re = patternStart + re
      }

      // parsing just a piece of a larger pattern.
      if (isSub === SUBPARSE) {
        return [re, hasMagic]
      }

      // skip the regexp for non-magical patterns
      // unescape anything in it, though, so that it'll be
      // an exact match against a file etc.
      if (!hasMagic) {
        return globUnescape(pattern)
      }

      var flags = options.nocase ? 'i' : ''
      try {
        var regExp = new RegExp('^' + re + '$', flags)
      } catch (er) {
        // If it was an invalid regular expression, then it can't match
        // anything.  This trick looks for a character after the end of
        // the string, which is of course impossible, except in multi-line
        // mode, but it's not a /m regex.
        return new RegExp('$.')
      }

      regExp._glob = pattern
      regExp._src = re

      return regExp
    }

    minimatch.makeRe = function (pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe()
    }

    Minimatch.prototype.makeRe = makeRe
    function makeRe() {
      if (this.regexp || this.regexp === false) return this.regexp

      // at this point, this.set is a 2d array of partial
      // pattern strings, or "**".
      //
      // It's better to use .match().  This function shouldn't
      // be used, really, but it's pretty convenient sometimes,
      // when you just want to work with a regex.
      var set = this.set

      if (!set.length) {
        this.regexp = false
        return this.regexp
      }
      var options = this.options

      var twoStar = options.noglobstar ? star
        : options.dot ? twoStarDot
          : twoStarNoDot
      var flags = options.nocase ? 'i' : ''

      var re = set.map(function (pattern) {
        return pattern.map(function (p) {
          return (p === GLOBSTAR) ? twoStar
            : (typeof p === 'string') ? regExpEscape(p)
              : p._src
        }).join('\\\/')
      }).join('|')

      // must match entire pattern
      // ending in a * or ** will make it less strict.
      re = '^(?:' + re + ')$'

      // can match anything, as long as it's not this.
      if (this.negate) re = '^(?!' + re + ').*$'

      try {
        this.regexp = new RegExp(re, flags)
      } catch (ex) {
        this.regexp = false
      }
      return this.regexp
    }

    minimatch.match = function (list, pattern, options) {
      options = options || {}
      var mm = new Minimatch(pattern, options)
      list = list.filter(function (f) {
        return mm.match(f)
      })
      if (mm.options.nonull && !list.length) {
        list.push(pattern)
      }
      return list
    }

    Minimatch.prototype.match = match
    function match(f, partial) {
      this.debug('match', f, this.pattern)
      // short-circuit in the case of busted things.
      // comments, etc.
      if (this.comment) return false
      if (this.empty) return f === ''

      if (f === '/' && partial) return true

      var options = this.options

      // windows: need to use /, not \
      if (path.sep !== '/') {
        f = f.split(path.sep).join('/')
      }

      // treat the test path as a set of pathparts.
      f = f.split(slashSplit)
      this.debug(this.pattern, 'split', f)

      // just ONE of the pattern sets in this.set needs to match
      // in order for it to be valid.  If negating, then just one
      // match means that we have failed.
      // Either way, return on the first hit.

      var set = this.set
      this.debug(this.pattern, 'set', set)

      // Find the basename of the path by looking for the last non-empty segment
      var filename
      var i
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i]
        if (filename) break
      }

      for (i = 0; i < set.length; i++) {
        var pattern = set[i]
        var file = f
        if (options.matchBase && pattern.length === 1) {
          file = [filename]
        }
        var hit = this.matchOne(file, pattern, partial)
        if (hit) {
          if (options.flipNegate) return true
          return !this.negate
        }
      }

      // didn't get any hits.  this is success if it's a negative
      // pattern, failure otherwise.
      if (options.flipNegate) return false
      return this.negate
    }

    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    Minimatch.prototype.matchOne = function (file, pattern, partial) {
      var options = this.options

      this.debug('matchOne',
        { 'this': this, file: file, pattern: pattern })

      this.debug('matchOne', file.length, pattern.length)

      for (var fi = 0,
        pi = 0,
        fl = file.length,
        pl = pattern.length
        ; (fi < fl) && (pi < pl)
        ; fi++, pi++) {
        this.debug('matchOne loop')
        var p = pattern[pi]
        var f = file[fi]

        this.debug(pattern, p, f)

        // should be impossible.
        // some invalid regexp stuff in the set.
        if (p === false) return false

        if (p === GLOBSTAR) {
          this.debug('GLOBSTAR', [pattern, p, f])

          // "**"
          // a/**/b/**/c would match the following:
          // a/b/x/y/z/c
          // a/x/y/z/b/c
          // a/b/x/b/x/c
          // a/b/c
          // To do this, take the rest of the pattern after
          // the **, and see if it would match the file remainder.
          // If so, return success.
          // If not, the ** "swallows" a segment, and try again.
          // This is recursively awful.
          //
          // a/**/b/**/c matching a/b/x/y/z/c
          // - a matches a
          // - doublestar
          //   - matchOne(b/x/y/z/c, b/**/c)
          //     - b matches b
          //     - doublestar
          //       - matchOne(x/y/z/c, c) -> no
          //       - matchOne(y/z/c, c) -> no
          //       - matchOne(z/c, c) -> no
          //       - matchOne(c, c) yes, hit
          var fr = fi
          var pr = pi + 1
          if (pr === pl) {
            this.debug('** at the end')
            // a ** at the end will just swallow the rest.
            // We have found a match.
            // however, it will not swallow /.x, unless
            // options.dot is set.
            // . and .. are *never* matched by **, for explosively
            // exponential reasons.
            for (; fi < fl; fi++) {
              if (file[fi] === '.' || file[fi] === '..' ||
                (!options.dot && file[fi].charAt(0) === '.')) return false
            }
            return true
          }

          // ok, let's see if we can swallow whatever we can.
          while (fr < fl) {
            var swallowee = file[fr]

            this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

            // XXX remove this slice.  Just pass the start index.
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug('globstar found match!', fr, fl, swallowee)
              // found a match.
              return true
            } else {
              // can't swallow "." or ".." ever.
              // can only swallow ".foo" when explicitly asked.
              if (swallowee === '.' || swallowee === '..' ||
                (!options.dot && swallowee.charAt(0) === '.')) {
                this.debug('dot detected!', file, fr, pattern, pr)
                break
              }

              // ** swallows a segment, and continue.
              this.debug('globstar swallow a segment, and continue')
              fr++
            }
          }

          // no match was found.
          // However, in partial mode, we can't say this is necessarily over.
          // If there's more *pattern* left, then
          if (partial) {
            // ran out of file
            this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
            if (fr === fl) return true
          }
          return false
        }

        // something other than **
        // non-magic patterns just have to match exactly
        // patterns with magic have been turned into regexps.
        var hit
        if (typeof p === 'string') {
          if (options.nocase) {
            hit = f.toLowerCase() === p.toLowerCase()
          } else {
            hit = f === p
          }
          this.debug('string match', p, f, hit)
        } else {
          hit = f.match(p)
          this.debug('pattern match', p, f, hit)
        }

        if (!hit) return false
      }

      // Note: ending in / means that we'll get a final ""
      // at the end of the pattern.  This can only match a
      // corresponding "" at the end of the file.
      // If the file ends in /, then it can only match a
      // a pattern that ends in /, unless the pattern just
      // doesn't have any more for it. But, a/b/ should *not*
      // match "a/b/*", even though "" matches against the
      // [^/]*? pattern, except in partial mode, where it might
      // simply not be reached yet.
      // However, a/b/ should still satisfy a/*

      // now either we fell off the end of the pattern, or we're done.
      if (fi === fl && pi === pl) {
        // ran out of pattern and filename at the same time.
        // an exact hit!
        return true
      } else if (fi === fl) {
        // ran out of file, but still had pattern left.
        // this is ok if we're doing the match as part of
        // a glob fs traversal.
        return partial
      } else if (pi === pl) {
        // ran out of pattern, still have file left.
        // this is only acceptable if we're on the very last
        // empty segment of a file with a trailing slash.
        // a/* should match a/b/
        var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
        return emptyFileEnd
      }

      // should be unreachable.
      throw new Error('wtf?')
    }

    // replace stuff like \* with *
    function globUnescape(s) {
      return s.replace(/\\(.)/g, '$1')
    }

    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
    }

  }, { "path": "UUq2", "brace-expansion": "dwXQ" }], "D1Ra": [function (require, module, exports) {
    var _require = require('es6-promisify'),
      promisify = _require.promisify;

    var Path = require('../path.js');

    var Errors = require('../errors.js');

    var Environment = require('./environment.js');

    var async = require('../../lib/async.js');

    var minimatch = require('minimatch');

    function Shell(fs, options) {
      var _this = this;

      options = options || {};
      var env = new Environment(options.env);
      var cwd = '/';
      /**
       * The bound FileSystem (cannot be changed)
       */

      Object.defineProperty(this, 'fs', {
        get: function get() {
          return fs;
        },
        enumerable: true
      });
      /**
       * The shell's environment (e.g., for things like
       * path, tmp, and other env vars). Use env.get()
       * and env.set() to work with variables.
       */

      Object.defineProperty(this, 'env', {
        get: function get() {
          return env;
        },
        enumerable: true
      });
      /**
       * Change the current working directory. We
       * include `cd` on the `this` vs. proto so that
       * we can access cwd without exposing it externally.
       */

      this.cd = function (path, callback) {
        path = Path.resolve(cwd, path); // Make sure the path actually exists, and is a dir

        fs.stat(path, function (err, stats) {
          if (err) {
            callback(new Errors.ENOTDIR(null, path));
            return;
          }

          if (stats.type === 'DIRECTORY') {
            cwd = path;
            callback();
          } else {
            callback(new Errors.ENOTDIR(null, path));
          }
        });
      };
      /**
       * Get the current working directory (changed with `cd()`)
       */


      this.pwd = function () {
        return cwd;
      };

      this.promises = {};
      /**
      * Public API for Shell converted to Promise based
      */

      ['cd', 'exec', 'touch', 'cat', 'ls', 'rm', 'tempDir', 'mkdirp', 'find'].forEach(function (methodName) {
        _this.promises[methodName] = promisify(_this[methodName].bind(_this));
      });
    }
    /**
     * Execute the .js command located at `path`. Such commands
     * should assume the existence of 3 arguments, which will be
     * defined at runtime:
     *
     *   * fs - the current shell's bound filesystem object
     *   * args - a list of arguments for the command, or an empty list if none
     *   * callback - a callback function(error, result) to call when done.
     *
     * The .js command's contents should be the body of a function
     * that looks like this:
     *
     * function(fs, args, callback) {
     *   // .js code here
     * }
     */


    Shell.prototype.exec = function (path, args, callback) {
      /* jshint evil:true */
      var sh = this;
      var fs = sh.fs;

      if (typeof args === 'function') {
        callback = args;
        args = [];
      }

      args = args || [];

      callback = callback || function () { };

      path = Path.resolve(sh.pwd(), path);
      fs.readFile(path, 'utf8', function (error, data) {
        if (error) {
          callback(error);
          return;
        }

        try {
          var cmd = new Function('fs', 'args', 'callback', data);
          cmd(fs, args, callback);
        } catch (e) {
          callback(e);
        }
      });
    };
    /**
     * Create a file if it does not exist, or update access and
     * modified times if it does. Valid options include:
     *
     *  * updateOnly - whether to create the file if missing (defaults to false)
     *  * date - use the provided Date value instead of current date/time
     */


    Shell.prototype.touch = function (path, options, callback) {
      var sh = this;
      var fs = sh.fs;

      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      options = options || {};

      callback = callback || function () { };

      path = Path.resolve(sh.pwd(), path);

      function createFile(path) {
        fs.writeFile(path, '', callback);
      }

      function updateTimes(path) {
        var now = Date.now();
        var atime = options.date || now;
        var mtime = options.date || now;
        fs.utimes(path, atime, mtime, callback);
      }

      fs.stat(path, function (error) {
        if (error) {
          if (options.updateOnly === true) {
            callback();
          } else {
            createFile(path);
          }
        } else {
          updateTimes(path);
        }
      });
    };
    /**
     * Concatenate multiple files into a single String, with each
     * file separated by a newline. The `files` argument should
     * be a String (path to single file) or an Array of Strings
     * (multiple file paths).
     */


    Shell.prototype.cat = function (files, callback) {
      var sh = this;
      var fs = sh.fs;
      var all = '';

      callback = callback || function () { };

      if (!files) {
        callback(new Errors.EINVAL('Missing files argument'));
        return;
      }

      files = typeof files === 'string' ? [files] : files;

      function append(item, callback) {
        var filename = Path.resolve(sh.pwd(), item);
        fs.readFile(filename, 'utf8', function (error, data) {
          if (error) {
            callback(error);
            return;
          }

          all += data + '\n';
          callback();
        });
      }

      async.eachSeries(files, append, function (error) {
        if (error) {
          callback(error);
        } else {
          callback(null, all.replace(/\n$/, ''));
        }
      });
    };
    /**
     * Get the listing of a directory, returning an array of
     * file entries in the following form:
     *
     * {
     *   path: <String> the basename of the directory entry
     *   links: <Number> the number of links to the entry
     *   size: <Number> the size in bytes of the entry
     *   modified: <Number> the last modified date/time
     *   type: <String> the type of the entry
     *   contents: <Array> an optional array of child entries
     * }
     *
     * By default ls() gives a shallow listing. If you want
     * to follow directories as they are encountered, use
     * the `recursive=true` option.
     */


    Shell.prototype.ls = function (dir, options, callback) {
      var sh = this;
      var fs = sh.fs;

      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      options = options || {};

      callback = callback || function () { };

      if (!dir) {
        callback(new Errors.EINVAL('Missing dir argument'));
        return;
      }

      function list(path, callback) {
        var pathname = Path.resolve(sh.pwd(), path);
        var result = [];
        fs.readdir(pathname, function (error, entries) {
          if (error) {
            callback(error);
            return;
          }

          function getDirEntry(name, callback) {
            name = Path.join(pathname, name);
            fs.stat(name, function (error, stats) {
              if (error) {
                callback(error);
                return;
              }

              var entry = stats;

              if (options.recursive && stats.type === 'DIRECTORY') {
                list(Path.join(pathname, entry.name), function (error, items) {
                  if (error) {
                    callback(error);
                    return;
                  }

                  entry.contents = items;
                  result.push(entry);
                  callback();
                });
              } else {
                result.push(entry);
                callback();
              }
            });
          }

          async.eachSeries(entries, getDirEntry, function (error) {
            callback(error, result);
          });
        });
      }

      list(dir, callback);
    };
    /**
     * Removes the file or directory at `path`. If `path` is a file
     * it will be removed. If `path` is a directory, it will be
     * removed if it is empty, otherwise the callback will receive
     * an error. In order to remove non-empty directories, use the
     * `recursive=true` option.
     */


    Shell.prototype.rm = function (path, options, callback) {
      var sh = this;
      var fs = sh.fs;

      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      options = options || {};

      callback = callback || function () { };

      if (!path) {
        callback(new Errors.EINVAL('Missing path argument'));
        return;
      }

      function remove(pathname, callback) {
        pathname = Path.resolve(sh.pwd(), pathname);
        fs.stat(pathname, function (error, stats) {
          if (error) {
            callback(error);
            return;
          } // If this is a file, delete it and we're done


          if (stats.type === 'FILE') {
            fs.unlink(pathname, callback);
            return;
          } // If it's a dir, check if it's empty


          fs.readdir(pathname, function (error, entries) {
            if (error) {
              callback(error);
              return;
            } // If dir is empty, delete it and we're done


            if (entries.length === 0) {
              fs.rmdir(pathname, callback);
              return;
            } // If not, see if we're allowed to delete recursively


            if (!options.recursive) {
              callback(new Errors.ENOTEMPTY(null, pathname));
              return;
            } // Remove each dir entry recursively, then delete the dir.


            entries = entries.map(function (filename) {
              // Root dir entries absolutely
              return Path.join(pathname, filename);
            });
            async.eachSeries(entries, remove, function (error) {
              if (error) {
                callback(error);
                return;
              }

              fs.rmdir(pathname, callback);
            });
          });
        });
      }

      remove(path, callback);
    };
    /**
     * Gets the path to the temporary directory, creating it if not
     * present. The directory used is the one specified in
     * env.TMP. The callback receives (error, tempDirName).
     */


    Shell.prototype.tempDir = function (callback) {
      var sh = this;
      var fs = sh.fs;
      var tmp = sh.env.get('TMP');

      callback = callback || function () { }; // Try and create it, and it will either work or fail
      // but either way it's now there.


      fs.mkdir(tmp, function () {
        callback(null, tmp);
      });
    };
    /**
     * Recursively creates the directory at `path`. If the parent
     * of `path` does not exist, it will be created.
     * Based off EnsureDir by Sam X. Xu
     * https://www.npmjs.org/package/ensureDir
     * MIT License
     */


    Shell.prototype.mkdirp = function (path, callback) {
      var sh = this;
      var fs = sh.fs;

      callback = callback || function () { };

      if (!path) {
        callback(new Errors.EINVAL('Missing path argument'));
        return;
      }

      path = Path.resolve(sh.pwd(), path);

      if (path === '/') {
        callback();
        return;
      }

      function _mkdirp(path, callback) {
        fs.stat(path, function (err, stat) {
          if (stat) {
            if (stat.isDirectory()) {
              callback();
              return;
            } else if (stat.isFile()) {
              callback(new Errors.ENOTDIR(null, path));
              return;
            }
          } else if (err && err.code !== 'ENOENT') {
            callback(err);
            return;
          } else {
            var parent = Path.dirname(path);

            if (parent === '/') {
              fs.mkdir(path, function (err) {
                if (err && err.code !== 'EEXIST') {
                  callback(err);
                  return;
                }

                callback();
                return;
              });
            } else {
              _mkdirp(parent, function (err) {
                if (err) return callback(err);
                fs.mkdir(path, function (err) {
                  if (err && err.code !== 'EEXIST') {
                    callback(err);
                    return;
                  }

                  callback();
                  return;
                });
              });
            }
          }
        });
      }

      _mkdirp(path, callback);
    };
    /**
     * Recursively walk a directory tree, reporting back all paths
     * that were found along the way. The `path` must be a dir.
     * Valid options include a `regex` for pattern matching paths
     * and an `exec` function of the form `function(path, next)` where
     * `path` is the current path that was found (dir paths have an '/'
     * appended) and `next` is a callback to call when done processing
     * the current path, passing any error object back as the first argument.
     * `find` returns a flat array of absolute paths for all matching/found
     * paths as the final argument to the callback.
     */


    Shell.prototype.find = function (path, options, callback) {
      var sh = this;
      var fs = sh.fs;

      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      options = options || {};

      callback = callback || function () { };

      var exec = options.exec || function (path, next) {
        next();
      };

      var found = [];

      if (!path) {
        callback(new Errors.EINVAL('Missing path argument'));
        return;
      }

      function processPath(path, callback) {
        exec(path, function (err) {
          if (err) {
            callback(err);
            return;
          }

          found.push(path);
          callback();
        });
      }

      function maybeProcessPath(path, callback) {
        // Test the path against the user's regex, name, path primaries (if any)
        // and remove any trailing slashes added previously.
        var rawPath = Path.removeTrailing(path); // Check entire path against provided regex, if any

        if (options.regex && !options.regex.test(rawPath)) {
          callback();
          return;
        } // Check basename for matches against name primary, if any


        if (options.name && !minimatch(Path.basename(rawPath), options.name)) {
          callback();
          return;
        } // Check dirname for matches against path primary, if any


        if (options.path && !minimatch(Path.dirname(rawPath), options.path)) {
          callback();
          return;
        }

        processPath(path, callback);
      }

      function walk(path, callback) {
        path = Path.resolve(sh.pwd(), path); // The path is either a file or dir, and instead of doing
        // a stat() to determine it first, we just try to readdir()
        // and it will either work or not, and we handle the non-dir error.

        fs.readdir(path, function (err, entries) {
          if (err) {
            if (err.code === 'ENOTDIR'
              /* file case, ignore error */
            ) {
              maybeProcessPath(path, callback);
            } else {
              callback(err);
            }

            return;
          } // Path is really a dir, add a trailing / and report it found


          maybeProcessPath(Path.addTrailing(path), function (err) {
            if (err) {
              callback(err);
              return;
            }

            entries = entries.map(function (entry) {
              return Path.join(path, entry);
            });
            async.eachSeries(entries, walk, function (err) {
              callback(err, found);
            });
          });
        });
      } // Make sure we are starting with a dir path


      fs.stat(path, function (err, stats) {
        if (err) {
          callback(err);
          return;
        }

        if (!stats.isDirectory()) {
          callback(new Errors.ENOTDIR(null, path));
          return;
        }

        walk(path, callback);
      });
    };

    module.exports = Shell;
  }, { "es6-promisify": "b1ZG", "../path.js": "UzoP", "../errors.js": "p8GN", "./environment.js": "QMiB", "../../lib/async.js": "u4Zs", "minimatch": "NtKi" }], "J4Qg": [function (require, module, exports) {
    // Based on https://github.com/diy/intercom.js/blob/master/lib/events.js
    // Copyright 2012 DIY Co Apache License, Version 2.0
    // http://www.apache.org/licenses/LICENSE-2.0
    function removeItem(item, array) {
      for (var i = array.length - 1; i >= 0; i--) {
        if (array[i] === item) {
          array.splice(i, 1);
        }
      }

      return array;
    }

    var EventEmitter = function EventEmitter() { };

    EventEmitter.createInterface = function (space) {
      var methods = {};

      methods.on = function (name, fn) {
        if (typeof this[space] === 'undefined') {
          this[space] = {};
        }

        if (!this[space].hasOwnProperty(name)) {
          this[space][name] = [];
        }

        this[space][name].push(fn);
      };

      methods.off = function (name, fn) {
        if (typeof this[space] === 'undefined') return;

        if (this[space].hasOwnProperty(name)) {
          removeItem(fn, this[space][name]);
        }
      };

      methods.trigger = function (name) {
        if (typeof this[space] !== 'undefined' && this[space].hasOwnProperty(name)) {
          var args = Array.prototype.slice.call(arguments, 1);

          for (var i = 0; i < this[space][name].length; i++) {
            this[space][name][i].apply(this[space][name][i], args);
          }
        }
      };

      methods.removeAllListeners = function (name) {
        if (typeof this[space] === 'undefined') return;
        var self = this;
        self[space][name].forEach(function (fn) {
          self.off(name, fn);
        });
      };

      return methods;
    };

    var pvt = EventEmitter.createInterface('_handlers');
    EventEmitter.prototype._on = pvt.on;
    EventEmitter.prototype._off = pvt.off;
    EventEmitter.prototype._trigger = pvt.trigger;
    var pub = EventEmitter.createInterface('handlers');

    EventEmitter.prototype.on = function () {
      pub.on.apply(this, arguments);
      Array.prototype.unshift.call(arguments, 'on');

      this._trigger.apply(this, arguments);
    };

    EventEmitter.prototype.off = pub.off;
    EventEmitter.prototype.trigger = pub.trigger;
    EventEmitter.prototype.removeAllListeners = pub.removeAllListeners;
    module.exports = EventEmitter;
  }, {}], "zBMa": [function (require, module, exports) {
    function generateRandom(template) {
      return template.replace(/[xy]/g, function (c) {
        var r = Math.random() * 16 | 0,
          v = c === 'x' ? r : r & 0x3 | 0x8;
        return v.toString(16);
      });
    }

    function guid() {
      return generateRandom('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx').toUpperCase();
    }
    /**
     * Generate a string of n random characters.  Defaults to n=6.
     */


    function randomChars(n) {
      n = n || 6;
      var template = 'x'.repeat(n);
      return generateRandom(template);
    }

    function nop() { }

    module.exports = {
      guid: guid,
      nop: nop,
      randomChars: randomChars
    };
  }, {}], "u7Jv": [function (require, module, exports) {
    var global = arguments[3];
    function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

    // Based on https://github.com/diy/intercom.js/blob/master/lib/intercom.js
    // Copyright 2012 DIY Co Apache License, Version 2.0
    // http://www.apache.org/licenses/LICENSE-2.0
    var EventEmitter = require('./eventemitter.js');

    var guid = require('../src/shared.js').guid;

    function throttle(delay, fn) {
      var last = 0;
      return function () {
        var now = Date.now();

        if (now - last > delay) {
          last = now;
          fn.apply(this, arguments);
        }
      };
    }

    function extend(a, b) {
      if (typeof a === 'undefined' || !a) {
        a = {};
      }

      if (_typeof(b) === 'object') {
        for (var key in b) {
          if (b.hasOwnProperty(key)) {
            a[key] = b[key];
          }
        }
      }

      return a;
    }

    var localStorage = function (window) {
      if (typeof window === 'undefined' || typeof window.localStorage === 'undefined') {
        return {
          getItem: function getItem() { },
          setItem: function setItem() { },
          removeItem: function removeItem() { }
        };
      }

      return window.localStorage;
    }(global);

    function Intercom() {
      var self = this;
      var now = Date.now();
      this.origin = guid();
      this.lastMessage = now;
      this.receivedIDs = {};
      this.previousValues = {};

      var storageHandler = function storageHandler() {
        self._onStorageEvent.apply(self, arguments);
      }; // If we're in node.js, skip event registration


      if (typeof document === 'undefined') {
        return;
      }

      if (document.attachEvent) {
        document.attachEvent('onstorage', storageHandler);
      } else {
        global.addEventListener('storage', storageHandler, false);
      }
    }

    Intercom.prototype._transaction = function (fn) {
      var TIMEOUT = 1000;
      var WAIT = 20;
      var self = this;
      var executed = false;
      var listening = false;
      var waitTimer = null;

      function lock() {
        if (executed) {
          return;
        }

        var now = Date.now();
        var activeLock = localStorage.getItem(INDEX_LOCK) | 0;

        if (activeLock && now - activeLock < TIMEOUT) {
          if (!listening) {
            self._on('storage', lock);

            listening = true;
          }

          waitTimer = setTimeout(lock, WAIT);
          return;
        }

        executed = true;
        localStorage.setItem(INDEX_LOCK, now);
        fn();
        unlock();
      }

      function unlock() {
        if (listening) {
          self._off('storage', lock);
        }

        if (waitTimer) {
          clearTimeout(waitTimer);
        }

        localStorage.removeItem(INDEX_LOCK);
      }

      lock();
    };

    Intercom.prototype._cleanup_emit = throttle(100, function () {
      var self = this;

      self._transaction(function () {
        var now = Date.now();
        var threshold = now - THRESHOLD_TTL_EMIT;
        var changed = 0;
        var messages;

        try {
          messages = JSON.parse(localStorage.getItem(INDEX_EMIT) || '[]');
        } catch (e) {
          messages = [];
        }

        for (var i = messages.length - 1; i >= 0; i--) {
          if (messages[i].timestamp < threshold) {
            messages.splice(i, 1);
            changed++;
          }
        }

        if (changed > 0) {
          localStorage.setItem(INDEX_EMIT, JSON.stringify(messages));
        }
      });
    });
    Intercom.prototype._cleanup_once = throttle(100, function () {
      var self = this;

      self._transaction(function () {
        var timestamp, ttl, key;
        var table;
        var now = Date.now();
        var changed = 0;

        try {
          table = JSON.parse(localStorage.getItem(INDEX_ONCE) || '{}');
        } catch (e) {
          table = {};
        }

        for (key in table) {
          if (self._once_expired(key, table)) {
            delete table[key];
            changed++;
          }
        }

        if (changed > 0) {
          localStorage.setItem(INDEX_ONCE, JSON.stringify(table));
        }
      });
    });

    Intercom.prototype._once_expired = function (key, table) {
      if (!table) {
        return true;
      }

      if (!table.hasOwnProperty(key)) {
        return true;
      }

      if (_typeof(table[key]) !== 'object') {
        return true;
      }

      var ttl = table[key].ttl || THRESHOLD_TTL_ONCE;
      var now = Date.now();
      var timestamp = table[key].timestamp;
      return timestamp < now - ttl;
    };

    Intercom.prototype._localStorageChanged = function (event, field) {
      if (event && event.key) {
        return event.key === field;
      }

      var currentValue = localStorage.getItem(field);

      if (currentValue === this.previousValues[field]) {
        return false;
      }

      this.previousValues[field] = currentValue;
      return true;
    };

    Intercom.prototype._onStorageEvent = function (event) {
      event = event || global.event;
      var self = this;

      if (this._localStorageChanged(event, INDEX_EMIT)) {
        this._transaction(function () {
          var now = Date.now();
          var data = localStorage.getItem(INDEX_EMIT);
          var messages;

          try {
            messages = JSON.parse(data || '[]');
          } catch (e) {
            messages = [];
          }

          for (var i = 0; i < messages.length; i++) {
            if (messages[i].origin === self.origin) continue;
            if (messages[i].timestamp < self.lastMessage) continue;

            if (messages[i].id) {
              if (self.receivedIDs.hasOwnProperty(messages[i].id)) continue;
              self.receivedIDs[messages[i].id] = true;
            }

            self.trigger(messages[i].name, messages[i].payload);
          }

          self.lastMessage = now;
        });
      }

      this._trigger('storage', event);
    };

    Intercom.prototype._emit = function (name, message, id) {
      id = typeof id === 'string' || typeof id === 'number' ? String(id) : null;

      if (id && id.length) {
        if (this.receivedIDs.hasOwnProperty(id)) return;
        this.receivedIDs[id] = true;
      }

      var packet = {
        id: id,
        name: name,
        origin: this.origin,
        timestamp: Date.now(),
        payload: message
      };
      var self = this;

      this._transaction(function () {
        var data = localStorage.getItem(INDEX_EMIT) || '[]';
        var delimiter = data === '[]' ? '' : ',';
        data = [data.substring(0, data.length - 1), delimiter, JSON.stringify(packet), ']'].join('');
        localStorage.setItem(INDEX_EMIT, data);
        self.trigger(name, message);
        setTimeout(function () {
          self._cleanup_emit();
        }, 50);
      });
    };

    Intercom.prototype.emit = function (name, message) {
      this._emit.apply(this, arguments);

      this._trigger('emit', name, message);
    };

    Intercom.prototype.once = function (key, fn, ttl) {
      if (!Intercom.supported) {
        return;
      }

      var self = this;

      this._transaction(function () {
        var data;

        try {
          data = JSON.parse(localStorage.getItem(INDEX_ONCE) || '{}');
        } catch (e) {
          data = {};
        }

        if (!self._once_expired(key, data)) {
          return;
        }

        data[key] = {};
        data[key].timestamp = Date.now();

        if (typeof ttl === 'number') {
          data[key].ttl = ttl * 1000;
        }

        localStorage.setItem(INDEX_ONCE, JSON.stringify(data));
        fn();
        setTimeout(function () {
          self._cleanup_once();
        }, 50);
      });
    };

    extend(Intercom.prototype, EventEmitter.prototype);
    Intercom.supported = typeof localStorage !== 'undefined';
    var INDEX_EMIT = 'intercom';
    var INDEX_ONCE = 'intercom_once';
    var INDEX_LOCK = 'intercom_lock';
    var THRESHOLD_TTL_EMIT = 50000;
    var THRESHOLD_TTL_ONCE = 1000 * 3600;

    Intercom.destroy = function () {
      localStorage.removeItem(INDEX_LOCK);
      localStorage.removeItem(INDEX_EMIT);
      localStorage.removeItem(INDEX_ONCE);
    };

    Intercom.getInstance = function () {
      var intercom;
      return function () {
        if (!intercom) {
          intercom = new Intercom();
        }

        return intercom;
      };
    }();

    module.exports = Intercom;
  }, { "./eventemitter.js": "J4Qg", "../src/shared.js": "zBMa" }], "VLEe": [function (require, module, exports) {
    'using strict';

    var EventEmitter = require('../lib/eventemitter.js');

    var Path = require('./path.js');

    var Intercom = require('../lib/intercom.js');
    /**
     * FSWatcher based on node.js' FSWatcher
     * see https://github.com/joyent/node/blob/master/lib/fs.js
     */


    function FSWatcher() {
      EventEmitter.call(this);
      var self = this;
      var recursive = false;
      var recursivePathPrefix;
      var filename;

      function onchange(path) {
        // Watch for exact filename, or parent path when recursive is true.
        if (filename === path || recursive && path.indexOf(recursivePathPrefix) === 0) {
          self.trigger('change', 'change', path);
        }
      } // We support, but ignore the second arg, which node.js uses.


      self.start = function (filename_, persistent_, recursive_) {
        // Bail if we've already started (and therefore have a filename);
        if (filename) {
          return;
        }

        if (Path.isNull(filename_)) {
          throw new Error('Path must be a string without null bytes.');
        } // TODO: get realpath for symlinks on filename...
        // Filer's Path.normalize strips trailing slashes, which we use here.
        // See https://github.com/js-platform/filer/issues/105


        filename = Path.normalize(filename_); // Whether to watch beneath this path or not

        recursive = recursive_ === true; // If recursive, construct a path prefix portion for comparisons later
        // (i.e., '/path' becomes '/path/' so we can search within a filename for the
        // prefix). We also take care to allow for '/' on its own.

        if (recursive) {
          recursivePathPrefix = filename === '/' ? '/' : filename + '/';
        }

        var intercom = Intercom.getInstance();
        intercom.on('change', onchange);
      };

      self.close = function () {
        var intercom = Intercom.getInstance();
        intercom.off('change', onchange);
        self.removeAllListeners('change');
      };
    }

    FSWatcher.prototype = new EventEmitter();
    FSWatcher.prototype.constructor = FSWatcher;
    module.exports = FSWatcher;
  }, { "../lib/eventemitter.js": "J4Qg", "./path.js": "UzoP", "../lib/intercom.js": "u7Jv" }], "ZECt": [function (require, module, exports) {
    var NODE_TYPE_FILE = require('./constants.js').NODE_TYPE_FILE;

    module.exports = function DirectoryEntry(id, type) {
      this.id = id;
      this.type = type || NODE_TYPE_FILE;
    };
  }, { "./constants.js": "iJA9" }], "osLK": [function (require, module, exports) {
    var _require = require('./constants'),
      FIRST_DESCRIPTOR = _require.FIRST_DESCRIPTOR;

    var openFiles = {};
    /**
     * Start at FIRST_DESCRIPTOR and go until we find
     * an empty file descriptor, then return it.
     */

    var getEmptyDescriptor = function getEmptyDescriptor() {
      var fd = FIRST_DESCRIPTOR;

      while (getOpenFileDescription(fd)) {
        fd++;
      }

      return fd;
    };
    /**
     * Look up the open file description object for a given
     * file descriptor.
     */


    var getOpenFileDescription = function getOpenFileDescription(ofd) {
      return openFiles[ofd];
    };
    /**
     * Allocate a new file descriptor for the given
     * open file description. 
     */


    var allocDescriptor = function allocDescriptor(openFileDescription) {
      var ofd = getEmptyDescriptor();
      openFiles[ofd] = openFileDescription;
      return ofd;
    };
    /**
     * Release the given existing file descriptor created
     * with allocDescriptor(). 
     */


    var releaseDescriptor = function releaseDescriptor(ofd) {
      return delete openFiles[ofd];
    };

    module.exports = {
      allocDescriptor: allocDescriptor,
      releaseDescriptor: releaseDescriptor,
      getOpenFileDescription: getOpenFileDescription
    };
  }, { "./constants": "iJA9" }], "KKNo": [function (require, module, exports) {
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    var _require = require('./constants'),
      NODE_TYPE_FILE = _require.NODE_TYPE_FILE,
      NODE_TYPE_DIRECTORY = _require.NODE_TYPE_DIRECTORY,
      NODE_TYPE_SYMBOLIC_LINK = _require.NODE_TYPE_SYMBOLIC_LINK,
      DEFAULT_FILE_PERMISSIONS = _require.DEFAULT_FILE_PERMISSIONS,
      DEFAULT_DIR_PERMISSIONS = _require.DEFAULT_DIR_PERMISSIONS;

    var _require$fsConstants = require('./constants').fsConstants,
      S_IFREG = _require$fsConstants.S_IFREG,
      S_IFDIR = _require$fsConstants.S_IFDIR,
      S_IFLNK = _require$fsConstants.S_IFLNK;
    /**
     * Make sure the options object has an id on property,
     * either from caller or one we generate using supplied guid fn.
     */


    function ensureID(options, prop, callback) {
      if (options[prop]) {
        return callback();
      }

      options.guid(function (err, id) {
        if (err) {
          return callback(err);
        }

        options[prop] = id;
        callback();
      });
    }
    /**
     * Generate a POSIX mode (integer) for the node type and permissions.
     * Use default permissions if we aren't passed any.
     */


    function generateMode(nodeType, modePermissions) {
      switch (nodeType) {
        case NODE_TYPE_DIRECTORY:
          return (modePermissions || DEFAULT_DIR_PERMISSIONS) | S_IFDIR;

        case NODE_TYPE_SYMBOLIC_LINK:
          return (modePermissions || DEFAULT_FILE_PERMISSIONS) | S_IFLNK;

        case NODE_TYPE_FILE: // falls through

        default:
          return (modePermissions || DEFAULT_FILE_PERMISSIONS) | S_IFREG;
      }
    }
    /**
     * Common properties for the layout of a Node
     */


    var Node = /*#__PURE__*/function () {
      function Node(options) {
        _classCallCheck(this, Node);

        var now = Date.now();
        this.id = options.id;
        this.data = options.data; // id for data object

        this.size = options.size || 0; // size (bytes for files, entries for directories)

        this.atime = options.atime || now; // access time (will mirror ctime after creation)

        this.ctime = options.ctime || now; // creation/change time

        this.mtime = options.mtime || now; // modified time

        this.flags = options.flags || []; // file flags

        this.xattrs = options.xattrs || {}; // extended attributes

        this.nlinks = options.nlinks || 0; // links count
        // Historically, Filer's node layout has referred to the
        // node type as `mode`, and done so using a String.  In
        // a POSIX filesystem, the mode is a number that combines
        // both node type and permission bits. Internal we use `type`,
        // but store it in the database as `mode` for backward
        // compatibility.

        if (typeof options.type === 'string') {
          this.type = options.type;
        } else if (typeof options.mode === 'string') {
          this.type = options.mode;
        } else {
          this.type = NODE_TYPE_FILE;
        } // Extra mode permissions and ownership info


        this.permissions = options.permissions || generateMode(this.type);
        this.uid = options.uid || 0x0; // owner name

        this.gid = options.gid || 0x0; // group name
      }
      /**
       * Serialize a Node to JSON.  Everything is as expected except
       * that we use `mode` for `type` to maintain backward compatibility.
       */


      _createClass(Node, [{
        key: "toJSON",
        value: function toJSON() {
          return {
            id: this.id,
            data: this.data,
            size: this.size,
            atime: this.atime,
            ctime: this.ctime,
            mtime: this.ctime,
            flags: this.flags,
            xattrs: this.xattrs,
            nlinks: this.nlinks,
            // Use `mode` for `type` to keep backward compatibility
            mode: this.type,
            permissions: this.permissions,
            uid: this.uid,
            gid: this.gid
          };
        } // Return complete POSIX `mode` for node type + permissions. See:
        // http://man7.org/linux/man-pages/man2/chmod.2.html

      }, {
        key: "mode",
        get: function get() {
          return generateMode(this.type, this.permissions);
        } // When setting the `mode` we assume permissions bits only (not changing type)
        ,
        set: function set(value) {
          this.permissions = value;
        }
      }]);

      return Node;
    }();

    module.exports.create = function create(options, callback) {
      // We expect both options.id and options.data to be provided/generated.
      ensureID(options, 'id', function (err) {
        if (err) {
          return callback(err);
        }

        ensureID(options, 'data', function (err) {
          if (err) {
            return callback(err);
          }

          callback(null, new Node(options));
        });
      });
    };
  }, { "./constants": "iJA9" }], "XWaV": [function (require, module, exports) {
    var Errors = require('./errors.js');

    var Node = require('./node');

    function OpenFileDescription(path, id, flags, position) {
      this.path = path;
      this.id = id;
      this.flags = flags;
      this.position = position;
    } // Tries to find the node associated with an ofd's `id`.
    // If not found, an error is returned on the callback.


    OpenFileDescription.prototype.getNode = function (context, callback) {
      var id = this.id;
      var path = this.path;

      function check_if_node_exists(error, node) {
        if (error) {
          return callback(error);
        }

        if (!node) {
          return callback(new Errors.EBADF('file descriptor refers to unknown node', path));
        }

        Node.create(node, callback);
      }

      context.getObject(id, check_if_node_exists);
    };

    module.exports = OpenFileDescription;
  }, { "./errors.js": "p8GN", "./node": "KKNo" }], "JEp0": [function (require, module, exports) {
    var Constants = require('./constants.js');

    function SuperNode(options) {
      var now = Date.now();
      this.id = Constants.SUPER_NODE_ID;
      this.type = Constants.NODE_TYPE_META;
      this.atime = options.atime || now;
      this.ctime = options.ctime || now;
      this.mtime = options.mtime || now; // root node id (randomly generated)

      this.rnode = options.rnode;
    }

    SuperNode.create = function (options, callback) {
      options.guid(function (err, rnode) {
        if (err) {
          callback(err);
          return;
        }

        options.rnode = options.rnode || rnode;
        callback(null, new SuperNode(options));
      });
    };

    module.exports = SuperNode;
  }, { "./constants.js": "iJA9" }], "dsCT": [function (require, module, exports) {
    'use strict';

    var Constants = require('./constants.js');

    var Path = require('./path.js');

    function dateFromMs(ms) {
      return new Date(Number(ms));
    }

    function Stats(path, fileNode, devName) {
      this.dev = devName;
      this.node = fileNode.id;
      this.type = fileNode.type;
      this.size = fileNode.size;
      this.nlinks = fileNode.nlinks; // Date objects

      this.atime = dateFromMs(fileNode.atime);
      this.mtime = dateFromMs(fileNode.mtime);
      this.ctime = dateFromMs(fileNode.ctime); // Unix timestamp MS Numbers

      this.atimeMs = fileNode.atime;
      this.mtimeMs = fileNode.mtime;
      this.ctimeMs = fileNode.ctime;
      this.version = fileNode.version;
      this.mode = fileNode.mode;
      this.uid = fileNode.uid;
      this.gid = fileNode.gid;
      this.name = Path.basename(path);
    }

    Stats.prototype.isFile = function () {
      return this.type === Constants.NODE_TYPE_FILE;
    };

    Stats.prototype.isDirectory = function () {
      return this.type === Constants.NODE_TYPE_DIRECTORY;
    };

    Stats.prototype.isSymbolicLink = function () {
      return this.type === Constants.NODE_TYPE_SYMBOLIC_LINK;
    }; // These will always be false in Filer.


    Stats.prototype.isSocket = Stats.prototype.isFIFO = Stats.prototype.isCharacterDevice = Stats.prototype.isBlockDevice = function () {
      return false;
    };

    module.exports = Stats;
  }, { "./constants.js": "iJA9", "./path.js": "UzoP" }], "q4Wu": [function (require, module, exports) {
    'use strict';

    var Stats = require('./stats.js');

    function Dirent(path, fileNode, devName) {
      this.constructor = Dirent;
      Stats.call(this, path, fileNode, devName);
    }

    Dirent.prototype = Stats.prototype;
    module.exports = Dirent;
  }, { "./stats.js": "dsCT" }], "bsBG": [function (require, module, exports) {
    var Buffer = require("buffer").Buffer;
    function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

    var Path = require('../path.js');

    var normalize = Path.normalize;
    var dirname = Path.dirname;
    var basename = Path.basename;
    var isAbsolutePath = Path.isAbsolute;

    var shared = require('../shared.js');

    var async = require('../../lib/async.js');

    var Constants = require('../constants.js');

    var NODE_TYPE_FILE = Constants.NODE_TYPE_FILE;
    var NODE_TYPE_DIRECTORY = Constants.NODE_TYPE_DIRECTORY;
    var NODE_TYPE_SYMBOLIC_LINK = Constants.NODE_TYPE_SYMBOLIC_LINK;
    var NODE_TYPE_META = Constants.NODE_TYPE_META;
    var FULL_READ_WRITE_EXEC_PERMISSIONS = Constants.FULL_READ_WRITE_EXEC_PERMISSIONS;
    var ROOT_DIRECTORY_NAME = Constants.ROOT_DIRECTORY_NAME;
    var SUPER_NODE_ID = Constants.SUPER_NODE_ID;
    var SYMLOOP_MAX = Constants.SYMLOOP_MAX;
    var O_READ = Constants.O_READ;
    var O_WRITE = Constants.O_WRITE;
    var O_CREATE = Constants.O_CREATE;
    var O_EXCLUSIVE = Constants.O_EXCLUSIVE;
    var O_APPEND = Constants.O_APPEND;
    var O_FLAGS = Constants.O_FLAGS;
    var XATTR_CREATE = Constants.XATTR_CREATE;
    var XATTR_REPLACE = Constants.XATTR_REPLACE;
    var FS_NOMTIME = Constants.FS_NOMTIME;
    var FS_NOCTIME = Constants.FS_NOCTIME;

    var Errors = require('../errors.js');

    var DirectoryEntry = require('../directory-entry.js');

    var openFiles = require('../open-files.js');

    var OpenFileDescription = require('../open-file-description.js');

    var SuperNode = require('../super-node.js');

    var Node = require('../node.js');

    var Dirent = require('../dirent.js');

    var Stats = require('../stats.js');
    /**
     * Update node times. Only passed times are modified (undefined times are ignored)
     * and filesystem flags are examined in order to override update logic.
     */


    function update_node_times(context, path, node, times, callback) {
      // Honour mount flags for how we update times
      var flags = context.flags;

      if (flags.includes(FS_NOCTIME)) {
        delete times.ctime;
      }

      if (flags.includes(FS_NOMTIME)) {
        delete times.mtime;
      } // Only do the update if required (i.e., times are still present)


      var update = false;

      if (times.ctime) {
        node.ctime = times.ctime; // We don't do atime tracking for perf reasons, but do mirror ctime

        node.atime = times.ctime;
        update = true;
      }

      if (times.atime) {
        // The only time we explicitly pass atime is when utimes(), futimes() is called.
        // Override ctime mirror here if so
        node.atime = times.atime;
        update = true;
      }

      if (times.mtime) {
        node.mtime = times.mtime;
        update = true;
      }

      function complete(error) {
        // Queue this change so we can send watch events.
        // Unlike node.js, we send the full path vs. basename/dirname only.
        context.changes.push({
          event: 'change',
          path: path
        });
        callback(error);
      }

      if (update) {
        context.putObject(node.id, node, complete);
      } else {
        complete();
      }
    }
    /**
     * make_node()
     */
    // in: file or directory path
    // out: new node representing file/directory


    function make_node(context, path, type, callback) {
      if (type !== NODE_TYPE_DIRECTORY && type !== NODE_TYPE_FILE) {
        return callback(new Errors.EINVAL('type must be a directory or file', path));
      }

      path = normalize(path);
      var name = basename(path);
      var parentPath = dirname(path);
      var parentNode;
      var parentNodeData;
      var node; // Check if the parent node exists

      function create_node_in_parent(error, parentDirectoryNode) {
        if (error) {
          callback(error);
        } else if (parentDirectoryNode.type !== NODE_TYPE_DIRECTORY) {
          callback(new Errors.ENOTDIR('a component of the path prefix is not a directory', path));
        } else {
          parentNode = parentDirectoryNode;
          find_node(context, path, check_if_node_exists);
        }
      } // Check if the node to be created already exists


      function check_if_node_exists(error, result) {
        if (!error && result) {
          callback(new Errors.EEXIST('path name already exists', path));
        } else if (error && !(error instanceof Errors.ENOENT)) {
          callback(error);
        } else {
          context.getObject(parentNode.data, create_node);
        }
      } // Create the new node


      function create_node(error, result) {
        if (error) {
          callback(error);
        } else {
          parentNodeData = result;
          Node.create({
            guid: context.guid,
            type: type
          }, function (error, result) {
            if (error) {
              callback(error);
              return;
            }

            node = result;
            node.nlinks += 1;
            context.putObject(node.id, node, update_parent_node_data);
          });
        }
      } // Update parent node time


      function update_time(error) {
        if (error) {
          callback(error);
        } else {
          var now = Date.now();
          update_node_times(context, parentPath, node, {
            mtime: now,
            ctime: now
          }, callback);
        }
      } // Update the parent nodes data


      function update_parent_node_data(error) {
        if (error) {
          callback(error);
        } else {
          parentNodeData[name] = new DirectoryEntry(node.id, type);
          context.putObject(parentNode.data, parentNodeData, update_time);
        }
      } // Find the parent node


      find_node(context, parentPath, create_node_in_parent);
    }
    /**
     * find_node
     */
    // in: file or directory path
    // out: node structure, or error


    function find_node(context, path, callback) {
      path = normalize(path);

      if (!path) {
        return callback(new Errors.ENOENT('path is an empty string'));
      }

      var name = basename(path);
      var parentPath = dirname(path);
      var followedCount = 0;

      function read_root_directory_node(error, nodeData) {
        if (error) {
          return callback(error);
        } // Parse existing node as SuperNode


        var superNode = new SuperNode(nodeData);

        if (!superNode || superNode.type !== NODE_TYPE_META || !superNode.rnode) {
          callback(new Errors.EFILESYSTEMERROR());
        } else {
          context.getObject(superNode.rnode, check_root_directory_node);
        }
      }

      function check_root_directory_node(error, rootDirectoryNode) {
        if (error) {
          callback(error);
        } else if (!rootDirectoryNode) {
          callback(new Errors.ENOENT());
        } else {
          Node.create(rootDirectoryNode, callback);
        }
      } // in: parent directory node
      // out: parent directory data


      function read_parent_directory_data(error, parentDirectoryNode) {
        if (error) {
          callback(error);
        } else if (parentDirectoryNode.type !== NODE_TYPE_DIRECTORY || !parentDirectoryNode.data) {
          callback(new Errors.ENOTDIR('a component of the path prefix is not a directory', path));
        } else {
          context.getObject(parentDirectoryNode.data, get_node_from_parent_directory_data);
        }
      } // in: parent directory data
      // out: searched node


      function get_node_from_parent_directory_data(error, parentDirectoryData) {
        if (error) {
          callback(error);
        } else {
          if (!Object.prototype.hasOwnProperty.call(parentDirectoryData, name)) {
            callback(new Errors.ENOENT(null, path));
          } else {
            var nodeId = parentDirectoryData[name].id;
            context.getObject(nodeId, create_node);
          }
        }
      }

      function create_node(error, data) {
        if (error) {
          return callback(error);
        }

        Node.create(data, is_symbolic_link);
      }

      function is_symbolic_link(error, node) {
        if (error) {
          callback(error);
        } else {
          if (node.type === NODE_TYPE_SYMBOLIC_LINK) {
            followedCount++;

            if (followedCount > SYMLOOP_MAX) {
              callback(new Errors.ELOOP(null, path));
            } else {
              follow_symbolic_link(node.data);
            }
          } else {
            callback(null, node);
          }
        }
      }

      function follow_symbolic_link(data) {
        data = normalize(data);
        parentPath = dirname(data);
        name = basename(data);

        if (ROOT_DIRECTORY_NAME === name) {
          context.getObject(SUPER_NODE_ID, read_root_directory_node);
        } else {
          find_node(context, parentPath, read_parent_directory_data);
        }
      }

      if (ROOT_DIRECTORY_NAME === name) {
        context.getObject(SUPER_NODE_ID, read_root_directory_node);
      } else {
        find_node(context, parentPath, read_parent_directory_data);
      }
    }
    /**
     * set extended attribute (refactor)
     */


    function set_extended_attribute(context, path, node, name, value, flag, callback) {
      function update_time(error) {
        if (error) {
          callback(error);
        } else {
          update_node_times(context, path, node, {
            ctime: Date.now()
          }, callback);
        }
      }

      var xattrs = node.xattrs;

      if (flag === XATTR_CREATE && Object.prototype.hasOwnProperty.call(xattrs, name)) {
        callback(new Errors.EEXIST('attribute already exists', path));
      } else if (flag === XATTR_REPLACE && !Object.prototype.hasOwnProperty.call(xattrs, name)) {
        callback(new Errors.ENOATTR(null, path));
      } else {
        xattrs[name] = value;
        context.putObject(node.id, node, update_time);
      }
    }
    /**
     * ensure_root_directory. Creates a root node if necessary.
     *
     * Note: this should only be invoked when formatting a new file system.
     * Multiple invocations of this by separate instances will still result
     * in only a single super node.
     */


    function ensure_root_directory(context, callback) {
      var superNode;
      var directoryNode;
      var directoryData;

      function ensure_super_node(error, existingNode) {
        if (!error && existingNode) {
          // Another instance has beat us and already created the super node.
          callback();
        } else if (error && !(error instanceof Errors.ENOENT)) {
          callback(error);
        } else {
          SuperNode.create({
            guid: context.guid
          }, function (error, result) {
            if (error) {
              callback(error);
              return;
            }

            superNode = result;
            context.putObject(superNode.id, superNode, write_directory_node);
          });
        }
      }

      function write_directory_node(error) {
        if (error) {
          callback(error);
        } else {
          Node.create({
            guid: context.guid,
            id: superNode.rnode,
            type: NODE_TYPE_DIRECTORY
          }, function (error, result) {
            if (error) {
              callback(error);
              return;
            }

            directoryNode = result;
            directoryNode.nlinks += 1;
            context.putObject(directoryNode.id, directoryNode, write_directory_data);
          });
        }
      }

      function write_directory_data(error) {
        if (error) {
          callback(error);
        } else {
          directoryData = {};
          context.putObject(directoryNode.data, directoryData, callback);
        }
      }

      context.getObject(SUPER_NODE_ID, ensure_super_node);
    }
    /**
     * make_directory
     */


    function make_directory(context, path, callback) {
      path = normalize(path);
      var name = basename(path);
      var parentPath = dirname(path);
      var directoryNode;
      var directoryData;
      var parentDirectoryNode;
      var parentDirectoryData;

      function check_if_directory_exists(error, result) {
        if (!error && result) {
          callback(new Errors.EEXIST(null, path));
        } else if (error && !(error instanceof Errors.ENOENT)) {
          callback(error);
        } else {
          find_node(context, parentPath, read_parent_directory_data);
        }
      }

      function read_parent_directory_data(error, result) {
        if (error) {
          callback(error);
        } else {
          parentDirectoryNode = result;
          context.getObject(parentDirectoryNode.data, write_directory_node);
        }
      }

      function write_directory_node(error, result) {
        if (error) {
          callback(error);
        } else {
          parentDirectoryData = result;
          Node.create({
            guid: context.guid,
            type: NODE_TYPE_DIRECTORY
          }, function (error, result) {
            if (error) {
              callback(error);
              return;
            }

            directoryNode = result;
            directoryNode.nlinks += 1;
            context.putObject(directoryNode.id, directoryNode, write_directory_data);
          });
        }
      }

      function write_directory_data(error) {
        if (error) {
          callback(error);
        } else {
          directoryData = {};
          context.putObject(directoryNode.data, directoryData, update_parent_directory_data);
        }
      }

      function update_time(error) {
        if (error) {
          callback(error);
        } else {
          var now = Date.now();
          update_node_times(context, parentPath, parentDirectoryNode, {
            mtime: now,
            ctime: now
          }, callback);
        }
      }

      function update_parent_directory_data(error) {
        if (error) {
          callback(error);
        } else {
          parentDirectoryData[name] = new DirectoryEntry(directoryNode.id, NODE_TYPE_DIRECTORY);
          context.putObject(parentDirectoryNode.data, parentDirectoryData, update_time);
        }
      }

      find_node(context, path, check_if_directory_exists);
    }

    function access_file(context, path, mode, callback) {
      var _Constants$fsConstant = Constants.fsConstants,
        F_OK = _Constants$fsConstant.F_OK,
        R_OK = _Constants$fsConstant.R_OK,
        W_OK = _Constants$fsConstant.W_OK,
        X_OK = _Constants$fsConstant.X_OK,
        S_IXUSR = _Constants$fsConstant.S_IXUSR,
        S_IXGRP = _Constants$fsConstant.S_IXGRP,
        S_IXOTH = _Constants$fsConstant.S_IXOTH;
      path = normalize(path);
      find_node(context, path, function (err, node) {
        if (err) {
          return callback(err);
        } // If we have a node, F_OK is true.


        if (mode === F_OK) {
          return callback(null);
        }

        var st_mode = validateAndMaskMode(node.mode, callback);
        if (!st_mode) return; // For any other combo of F_OK, R_OK, W_OK, always allow. Filer user is a root user,
        // so existing files are always OK, readable, and writable

        if (mode & (R_OK | W_OK)) {
          return callback(null);
        } // For the case of X_OK, actually check if this file is executable


        if (mode & X_OK && st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)) {
          return callback(null);
        } // In any other case, the file isn't accessible


        callback(new Errors.EACCES('permission denied', path));
      });
    }
    /**
     * remove_directory
     */


    function remove_directory(context, path, callback) {
      path = normalize(path);
      var name = basename(path);
      var parentPath = dirname(path);
      var directoryNode;
      var directoryData;
      var parentDirectoryNode;
      var parentDirectoryData;

      function read_parent_directory_data(error, result) {
        if (error) {
          callback(error);
        } else {
          parentDirectoryNode = result;
          context.getObject(parentDirectoryNode.data, check_if_node_exists);
        }
      }

      function check_if_node_exists(error, result) {
        if (error) {
          callback(error);
        } else if (ROOT_DIRECTORY_NAME === name) {
          callback(new Errors.EBUSY(null, path));
        } else if (!Object.prototype.hasOwnProperty.call(result, name)) {
          callback(new Errors.ENOENT(null, path));
        } else {
          parentDirectoryData = result;
          directoryNode = parentDirectoryData[name].id;
          context.getObject(directoryNode, check_if_node_is_directory);
        }
      }

      function check_if_node_is_directory(error, result) {
        if (error) {
          callback(error);
        } else if (result.type !== NODE_TYPE_DIRECTORY) {
          callback(new Errors.ENOTDIR(null, path));
        } else {
          directoryNode = result;
          context.getObject(directoryNode.data, check_if_directory_is_empty);
        }
      }

      function check_if_directory_is_empty(error, result) {
        if (error) {
          callback(error);
        } else {
          directoryData = result;

          if (Object.keys(directoryData).length > 0) {
            callback(new Errors.ENOTEMPTY(null, path));
          } else {
            remove_directory_entry_from_parent_directory_node();
          }
        }
      }

      function update_time(error) {
        if (error) {
          callback(error);
        } else {
          var now = Date.now();
          update_node_times(context, parentPath, parentDirectoryNode, {
            mtime: now,
            ctime: now
          }, remove_directory_node);
        }
      }

      function remove_directory_entry_from_parent_directory_node() {
        delete parentDirectoryData[name];
        context.putObject(parentDirectoryNode.data, parentDirectoryData, update_time);
      }

      function remove_directory_node(error) {
        if (error) {
          callback(error);
        } else {
          context.delete(directoryNode.id, remove_directory_data);
        }
      }

      function remove_directory_data(error) {
        if (error) {
          callback(error);
        } else {
          context.delete(directoryNode.data, callback);
        }
      }

      find_node(context, parentPath, read_parent_directory_data);
    }

    function open_file(context, path, flags, mode, callback) {
      if (typeof mode === 'function') {
        callback = mode;
        mode = null;
      }

      path = normalize(path);
      var name = basename(path);
      var parentPath = dirname(path);
      var directoryNode;
      var directoryData;
      var directoryEntry;
      var fileNode;
      var fileData;
      var followedCount = 0;

      if (ROOT_DIRECTORY_NAME === name) {
        if (flags.includes(O_WRITE)) {
          callback(new Errors.EISDIR('the named file is a directory and O_WRITE is set', path));
        } else {
          find_node(context, path, set_file_node);
        }
      } else {
        find_node(context, parentPath, read_directory_data);
      }

      function read_directory_data(error, result) {
        if (error) {
          callback(error);
        } else if (result.type !== NODE_TYPE_DIRECTORY) {
          callback(new Errors.ENOENT(null, path));
        } else {
          directoryNode = result;
          context.getObject(directoryNode.data, check_if_file_exists);
        }
      }

      function check_if_file_exists(error, result) {
        if (error) {
          callback(error);
        } else {
          directoryData = result;

          if (Object.prototype.hasOwnProperty.call(directoryData, name)) {
            if (flags.includes(O_EXCLUSIVE)) {
              callback(new Errors.EEXIST('O_CREATE and O_EXCLUSIVE are set, and the named file exists', path));
            } else {
              directoryEntry = directoryData[name];

              if (directoryEntry.type === NODE_TYPE_DIRECTORY && flags.includes(O_WRITE)) {
                callback(new Errors.EISDIR('the named file is a directory and O_WRITE is set', path));
              } else {
                context.getObject(directoryEntry.id, check_if_symbolic_link);
              }
            }
          } else {
            if (!flags.includes(O_CREATE)) {
              callback(new Errors.ENOENT('O_CREATE is not set and the named file does not exist', path));
            } else {
              write_file_node();
            }
          }
        }
      }

      function check_if_symbolic_link(error, result) {
        if (error) {
          callback(error);
        } else {
          var node = result;

          if (node.type === NODE_TYPE_SYMBOLIC_LINK) {
            followedCount++;

            if (followedCount > SYMLOOP_MAX) {
              callback(new Errors.ELOOP(null, path));
            } else {
              follow_symbolic_link(node.data);
            }
          } else {
            set_file_node(undefined, node);
          }
        }
      }

      function follow_symbolic_link(data) {
        data = normalize(data);
        parentPath = dirname(data);
        name = basename(data);

        if (ROOT_DIRECTORY_NAME === name) {
          if (flags.includes(O_WRITE)) {
            callback(new Errors.EISDIR('the named file is a directory and O_WRITE is set', path));
          } else {
            find_node(context, path, set_file_node);
          }
        }

        find_node(context, parentPath, read_directory_data);
      }

      function set_file_node(error, result) {
        if (error) {
          callback(error);
        } else {
          fileNode = result;
          callback(null, fileNode);
        }
      }

      function write_file_node() {
        Node.create({
          guid: context.guid,
          type: NODE_TYPE_FILE
        }, function (error, result) {
          if (error) {
            callback(error);
            return;
          }

          fileNode = result;
          fileNode.nlinks += 1;

          if (mode) {
            fileNode.mode = mode;
          }

          context.putObject(fileNode.id, fileNode, write_file_data);
        });
      }

      function write_file_data(error) {
        if (error) {
          callback(error);
        } else {
          fileData = Buffer.alloc(0);
          context.putBuffer(fileNode.data, fileData, update_directory_data);
        }
      }

      function update_time(error) {
        if (error) {
          callback(error);
        } else {
          var now = Date.now();
          update_node_times(context, parentPath, directoryNode, {
            mtime: now,
            ctime: now
          }, handle_update_result);
        }
      }

      function update_directory_data(error) {
        if (error) {
          callback(error);
        } else {
          directoryData[name] = new DirectoryEntry(fileNode.id, NODE_TYPE_FILE);
          context.putObject(directoryNode.data, directoryData, update_time);
        }
      }

      function handle_update_result(error) {
        if (error) {
          callback(error);
        } else {
          callback(null, fileNode);
        }
      }
    }

    function replace_data(context, ofd, buffer, offset, length, callback) {
      var fileNode;

      function return_nbytes(error) {
        if (error) {
          callback(error);
        } else {
          callback(null, length);
        }
      }

      function update_time(error) {
        if (error) {
          callback(error);
        } else {
          var now = Date.now();
          update_node_times(context, ofd.path, fileNode, {
            mtime: now,
            ctime: now
          }, return_nbytes);
        }
      }

      function update_file_node(error) {
        if (error) {
          callback(error);
        } else {
          context.putObject(fileNode.id, fileNode, update_time);
        }
      }

      function write_file_data(error, result) {
        if (error) {
          callback(error);
        } else {
          fileNode = result;
          var newData = Buffer.alloc(length);
          buffer.copy(newData, 0, offset, offset + length);
          ofd.position = length;
          fileNode.size = length;
          fileNode.version += 1;
          context.putBuffer(fileNode.data, newData, update_file_node);
        }
      }

      context.getObject(ofd.id, write_file_data);
    }

    function write_data(context, ofd, buffer, offset, length, position, callback) {
      var fileNode;
      var fileData;

      function return_nbytes(error) {
        if (error) {
          callback(error);
        } else {
          callback(null, length);
        }
      }

      function update_time(error) {
        if (error) {
          callback(error);
        } else {
          var now = Date.now();
          update_node_times(context, ofd.path, fileNode, {
            mtime: now,
            ctime: now
          }, return_nbytes);
        }
      }

      function update_file_node(error) {
        if (error) {
          callback(error);
        } else {
          context.putObject(fileNode.id, fileNode, update_time);
        }
      }

      function update_file_data(error, result) {
        if (error) {
          callback(error);
        } else {
          fileData = result;

          if (!fileData) {
            return callback(new Errors.EIO('Expected Buffer'));
          }

          var _position = !(undefined === position || null === position) ? position : ofd.position;

          var newSize = Math.max(fileData.length, _position + length);
          var newData = Buffer.alloc(newSize);

          if (fileData) {
            fileData.copy(newData);
          }

          buffer.copy(newData, _position, offset, offset + length);

          if (undefined === position) {
            ofd.position += length;
          }

          fileNode.size = newSize;
          fileNode.version += 1;
          context.putBuffer(fileNode.data, newData, update_file_node);
        }
      }

      function read_file_data(error, result) {
        if (error) {
          callback(error);
        } else {
          fileNode = result;
          context.getBuffer(fileNode.data, update_file_data);
        }
      }

      context.getObject(ofd.id, read_file_data);
    }

    function read_data(context, ofd, buffer, offset, length, position, callback) {
      var fileNode;
      var fileData;

      function handle_file_data(error, result) {
        if (error) {
          callback(error);
        } else {
          fileData = result;

          if (!fileData) {
            return callback(new Errors.EIO('Expected Buffer'));
          }

          var _position = !(undefined === position || null === position) ? position : ofd.position;

          length = _position + length > buffer.length ? length - _position : length;
          fileData.copy(buffer, offset, _position, _position + length);

          if (undefined === position) {
            ofd.position += length;
          }

          callback(null, length);
        }
      }

      function read_file_data(error, result) {
        if (error) {
          callback(error);
        } else if (result.type === NODE_TYPE_DIRECTORY) {
          callback(new Errors.EISDIR('the named file is a directory', ofd.path));
        } else {
          fileNode = result;
          context.getBuffer(fileNode.data, handle_file_data);
        }
      }

      context.getObject(ofd.id, read_file_data);
    }

    function stat_file(context, path, callback) {
      path = normalize(path);
      find_node(context, path, callback);
    }

    function fstat_file(context, ofd, callback) {
      ofd.getNode(context, callback);
    }

    function lstat_file(context, path, callback) {
      path = normalize(path);
      var name = basename(path);
      var parentPath = dirname(path);
      var directoryNode;
      var directoryData;

      if (ROOT_DIRECTORY_NAME === name) {
        find_node(context, path, callback);
      } else {
        find_node(context, parentPath, read_directory_data);
      }

      function read_directory_data(error, result) {
        if (error) {
          callback(error);
        } else {
          directoryNode = result;
          context.getObject(directoryNode.data, check_if_file_exists);
        }
      }

      function create_node(error, data) {
        if (error) {
          return callback(error);
        }

        Node.create(data, callback);
      }

      function check_if_file_exists(error, result) {
        if (error) {
          callback(error);
        } else {
          directoryData = result;

          if (!Object.prototype.hasOwnProperty.call(directoryData, name)) {
            callback(new Errors.ENOENT('a component of the path does not name an existing file', path));
          } else {
            context.getObject(directoryData[name].id, create_node);
          }
        }
      }
    }

    function link_node(context, oldpath, newpath, callback) {
      oldpath = normalize(oldpath);
      var oldname = basename(oldpath);
      var oldParentPath = dirname(oldpath);
      newpath = normalize(newpath);
      var newname = basename(newpath);
      var newParentPath = dirname(newpath);
      var ctime = Date.now();
      var oldDirectoryNode;
      var oldDirectoryData;
      var newDirectoryNode;
      var newDirectoryData;
      var fileNodeID;
      var fileNode;

      function update_time(error) {
        if (error) {
          callback(error);
        } else {
          update_node_times(context, newpath, fileNode, {
            ctime: ctime
          }, callback);
        }
      }

      function update_file_node(error, result) {
        if (error) {
          callback(error);
        } else {
          fileNode = result;
          fileNode.nlinks += 1;
          context.putObject(fileNode.id, fileNode, update_time);
        }
      }

      function read_file_node(error) {
        if (error) {
          callback(error);
        } else {
          context.getObject(fileNodeID, update_file_node);
        }
      }

      function check_if_new_file_exists(error, result) {
        if (error) {
          callback(error);
        } else {
          newDirectoryData = result;

          if (Object.prototype.hasOwnProperty.call(newDirectoryData, newname)) {
            callback(new Errors.EEXIST('newpath resolves to an existing file', newname));
          } else {
            newDirectoryData[newname] = oldDirectoryData[oldname];
            fileNodeID = newDirectoryData[newname].id;
            context.putObject(newDirectoryNode.data, newDirectoryData, read_file_node);
          }
        }
      }

      function read_new_directory_data(error, result) {
        if (error) {
          callback(error);
        } else {
          newDirectoryNode = result;
          context.getObject(newDirectoryNode.data, check_if_new_file_exists);
        }
      }

      function check_if_old_file_exists(error, result) {
        if (error) {
          callback(error);
        } else {
          oldDirectoryData = result;

          if (!Object.prototype.hasOwnProperty.call(oldDirectoryData, oldname)) {
            callback(new Errors.ENOENT('a component of either path prefix does not exist', oldname));
          } else if (oldDirectoryData[oldname].type === NODE_TYPE_DIRECTORY) {
            callback(new Errors.EPERM('oldpath refers to a directory'));
          } else {
            find_node(context, newParentPath, read_new_directory_data);
          }
        }
      }

      function read_old_directory_data(error, result) {
        if (error) {
          callback(error);
        } else {
          oldDirectoryNode = result;
          context.getObject(oldDirectoryNode.data, check_if_old_file_exists);
        }
      }

      find_node(context, oldParentPath, read_old_directory_data);
    }

    function unlink_node(context, path, callback) {
      path = normalize(path);
      var name = basename(path);
      var parentPath = dirname(path);
      var directoryNode;
      var directoryData;
      var fileNode;

      function update_directory_data(error) {
        if (error) {
          callback(error);
        } else {
          delete directoryData[name];
          context.putObject(directoryNode.data, directoryData, function (error) {
            if (error) {
              callback(error);
            } else {
              var now = Date.now();
              update_node_times(context, parentPath, directoryNode, {
                mtime: now,
                ctime: now
              }, callback);
            }
          });
        }
      }

      function delete_file_data(error) {
        if (error) {
          callback(error);
        } else {
          context.delete(fileNode.data, update_directory_data);
        }
      }

      function update_file_node(error, result) {
        if (error) {
          callback(error);
        } else {
          fileNode = result;
          fileNode.nlinks -= 1;

          if (fileNode.nlinks < 1) {
            context.delete(fileNode.id, delete_file_data);
          } else {
            context.putObject(fileNode.id, fileNode, function (error) {
              if (error) {
                callback(error);
              } else {
                update_node_times(context, path, fileNode, {
                  ctime: Date.now()
                }, update_directory_data);
              }
            });
          }
        }
      }

      function check_if_node_is_directory(error, result) {
        if (error) {
          callback(error);
        } else if (result.type === NODE_TYPE_DIRECTORY) {
          callback(new Errors.EPERM('unlink not permitted on directories', name));
        } else {
          update_file_node(null, result);
        }
      }

      function check_if_file_exists(error, result) {
        if (error) {
          callback(error);
        } else {
          directoryData = result;

          if (!Object.prototype.hasOwnProperty.call(directoryData, name)) {
            callback(new Errors.ENOENT('a component of the path does not name an existing file', name));
          } else {
            context.getObject(directoryData[name].id, check_if_node_is_directory);
          }
        }
      }

      function read_directory_data(error, result) {
        if (error) {
          callback(error);
        } else {
          directoryNode = result;
          context.getObject(directoryNode.data, check_if_file_exists);
        }
      }

      find_node(context, parentPath, read_directory_data);
    }

    function read_directory(context, path, options, callback) {
      path = normalize(path);

      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      options = validate_directory_options(options);
      var directoryNode;
      var directoryData;

      function handle_directory_data(error, result) {
        if (error) {
          callback(error);
        } else {
          directoryData = result;
          var files = Object.keys(directoryData);

          if (options.encoding) {
            var fileBuffers = files.map(function (file) {
              return Buffer.from(file);
            });

            if (options.encoding === 'buffer') {
              files = fileBuffers;
            } else {
              files = fileBuffers.map(function (fileBuffer) {
                return fileBuffer.toString(options.encoding);
              });
            }
          }

          if (options.withFileTypes) {
            var dirEnts = []; // eslint-disable-next-line no-inner-declarations

            function to_dir_entry(file, callback) {
              var filename = Buffer.from(file, options.encoding).toString();
              var filepath = Path.join(path, filename);
              get_dir_entry(context, filepath, function (error, dirEnt) {
                if (error) {
                  callback(error);
                }

                dirEnt.name = file;
                dirEnts.push(dirEnt);
                callback();
              });
            }

            async.eachSeries(files, to_dir_entry, function (error) {
              callback(error, dirEnts);
            });
          } else {
            callback(null, files);
          }
        }
      }

      function read_directory_data(error, result) {
        if (error) {
          callback(error);
        } else if (result.type !== NODE_TYPE_DIRECTORY) {
          callback(new Errors.ENOTDIR(null, path));
        } else {
          directoryNode = result;
          context.getObject(directoryNode.data, handle_directory_data);
        }
      }

      find_node(context, path, read_directory_data);
    }

    function get_dir_entry(context, path, callback) {
      function check_result(error, result) {
        if (error) {
          callback(error);
        } else {
          var stats = new Dirent(path, result, context.name);
          callback(null, stats);
        }
      }

      lstat_file(context, path, check_result);
    }

    function validate_directory_options(options, enc) {
      if (!options) {
        options = {
          encoding: enc
        };
      } else if (typeof options === 'function') {
        options = {
          encoding: enc
        };
      } else if (typeof options === 'string') {
        options = {
          encoding: options
        };
      }

      return options;
    }

    function make_symbolic_link(context, srcpath, dstpath, callback) {
      dstpath = normalize(dstpath);
      var name = basename(dstpath);
      var parentPath = dirname(dstpath);
      var directoryNode;
      var directoryData;
      var fileNode;

      if (ROOT_DIRECTORY_NAME === name) {
        callback(new Errors.EEXIST(null, name));
      } else {
        find_node(context, parentPath, read_directory_data);
      }

      function read_directory_data(error, result) {
        if (error) {
          callback(error);
        } else {
          directoryNode = result;
          context.getObject(directoryNode.data, check_if_file_exists);
        }
      }

      function check_if_file_exists(error, result) {
        if (error) {
          callback(error);
        } else {
          directoryData = result;

          if (Object.prototype.hasOwnProperty.call(directoryData, name)) {
            callback(new Errors.EEXIST(null, name));
          } else {
            write_file_node();
          }
        }
      }

      function write_file_node() {
        Node.create({
          guid: context.guid,
          type: NODE_TYPE_SYMBOLIC_LINK
        }, function (error, result) {
          if (error) {
            callback(error);
            return;
          }

          fileNode = result;
          fileNode.nlinks += 1; // If the srcpath isn't absolute, resolve it relative to the dstpath
          // but store both versions, since we'll use the relative one in readlink().

          if (!isAbsolutePath(srcpath)) {
            fileNode.symlink_relpath = srcpath;
            srcpath = Path.resolve(parentPath, srcpath);
          }

          fileNode.size = srcpath.length;
          fileNode.data = srcpath;
          context.putObject(fileNode.id, fileNode, update_directory_data);
        });
      }

      function update_time(error) {
        if (error) {
          callback(error);
        } else {
          var now = Date.now();
          update_node_times(context, parentPath, directoryNode, {
            mtime: now,
            ctime: now
          }, callback);
        }
      }

      function update_directory_data(error) {
        if (error) {
          callback(error);
        } else {
          directoryData[name] = new DirectoryEntry(fileNode.id, NODE_TYPE_SYMBOLIC_LINK);
          context.putObject(directoryNode.data, directoryData, update_time);
        }
      }
    }

    function read_link(context, path, callback) {
      path = normalize(path);
      var name = basename(path);
      var parentPath = dirname(path);
      var directoryNode;
      var directoryData;
      find_node(context, parentPath, read_directory_data);

      function read_directory_data(error, result) {
        if (error) {
          callback(error);
        } else {
          directoryNode = result;
          context.getObject(directoryNode.data, check_if_file_exists);
        }
      }

      function check_if_file_exists(error, result) {
        if (error) {
          callback(error);
        } else {
          directoryData = result;

          if (!Object.prototype.hasOwnProperty.call(directoryData, name)) {
            callback(new Errors.ENOENT('a component of the path does not name an existing file', name));
          } else {
            context.getObject(directoryData[name].id, check_if_symbolic);
          }
        }
      }

      function check_if_symbolic(error, fileNode) {
        if (error) {
          callback(error);
        } else {
          if (fileNode.type !== NODE_TYPE_SYMBOLIC_LINK) {
            callback(new Errors.EINVAL('path not a symbolic link', path));
          } else {
            // If we were originally given a relative path, return that now vs. the
            // absolute path we've generated and use elsewhere internally.
            var target = fileNode.symlink_relpath ? fileNode.symlink_relpath : fileNode.data;
            callback(null, target);
          }
        }
      }
    }

    function truncate_file(context, path, length, callback) {
      path = normalize(path);
      var fileNode;

      function read_file_data(error, node) {
        if (error) {
          callback(error);
        } else if (node.type === NODE_TYPE_DIRECTORY) {
          callback(new Errors.EISDIR(null, path));
        } else {
          fileNode = node;
          context.getBuffer(fileNode.data, truncate_file_data);
        }
      }

      function truncate_file_data(error, fileData) {
        if (error) {
          callback(error);
        } else {
          if (!fileData) {
            return callback(new Errors.EIO('Expected Buffer'));
          }

          var data = Buffer.alloc(length);

          if (fileData) {
            fileData.copy(data);
          }

          context.putBuffer(fileNode.data, data, update_file_node);
        }
      }

      function update_time(error) {
        if (error) {
          callback(error);
        } else {
          var now = Date.now();
          update_node_times(context, path, fileNode, {
            mtime: now,
            ctime: now
          }, callback);
        }
      }

      function update_file_node(error) {
        if (error) {
          callback(error);
        } else {
          fileNode.size = length;
          fileNode.version += 1;
          context.putObject(fileNode.id, fileNode, update_time);
        }
      }

      if (length < 0) {
        callback(new Errors.EINVAL('length cannot be negative'));
      } else {
        find_node(context, path, read_file_data);
      }
    }

    function ftruncate_file(context, ofd, length, callback) {
      var fileNode;

      function read_file_data(error, node) {
        if (error) {
          callback(error);
        } else if (node.type === NODE_TYPE_DIRECTORY) {
          callback(new Errors.EISDIR());
        } else {
          fileNode = node;
          context.getBuffer(fileNode.data, truncate_file_data);
        }
      }

      function truncate_file_data(error, fileData) {
        if (error) {
          callback(error);
        } else {
          var data;

          if (!fileData) {
            return callback(new Errors.EIO('Expected Buffer'));
          }

          if (fileData) {
            data = fileData.slice(0, length);
          } else {
            data = Buffer.alloc(length);
          }

          context.putBuffer(fileNode.data, data, update_file_node);
        }
      }

      function update_time(error) {
        if (error) {
          callback(error);
        } else {
          var now = Date.now();
          update_node_times(context, ofd.path, fileNode, {
            mtime: now,
            ctime: now
          }, callback);
        }
      }

      function update_file_node(error) {
        if (error) {
          callback(error);
        } else {
          fileNode.size = length;
          fileNode.version += 1;
          context.putObject(fileNode.id, fileNode, update_time);
        }
      }

      if (length < 0) {
        callback(new Errors.EINVAL('length cannot be negative'));
      } else {
        ofd.getNode(context, read_file_data);
      }
    }

    function utimes_file(context, path, atime, mtime, callback) {
      path = normalize(path);

      function update_times(error, node) {
        if (error) {
          callback(error);
        } else {
          update_node_times(context, path, node, {
            atime: atime,
            ctime: mtime,
            mtime: mtime
          }, callback);
        }
      }

      if (typeof atime !== 'number' || typeof mtime !== 'number') {
        callback(new Errors.EINVAL('atime and mtime must be number', path));
      } else if (atime < 0 || mtime < 0) {
        callback(new Errors.EINVAL('atime and mtime must be positive integers', path));
      } else {
        find_node(context, path, update_times);
      }
    }

    function futimes_file(context, ofd, atime, mtime, callback) {
      function update_times(error, node) {
        if (error) {
          callback(error);
        } else {
          update_node_times(context, ofd.path, node, {
            atime: atime,
            ctime: mtime,
            mtime: mtime
          }, callback);
        }
      }

      if (typeof atime !== 'number' || typeof mtime !== 'number') {
        callback(new Errors.EINVAL('atime and mtime must be a number'));
      } else if (atime < 0 || mtime < 0) {
        callback(new Errors.EINVAL('atime and mtime must be positive integers'));
      } else {
        ofd.getNode(context, update_times);
      }
    }

    function setxattr_file(context, path, name, value, flag, callback) {
      path = normalize(path);

      function setxattr(error, node) {
        if (error) {
          return callback(error);
        }

        set_extended_attribute(context, path, node, name, value, flag, callback);
      }

      if (typeof name !== 'string') {
        callback(new Errors.EINVAL('attribute name must be a string', path));
      } else if (!name) {
        callback(new Errors.EINVAL('attribute name cannot be an empty string', path));
      } else if (flag !== null && flag !== XATTR_CREATE && flag !== XATTR_REPLACE) {
        callback(new Errors.EINVAL('invalid flag, must be null, XATTR_CREATE or XATTR_REPLACE', path));
      } else {
        find_node(context, path, setxattr);
      }
    }

    function fsetxattr_file(context, ofd, name, value, flag, callback) {
      function setxattr(error, node) {
        if (error) {
          return callback(error);
        }

        set_extended_attribute(context, ofd.path, node, name, value, flag, callback);
      }

      if (typeof name !== 'string') {
        callback(new Errors.EINVAL('attribute name must be a string'));
      } else if (!name) {
        callback(new Errors.EINVAL('attribute name cannot be an empty string'));
      } else if (flag !== null && flag !== XATTR_CREATE && flag !== XATTR_REPLACE) {
        callback(new Errors.EINVAL('invalid flag, must be null, XATTR_CREATE or XATTR_REPLACE'));
      } else {
        ofd.getNode(context, setxattr);
      }
    }

    function getxattr_file(context, path, name, callback) {
      path = normalize(path);

      function get_xattr(error, node) {
        if (error) {
          return callback(error);
        }

        var xattrs = node.xattrs;

        if (!Object.prototype.hasOwnProperty.call(xattrs, name)) {
          callback(new Errors.ENOATTR(null, path));
        } else {
          callback(null, xattrs[name]);
        }
      }

      if (typeof name !== 'string') {
        callback(new Errors.EINVAL('attribute name must be a string', path));
      } else if (!name) {
        callback(new Errors.EINVAL('attribute name cannot be an empty string', path));
      } else {
        find_node(context, path, get_xattr);
      }
    }

    function fgetxattr_file(context, ofd, name, callback) {
      function get_xattr(error, node) {
        if (error) {
          return callback(error);
        }

        var xattrs = node.xattrs;

        if (!Object.prototype.hasOwnProperty.call(xattrs, name)) {
          callback(new Errors.ENOATTR());
        } else {
          callback(null, xattrs[name]);
        }
      }

      if (typeof name !== 'string') {
        callback(new Errors.EINVAL());
      } else if (!name) {
        callback(new Errors.EINVAL('attribute name cannot be an empty string'));
      } else {
        ofd.getNode(context, get_xattr);
      }
    }

    function removexattr_file(context, path, name, callback) {
      path = normalize(path);

      function remove_xattr(error, node) {
        if (error) {
          return callback(error);
        }

        function update_time(error) {
          if (error) {
            callback(error);
          } else {
            update_node_times(context, path, node, {
              ctime: Date.now()
            }, callback);
          }
        }

        var xattrs = node.xattrs;

        if (!Object.prototype.hasOwnProperty.call(xattrs, name)) {
          callback(new Errors.ENOATTR(null, path));
        } else {
          delete xattrs[name];
          context.putObject(node.id, node, update_time);
        }
      }

      if (typeof name !== 'string') {
        callback(new Errors.EINVAL('attribute name must be a string', path));
      } else if (!name) {
        callback(new Errors.EINVAL('attribute name cannot be an empty string', path));
      } else {
        find_node(context, path, remove_xattr);
      }
    }

    function fremovexattr_file(context, ofd, name, callback) {
      function remove_xattr(error, node) {
        if (error) {
          return callback(error);
        }

        function update_time(error) {
          if (error) {
            callback(error);
          } else {
            update_node_times(context, ofd.path, node, {
              ctime: Date.now()
            }, callback);
          }
        }

        var xattrs = node.xattrs;

        if (!Object.prototype.hasOwnProperty.call(xattrs, name)) {
          callback(new Errors.ENOATTR());
        } else {
          delete xattrs[name];
          context.putObject(node.id, node, update_time);
        }
      }

      if (typeof name !== 'string') {
        callback(new Errors.EINVAL('attribute name must be a string'));
      } else if (!name) {
        callback(new Errors.EINVAL('attribute name cannot be an empty string'));
      } else {
        ofd.getNode(context, remove_xattr);
      }
    }

    function validate_flags(flags) {
      return Object.prototype.hasOwnProperty.call(O_FLAGS, flags) ? O_FLAGS[flags] : null;
    }

    function validate_file_options(options, enc, fileMode) {
      if (!options) {
        options = {
          encoding: enc,
          flag: fileMode
        };
      } else if (typeof options === 'function') {
        options = {
          encoding: enc,
          flag: fileMode
        };
      } else if (typeof options === 'string') {
        options = {
          encoding: options,
          flag: fileMode
        };
      }

      return options;
    }

    function open(context, path, flags, mode, callback) {
      if (arguments.length < 5) {
        callback = arguments[arguments.length - 1];
        mode = 420;
      } else {
        mode = validateAndMaskMode(mode, FULL_READ_WRITE_EXEC_PERMISSIONS, callback);
      }

      function check_result(error, fileNode) {
        if (error) {
          callback(error);
        } else {
          var position;

          if (flags.includes(O_APPEND)) {
            position = fileNode.size;
          } else {
            position = 0;
          }

          var openFileDescription = new OpenFileDescription(path, fileNode.id, flags, position);
          var fd = openFiles.allocDescriptor(openFileDescription);
          callback(null, fd);
        }
      }

      flags = validate_flags(flags);

      if (!flags) {
        return callback(new Errors.EINVAL('flags is not valid'), path);
      }

      open_file(context, path, flags, mode, check_result);
    }

    function close(context, fd, callback) {
      if (!openFiles.getOpenFileDescription(fd)) {
        callback(new Errors.EBADF());
      } else {
        openFiles.releaseDescriptor(fd);
        callback(null);
      }
    }

    function mknod(context, path, type, callback) {
      make_node(context, path, type, callback);
    }

    function mkdir(context, path, mode, callback) {
      if (arguments.length < 4) {
        callback = mode;
        mode = FULL_READ_WRITE_EXEC_PERMISSIONS;
      } else {
        mode = validateAndMaskMode(mode, FULL_READ_WRITE_EXEC_PERMISSIONS, callback);
        if (!mode) return;
      }

      make_directory(context, path, callback);
    }

    function access(context, path, mode, callback) {
      if (typeof mode === 'function') {
        callback = mode;
        mode = Constants.fsConstants.F_OK;
      }

      mode = mode | Constants.fsConstants.F_OK;
      access_file(context, path, mode, callback);
    }

    function mkdtemp(context, prefix, options, callback) {
      callback = arguments[arguments.length - 1];

      if (!prefix) {
        return callback(new Error('filename prefix is required'));
      }

      var random = shared.randomChars(6);
      var path = prefix + '-' + random;
      make_directory(context, path, function (error) {
        callback(error, path);
      });
    }

    function rmdir(context, path, callback) {
      remove_directory(context, path, callback);
    }

    function stat(context, path, callback) {
      function check_result(error, result) {
        if (error) {
          callback(error);
        } else {
          var stats = new Stats(path, result, context.name);
          callback(null, stats);
        }
      }

      stat_file(context, path, check_result);
    }

    function fstat(context, fd, callback) {
      function check_result(error, result) {
        if (error) {
          callback(error);
        } else {
          var stats = new Stats(ofd.path, result, context.name);
          callback(null, stats);
        }
      }

      var ofd = openFiles.getOpenFileDescription(fd);

      if (!ofd) {
        callback(new Errors.EBADF());
      } else {
        fstat_file(context, ofd, check_result);
      }
    }

    function link(context, oldpath, newpath, callback) {
      link_node(context, oldpath, newpath, callback);
    }

    function unlink(context, path, callback) {
      unlink_node(context, path, callback);
    }

    function read(context, fd, buffer, offset, length, position, callback) {
      // Follow how node.js does this
      function wrapped_cb(err, bytesRead) {
        // Retain a reference to buffer so that it can't be GC'ed too soon.
        callback(err, bytesRead || 0, buffer);
      }

      offset = undefined === offset ? 0 : offset;
      length = undefined === length ? buffer.length - offset : length;
      callback = arguments[arguments.length - 1];
      var ofd = openFiles.getOpenFileDescription(fd);

      if (!ofd) {
        callback(new Errors.EBADF());
      } else if (!ofd.flags.includes(O_READ)) {
        callback(new Errors.EBADF('descriptor does not permit reading'));
      } else {
        read_data(context, ofd, buffer, offset, length, position, wrapped_cb);
      }
    }

    function fsync(context, fd, callback) {
      if (validateInteger(fd, callback) !== fd) return;
      var ofd = openFiles.getOpenFileDescription(fd);

      if (!ofd) {
        callback(new Errors.EBADF());
      } else {
        callback();
      }
    }

    function readFile(context, path, options, callback) {
      callback = arguments[arguments.length - 1];
      options = validate_file_options(options, null, 'r');
      var flags = validate_flags(options.flag || 'r');

      if (!flags) {
        return callback(new Errors.EINVAL('flags is not valid', path));
      }

      open_file(context, path, flags, function (err, fileNode) {
        if (err) {
          return callback(err);
        }

        var ofd = new OpenFileDescription(path, fileNode.id, flags, 0);
        var fd = openFiles.allocDescriptor(ofd);

        function cleanup() {
          openFiles.releaseDescriptor(fd);
        }

        fstat_file(context, ofd, function (err, fstatResult) {
          if (err) {
            cleanup();
            return callback(err);
          }

          var stats = new Stats(ofd.path, fstatResult, context.name);

          if (stats.isDirectory()) {
            cleanup();
            return callback(new Errors.EISDIR('illegal operation on directory', path));
          }

          var size = stats.size;
          var buffer = Buffer.alloc(size);
          read_data(context, ofd, buffer, 0, size, 0, function (err) {
            cleanup();

            if (err) {
              return callback(err);
            }

            var data;

            if (options.encoding === 'utf8') {
              data = buffer.toString('utf8');
            } else {
              data = buffer;
            }

            callback(null, data);
          });
        });
      });
    }

    function write(context, fd, buffer, offset, length, position, callback) {
      callback = arguments[arguments.length - 1];
      offset = undefined === offset ? 0 : offset;
      length = undefined === length ? buffer.length - offset : length;
      var ofd = openFiles.getOpenFileDescription(fd);

      if (!ofd) {
        callback(new Errors.EBADF());
      } else if (!ofd.flags.includes(O_WRITE)) {
        callback(new Errors.EBADF('descriptor does not permit writing'));
      } else if (buffer.length - offset < length) {
        callback(new Errors.EIO('input buffer is too small'));
      } else {
        write_data(context, ofd, buffer, offset, length, position, callback);
      }
    }

    function writeFile(context, path, data, options, callback) {
      callback = arguments[arguments.length - 1];
      options = validate_file_options(options, 'utf8', 'w');
      var flags = validate_flags(options.flag || 'w');

      if (!flags) {
        return callback(new Errors.EINVAL('flags is not valid', path));
      }

      if (!Buffer.isBuffer(data)) {
        if (typeof data === 'number') {
          data = '' + data;
        }

        data = data || '';

        if (typeof data !== 'string') {
          data = Buffer.from(data.toString());
        } else {
          data = Buffer.from(data || '', options.encoding || 'utf8');
        }
      }

      open_file(context, path, flags, function (err, fileNode) {
        if (err) {
          return callback(err);
        }

        var ofd = new OpenFileDescription(path, fileNode.id, flags, 0);
        var fd = openFiles.allocDescriptor(ofd);
        replace_data(context, ofd, data, 0, data.length, function (err) {
          openFiles.releaseDescriptor(fd);

          if (err) {
            return callback(err);
          }

          callback(null);
        });
      });
    }

    function appendFile(context, path, data, options, callback) {
      callback = arguments[arguments.length - 1];
      options = validate_file_options(options, 'utf8', 'a');
      var flags = validate_flags(options.flag || 'a');

      if (!flags) {
        return callback(new Errors.EINVAL('flags is not valid', path));
      }

      data = data || '';

      if (typeof data === 'number') {
        data = '' + data;
      }

      if (typeof data === 'string' && options.encoding === 'utf8') {
        data = Buffer.from(data);
      }

      open_file(context, path, flags, function (err, fileNode) {
        if (err) {
          return callback(err);
        }

        var ofd = new OpenFileDescription(path, fileNode.id, flags, fileNode.size);
        var fd = openFiles.allocDescriptor(ofd);
        write_data(context, ofd, data, 0, data.length, ofd.position, function (err) {
          openFiles.releaseDescriptor(fd);

          if (err) {
            return callback(err);
          }

          callback(null);
        });
      });
    }

    function exists(context, path, callback) {
      function cb(err) {
        callback(err ? false : true);
      }

      stat(context, path, cb);
    }

    function validateInteger(value, callback) {
      if (typeof value !== 'number') {
        callback(new Errors.EINVAL('Expected integer', value));
        return;
      }

      return value;
    } // Based on https://github.com/nodejs/node/blob/c700cc42da9cf73af9fec2098520a6c0a631d901/lib/internal/validators.js#L21


    var octalReg = /^[0-7]+$/;

    function isUint32(value) {
      return value === value >>> 0;
    } // Validator for mode_t (the S_* constants). Valid numbers or octal strings
    // will be masked with 0o777 to be consistent with the behavior in POSIX APIs.


    function validateAndMaskMode(value, def, callback) {
      if (typeof def === 'function') {
        callback = def;
        def = undefined;
      }

      if (isUint32(value)) {
        return value & FULL_READ_WRITE_EXEC_PERMISSIONS;
      }

      if (typeof value === 'number') {
        if (!Number.isInteger(value)) {
          callback(new Errors.EINVAL('mode not a valid an integer value', value));
          return false;
        } else {
          // 2 ** 32 === 4294967296
          callback(new Errors.EINVAL('mode not a valid an integer value', value));
          return false;
        }
      }

      if (typeof value === 'string') {
        if (!octalReg.test(value)) {
          callback(new Errors.EINVAL('mode not a valid octal string', value));
          return false;
        }

        var parsed = parseInt(value, 8);
        return parsed & FULL_READ_WRITE_EXEC_PERMISSIONS;
      } // TODO(BridgeAR): Only return `def` in case `value === null`


      if (def !== undefined) {
        return def;
      }

      callback(new Errors.EINVAL('mode not valid', value));
      return false;
    }

    function chmod_file(context, path, mode, callback) {
      path = normalize(path);

      function update_mode(error, node) {
        if (error) {
          callback(error);
        } else {
          node.mode = mode;
          update_node_times(context, path, node, {
            mtime: Date.now()
          }, callback);
        }
      }

      if (typeof mode !== 'number') {
        callback(new Errors.EINVAL('mode must be number', path));
      } else {
        find_node(context, path, update_mode);
      }
    }

    function fchmod_file(context, ofd, mode, callback) {
      function update_mode(error, node) {
        if (error) {
          callback(error);
        } else {
          node.mode = mode;
          update_node_times(context, ofd.path, node, {
            mtime: Date.now()
          }, callback);
        }
      }

      if (typeof mode !== 'number') {
        callback(new Errors.EINVAL('mode must be a number'));
      } else {
        ofd.getNode(context, update_mode);
      }
    }

    function chown_file(context, path, uid, gid, callback) {
      path = normalize(path);

      function update_owner(error, node) {
        if (error) {
          callback(error);
        } else {
          node.uid = uid;
          node.gid = gid;
          update_node_times(context, path, node, {
            mtime: Date.now()
          }, callback);
        }
      }

      find_node(context, path, update_owner);
    }

    function fchown_file(context, ofd, uid, gid, callback) {
      function update_owner(error, node) {
        if (error) {
          callback(error);
        } else {
          node.uid = uid;
          node.gid = gid;
          update_node_times(context, ofd.path, node, {
            mtime: Date.now()
          }, callback);
        }
      }

      ofd.getNode(context, update_owner);
    }

    function getxattr(context, path, name, callback) {
      getxattr_file(context, path, name, callback);
    }

    function fgetxattr(context, fd, name, callback) {
      var ofd = openFiles.getOpenFileDescription(fd);

      if (!ofd) {
        callback(new Errors.EBADF());
      } else {
        fgetxattr_file(context, ofd, name, callback);
      }
    }

    function setxattr(context, path, name, value, flag, callback) {
      if (typeof flag === 'function') {
        callback = flag;
        flag = null;
      }

      setxattr_file(context, path, name, value, flag, callback);
    }

    function fsetxattr(context, fd, name, value, flag, callback) {
      if (typeof flag === 'function') {
        callback = flag;
        flag = null;
      }

      var ofd = openFiles.getOpenFileDescription(fd);

      if (!ofd) {
        callback(new Errors.EBADF());
      } else if (!ofd.flags.includes(O_WRITE)) {
        callback(new Errors.EBADF('descriptor does not permit writing'));
      } else {
        fsetxattr_file(context, ofd, name, value, flag, callback);
      }
    }

    function removexattr(context, path, name, callback) {
      removexattr_file(context, path, name, callback);
    }

    function fremovexattr(context, fd, name, callback) {
      var ofd = openFiles.getOpenFileDescription(fd);

      if (!ofd) {
        callback(new Errors.EBADF());
      } else if (!ofd.flags.includes(O_WRITE)) {
        callback(new Errors.EBADF('descriptor does not permit writing'));
      } else {
        fremovexattr_file(context, ofd, name, callback);
      }
    }

    function lseek(context, fd, offset, whence, callback) {
      function update_descriptor_position(error, stats) {
        if (error) {
          callback(error);
        } else {
          if (stats.size + offset < 0) {
            callback(new Errors.EINVAL('resulting file offset would be negative'));
          } else {
            ofd.position = stats.size + offset;
            callback(null, ofd.position);
          }
        }
      }

      var ofd = openFiles.getOpenFileDescription(fd);

      if (!ofd) {
        callback(new Errors.EBADF());
      }

      if ('SET' === whence) {
        if (offset < 0) {
          callback(new Errors.EINVAL('resulting file offset would be negative'));
        } else {
          ofd.position = offset;
          callback(null, ofd.position);
        }
      } else if ('CUR' === whence) {
        if (ofd.position + offset < 0) {
          callback(new Errors.EINVAL('resulting file offset would be negative'));
        } else {
          ofd.position += offset;
          callback(null, ofd.position);
        }
      } else if ('END' === whence) {
        fstat_file(context, ofd, update_descriptor_position);
      } else {
        callback(new Errors.EINVAL('whence argument is not a proper value'));
      }
    }

    function readdir(context, path, options, callback) {
      read_directory(context, path, options, callback);
    }

    function toUnixTimestamp(time) {
      if (typeof time === 'number') {
        return time;
      }

      if (_typeof(time) === 'object' && typeof time.getTime === 'function') {
        return time.getTime();
      }
    }

    function utimes(context, path, atime, mtime, callback) {
      var currentTime = Date.now();
      atime = atime ? toUnixTimestamp(atime) : toUnixTimestamp(currentTime);
      mtime = mtime ? toUnixTimestamp(mtime) : toUnixTimestamp(currentTime);
      utimes_file(context, path, atime, mtime, callback);
    }

    function futimes(context, fd, atime, mtime, callback) {
      var currentTime = Date.now();
      atime = atime ? toUnixTimestamp(atime) : toUnixTimestamp(currentTime);
      mtime = mtime ? toUnixTimestamp(mtime) : toUnixTimestamp(currentTime);
      var ofd = openFiles.getOpenFileDescription(fd);

      if (!ofd) {
        callback(new Errors.EBADF());
      } else if (!ofd.flags.includes(O_WRITE)) {
        callback(new Errors.EBADF('descriptor does not permit writing'));
      } else {
        futimes_file(context, ofd, atime, mtime, callback);
      }
    }

    function chmod(context, path, mode, callback) {
      mode = validateAndMaskMode(mode, callback);
      if (!mode) return;
      chmod_file(context, path, mode, callback);
    }

    function fchmod(context, fd, mode, callback) {
      mode = validateAndMaskMode(mode, callback);
      if (!mode) return;
      var ofd = openFiles.getOpenFileDescription(fd);

      if (!ofd) {
        callback(new Errors.EBADF());
      } else if (!ofd.flags.includes(O_WRITE)) {
        callback(new Errors.EBADF('descriptor does not permit writing'));
      } else {
        fchmod_file(context, ofd, mode, callback);
      }
    }

    function chown(context, path, uid, gid, callback) {
      if (!isUint32(uid)) {
        return callback(new Errors.EINVAL('uid must be a valid integer', uid));
      }

      if (!isUint32(gid)) {
        return callback(new Errors.EINVAL('gid must be a valid integer', gid));
      }

      chown_file(context, path, uid, gid, callback);
    }

    function fchown(context, fd, uid, gid, callback) {
      if (!isUint32(uid)) {
        return callback(new Errors.EINVAL('uid must be a valid integer', uid));
      }

      if (!isUint32(gid)) {
        return callback(new Errors.EINVAL('gid must be a valid integer', gid));
      }

      var ofd = openFiles.getOpenFileDescription(fd);

      if (!ofd) {
        callback(new Errors.EBADF());
      } else if (!ofd.flags.includes(O_WRITE)) {
        callback(new Errors.EBADF('descriptor does not permit writing'));
      } else {
        fchown_file(context, ofd, uid, gid, callback);
      }
    }

    function rename(context, oldpath, newpath, callback) {
      oldpath = normalize(oldpath);
      newpath = normalize(newpath);
      var oldParentPath = Path.dirname(oldpath);
      var newParentPath = Path.dirname(newpath);
      var oldName = Path.basename(oldpath);
      var newName = Path.basename(newpath);
      var oldParentDirectory, oldParentData;
      var newParentDirectory, newParentData;
      var ctime = Date.now();
      var fileNode;

      function update_times(error, result) {
        if (error) {
          callback(error);
        } else {
          fileNode = result;
          update_node_times(context, newpath, fileNode, {
            ctime: ctime
          }, callback);
        }
      }

      function read_new_directory(error) {
        if (error) {
          callback(error);
        } else {
          context.getObject(newParentData[newName].id, update_times);
        }
      }

      function update_old_parent_directory_data(error) {
        if (error) {
          callback(error);
        } else {
          if (oldParentDirectory.id === newParentDirectory.id) {
            oldParentData = newParentData;
          }

          delete oldParentData[oldName];
          context.putObject(oldParentDirectory.data, oldParentData, read_new_directory);
        }
      }

      function update_new_parent_directory_data(error) {
        if (error) {
          callback(error);
        } else {
          newParentData[newName] = oldParentData[oldName];
          context.putObject(newParentDirectory.data, newParentData, update_old_parent_directory_data);
        }
      }

      function check_if_new_directory_exists(error, result) {
        if (error) {
          callback(error);
        } else {
          newParentData = result;

          if (Object.prototype.hasOwnProperty.call(newParentData, newName)) {
            remove_directory(context, newpath, update_new_parent_directory_data);
          } else {
            update_new_parent_directory_data();
          }
        }
      }

      function read_new_parent_directory_data(error, result) {
        if (error) {
          callback(error);
        } else {
          newParentDirectory = result;
          context.getObject(newParentDirectory.data, check_if_new_directory_exists);
        }
      }

      function get_new_parent_directory(error, result) {
        if (error) {
          callback(error);
        } else {
          oldParentData = result;
          find_node(context, newParentPath, read_new_parent_directory_data);
        }
      }

      function read_parent_directory_data(error, result) {
        if (error) {
          callback(error);
        } else {
          oldParentDirectory = result;
          context.getObject(result.data, get_new_parent_directory);
        }
      }

      function unlink_old_file(error) {
        if (error) {
          callback(error);
        } else {
          unlink_node(context, oldpath, callback);
        }
      }

      function check_node_type(error, node) {
        if (error) {
          callback(error);
        } else if (node.type === NODE_TYPE_DIRECTORY) {
          find_node(context, oldParentPath, read_parent_directory_data);
        } else {
          link_node(context, oldpath, newpath, unlink_old_file);
        }
      }

      find_node(context, oldpath, check_node_type);
    }

    function symlink(context, srcpath, dstpath, type, callback) {
      // NOTE: we support passing the `type` arg, but ignore it.
      callback = arguments[arguments.length - 1];
      make_symbolic_link(context, srcpath, dstpath, callback);
    }

    function readlink(context, path, callback) {
      read_link(context, path, callback);
    }

    function lstat(context, path, callback) {
      function check_result(error, result) {
        if (error) {
          callback(error);
        } else {
          var stats = new Stats(path, result, context.name);
          callback(null, stats);
        }
      }

      lstat_file(context, path, check_result);
    }

    function truncate(context, path, length, callback) {
      // NOTE: length is optional
      callback = arguments[arguments.length - 1];
      length = length || 0;
      if (validateInteger(length, callback) !== length) return;
      truncate_file(context, path, length, callback);
    }

    function ftruncate(context, fd, length, callback) {
      // NOTE: length is optional
      callback = arguments[arguments.length - 1];
      length = length || 0;
      var ofd = openFiles.getOpenFileDescription(fd);

      if (!ofd) {
        callback(new Errors.EBADF());
      } else if (!ofd.flags.includes(O_WRITE)) {
        callback(new Errors.EBADF('descriptor does not permit writing'));
      } else {
        if (validateInteger(length, callback) !== length) return;
        ftruncate_file(context, ofd, length, callback);
      }
    }

    module.exports = {
      appendFile: appendFile,
      access: access,
      chown: chown,
      chmod: chmod,
      close: close,
      // copyFile - https://github.com/filerjs/filer/issues/436
      ensureRootDirectory: ensure_root_directory,
      exists: exists,
      fchown: fchown,
      fchmod: fchmod,
      // fdatasync - https://github.com/filerjs/filer/issues/653
      fgetxattr: fgetxattr,
      fremovexattr: fremovexattr,
      fsetxattr: fsetxattr,
      fstat: fstat,
      fsync: fsync,
      ftruncate: ftruncate,
      futimes: futimes,
      getxattr: getxattr,
      // lchown - https://github.com/filerjs/filer/issues/620
      // lchmod - https://github.com/filerjs/filer/issues/619
      link: link,
      lseek: lseek,
      lstat: lstat,
      mkdir: mkdir,
      mkdtemp: mkdtemp,
      mknod: mknod,
      open: open,
      readdir: readdir,
      read: read,
      readFile: readFile,
      readlink: readlink,
      // realpath - https://github.com/filerjs/filer/issues/85
      removexattr: removexattr,
      rename: rename,
      rmdir: rmdir,
      setxattr: setxattr,
      stat: stat,
      symlink: symlink,
      truncate: truncate,
      // unwatchFile - implemented in interface.js
      unlink: unlink,
      utimes: utimes,
      // watch - implemented in interface.js
      // watchFile - implemented in interface.js
      writeFile: writeFile,
      write: write
    };
  }, { "../path.js": "UzoP", "../shared.js": "zBMa", "../../lib/async.js": "u4Zs", "../constants.js": "iJA9", "../errors.js": "p8GN", "../directory-entry.js": "ZECt", "../open-files.js": "osLK", "../open-file-description.js": "XWaV", "../super-node.js": "JEp0", "../node.js": "KKNo", "../dirent.js": "q4Wu", "../stats.js": "dsCT", "buffer": "dskh" }], "GMi4": [function (require, module, exports) {
    var Buffer = require("buffer").Buffer;
    'use strict';

    var _require = require('es6-promisify'),
      promisify = _require.promisify;

    var Path = require('../path.js');

    var providers = require('../providers/index.js');

    var Shell = require('../shell/shell.js');

    var Intercom = require('../../lib/intercom.js');

    var FSWatcher = require('../fs-watcher.js');

    var Errors = require('../errors.js');

    var _require2 = require('../shared.js'),
      nop = _require2.nop,
      defaultGuidFn = _require2.guid;

    var _require3 = require('../constants.js'),
      fsConstants = _require3.fsConstants,
      FILE_SYSTEM_NAME = _require3.FILE_SYSTEM_NAME,
      FS_FORMAT = _require3.FS_FORMAT,
      FS_READY = _require3.FS_READY,
      FS_PENDING = _require3.FS_PENDING,
      FS_ERROR = _require3.FS_ERROR,
      FS_NODUPEIDCHECK = _require3.FS_NODUPEIDCHECK,
      STDIN = _require3.STDIN,
      STDOUT = _require3.STDOUT,
      STDERR = _require3.STDERR; // The core fs operations live on impl


    var impl = require('./implementation.js'); // node.js supports a calling pattern that leaves off a callback.


    function maybeCallback(callback) {
      if (typeof callback === 'function') {
        return callback;
      }

      return function (err) {
        if (err) {
          throw err;
        }
      };
    } // Default callback that logs an error if passed in


    function defaultCallback(err) {
      if (err) {
        /* eslint no-console: 0 */
        console.error('Filer error: ', err);
      }
    } // Get a path (String) from a file:// URL. Support URL() like objects
    // https://github.com/nodejs/node/blob/968e901aff38a343b1de4addebf79fd8fa991c59/lib/internal/url.js#L1381


    function toPathIfFileURL(fileURLOrPath) {
      if (!(fileURLOrPath && fileURLOrPath.protocol && fileURLOrPath.pathname)) {
        return fileURLOrPath;
      }

      if (fileURLOrPath.protocol !== 'file:') {
        throw new Errors.EINVAL('only file: URLs are supported for paths', fileURLOrPath);
      }

      var pathname = fileURLOrPath.pathname;

      for (var n = 0; n < pathname.length; n++) {
        if (pathname[n] === '%') {
          var third = pathname.codePointAt(n + 2) | 0x20;

          if (pathname[n + 1] === '2' && third === 102) {
            throw new Errors.EINVAL('file: URLs must not include encoded / characters', fileURLOrPath);
          }
        }
      }

      return decodeURIComponent(pathname);
    } // Allow Buffers for paths. Assumes we want UTF8.


    function toPathIfBuffer(bufferOrPath) {
      return Buffer.isBuffer(bufferOrPath) ? bufferOrPath.toString() : bufferOrPath;
    }

    function validatePath(path, allowRelative) {
      if (!path) {
        return new Errors.EINVAL('Path must be a string', path);
      } else if (Path.isNull(path)) {
        return new Errors.EINVAL('Path must be a string without null bytes.', path);
      } else if (!allowRelative && !Path.isAbsolute(path)) {
        return new Errors.EINVAL('Path must be absolute.', path);
      }
    }

    function processPathArg(args, idx, allowRelative) {
      var path = args[idx];
      path = toPathIfFileURL(path);
      path = toPathIfBuffer(path); // Some methods specifically allow for rel paths (eg symlink with srcPath)

      var err = validatePath(path, allowRelative);

      if (err) {
        throw err;
      } // Overwrite path arg with converted and validated path


      args[idx] = path;
    }
    /**
     * FileSystem
     *
     * A FileSystem takes an `options` object, which can specify a number of,
     * options.  All options are optional, and include:
     *
     * name: the name of the file system, defaults to "local"
     *
     * flags: one or more flags to use when creating/opening the file system.
     *        For example: "FORMAT" will cause the file system to be formatted.
     *        No explicit flags are set by default.
     *
     * provider: an explicit storage provider to use for the file
     *           system's database context provider.  A number of context
     *           providers are included (see /src/providers), and users
     *           can write one of their own and pass it in to be used.
     *           By default an IndexedDB provider is used.
     *
     * guid: a function for generating unique IDs for nodes in the filesystem.
     *       Use this to override the built-in UUID generation. (Used mainly for tests).
     *
     * callback: a callback function to be executed when the file system becomes
     *           ready for use. Depending on the context provider used, this might
     *           be right away, or could take some time. The callback should expect
     *           an `error` argument, which will be null if everything worked.  Also
     *           users should check the file system's `readyState` and `error`
     *           properties to make sure it is usable.
     */


    function FileSystem(options, callback) {
      options = options || {};
      callback = callback || defaultCallback;
      var flags = options.flags || [];
      var guid = options.guid ? options.guid : defaultGuidFn;
      var provider = options.provider || new providers.Default(options.name || FILE_SYSTEM_NAME); // If we're given a provider, match its name unless we get an explicit name

      var name = options.name || provider.name;
      var forceFormatting = flags.includes(FS_FORMAT);
      var fs = this;
      fs.readyState = FS_PENDING;
      fs.name = name;
      fs.error = null;
      fs.stdin = STDIN;
      fs.stdout = STDOUT;
      fs.stderr = STDERR; // Expose Node's fs.constants to users

      fs.constants = fsConstants; // Node also forwards the access mode flags onto fs

      fs.F_OK = fsConstants.F_OK;
      fs.R_OK = fsConstants.R_OK;
      fs.W_OK = fsConstants.W_OK;
      fs.X_OK = fsConstants.X_OK; // Expose Shell constructor

      this.Shell = Shell.bind(undefined, this); // Safely expose the operation queue

      var queue = [];

      this.queueOrRun = function (operation) {
        var error;

        if (FS_READY === fs.readyState) {
          operation.call(fs);
        } else if (FS_ERROR === fs.readyState) {
          error = new Errors.EFILESYSTEMERROR('unknown error');
        } else {
          queue.push(operation);
        }

        return error;
      };

      function runQueued() {
        queue.forEach(function (operation) {
          operation.call(this);
        }.bind(fs));
        queue = null;
      } // We support the optional `options` arg from node, but ignore it


      this.watch = function (filename, options, listener) {
        if (Path.isNull(filename)) {
          throw new Error('Path must be a string without null bytes.');
        }

        if (typeof options === 'function') {
          listener = options;
          options = {};
        }

        options = options || {};
        listener = listener || nop;
        var watcher = new FSWatcher();
        watcher.start(filename, false, options.recursive);
        watcher.on('change', listener);
        return watcher;
      }; // Deal with various approaches to node ID creation


      function wrappedGuidFn(context) {
        return function (callback) {
          // Skip the duplicate ID check if asked to
          if (flags.includes(FS_NODUPEIDCHECK)) {
            callback(null, guid());
            return;
          } // Otherwise (default) make sure this id is unused first


          function guidWithCheck(callback) {
            var id = guid();
            context.getObject(id, function (err, value) {
              if (err) {
                callback(err);
                return;
              } // If this id is unused, use it, otherwise find another


              if (!value) {
                callback(null, id);
              } else {
                guidWithCheck(callback);
              }
            });
          }

          guidWithCheck(callback);
        };
      } // Let other instances (in this or other windows) know about
      // any changes to this fs instance.


      function broadcastChanges(changes) {
        if (!changes.length) {
          return;
        }

        var intercom = Intercom.getInstance();
        changes.forEach(function (change) {
          intercom.emit(change.event, change.path);
        });
      } // Open file system storage provider


      provider.open(function (err) {
        function complete(error) {
          function wrappedContext(methodName) {
            var context = provider[methodName]();
            context.name = name;
            context.flags = flags;
            context.changes = [];
            context.guid = wrappedGuidFn(context); // When the context is finished, let the fs deal with any change events

            context.close = function () {
              var changes = context.changes;
              broadcastChanges(changes);
              changes.length = 0;
            };

            return context;
          } // Wrap the provider so we can extend the context with fs flags and
          // an array of changes (e.g., watch event 'change' and 'rename' events
          // for paths updated during the lifetime of the context). From this
          // point forward we won't call open again, so it's safe to drop it.


          fs.provider = {
            openReadWriteContext: function openReadWriteContext() {
              return wrappedContext('getReadWriteContext');
            },
            openReadOnlyContext: function openReadOnlyContext() {
              return wrappedContext('getReadOnlyContext');
            }
          };

          if (error) {
            fs.readyState = FS_ERROR;
          } else {
            fs.readyState = FS_READY;
          }

          runQueued();
          callback(error, fs);
        }

        if (err) {
          return complete(err);
        }

        var context = provider.getReadWriteContext();
        context.guid = wrappedGuidFn(context); // Mount the filesystem, formatting if necessary

        if (forceFormatting) {
          // Wipe the storage provider, then write root block
          context.clear(function (err) {
            if (err) {
              return complete(err);
            }

            impl.ensureRootDirectory(context, complete);
          });
        } else {
          // Use existing (or create new) root and mount
          impl.ensureRootDirectory(context, complete);
        }
      });
      FileSystem.prototype.promises = {};
      /**
       * Public API for FileSystem. All node.js methods that are exposed on fs.promises
       * include `promise: true`.  We also include our own extra methods, but skip the
       * fd versions to match node.js, which puts these on a `FileHandle` object.
       * Any method that deals with path argument(s) also includes the position of
       * those args in one of `absPathArgs: [...]` or `relPathArgs: [...]`, so they
       * can be processed and validated before being passed on to the method.
       */

      [{
        name: 'appendFile',
        promises: true,
        absPathArgs: [0]
      }, {
        name: 'access',
        promises: true,
        absPathArgs: [0]
      }, {
        name: 'chown',
        promises: true,
        absPathArgs: [0]
      }, {
        name: 'chmod',
        promises: true,
        absPathArgs: [0]
      }, {
        name: 'close'
      }, // copyFile - https://github.com/filerjs/filer/issues/436
      {
        name: 'exists',
        absPathArgs: [0]
      }, {
        name: 'fchown'
      }, {
        name: 'fchmod'
      }, // fdatasync - https://github.com/filerjs/filer/issues/653
      {
        name: 'fgetxattr'
      }, {
        name: 'fremovexattr'
      }, {
        name: 'fsetxattr'
      }, {
        name: 'fstat'
      }, {
        name: 'fsync'
      }, {
        name: 'ftruncate'
      }, {
        name: 'futimes'
      }, {
        name: 'getxattr',
        promises: true,
        absPathArgs: [0]
      }, // lchown - https://github.com/filerjs/filer/issues/620
      // lchmod - https://github.com/filerjs/filer/issues/619
      {
        name: 'link',
        promises: true,
        absPathArgs: [0, 1]
      }, {
        name: 'lseek'
      }, {
        name: 'lstat',
        promises: true
      }, {
        name: 'mkdir',
        promises: true,
        absPathArgs: [0]
      }, {
        name: 'mkdtemp',
        promises: true
      }, {
        name: 'mknod',
        promises: true,
        absPathArgs: [0]
      }, {
        name: 'open',
        promises: true,
        absPathArgs: [0]
      }, {
        name: 'readdir',
        promises: true,
        absPathArgs: [0]
      }, {
        name: 'read'
      }, {
        name: 'readFile',
        promises: true,
        absPathArgs: [0]
      }, {
        name: 'readlink',
        promises: true,
        absPathArgs: [0]
      }, // realpath - https://github.com/filerjs/filer/issues/85
      {
        name: 'removexattr',
        promises: true,
        absPathArgs: [0]
      }, {
        name: 'rename',
        promises: true,
        absPathArgs: [0, 1]
      }, {
        name: 'rmdir',
        promises: true,
        absPathArgs: [0]
      }, {
        name: 'setxattr',
        promises: true,
        absPathArgs: [0]
      }, {
        name: 'stat',
        promises: true,
        absPathArgs: [0]
      }, {
        name: 'symlink',
        promises: true,
        relPathArgs: [0],
        absPathArgs: [1]
      }, {
        name: 'truncate',
        promises: true,
        absPathArgs: [0]
      }, // unwatchFile - https://github.com/filerjs/filer/pull/553
      {
        name: 'unlink',
        promises: true,
        absPathArgs: [0]
      }, {
        name: 'utimes',
        promises: true,
        absPathArgs: [0]
      }, // watch - implemented above in `this.watch`
      // watchFile - https://github.com/filerjs/filer/issues/654
      {
        name: 'writeFile',
        promises: true,
        absPathArgs: [0]
      }, {
        name: 'write'
      }].forEach(function (method) {
        var methodName = method.name;
        var shouldPromisify = method.promises === true;

        FileSystem.prototype[methodName] = function () {
          var fs = this;
          var args = Array.prototype.slice.call(arguments, 0);
          var lastArgIndex = args.length - 1; // We may or may not get a callback, and since node.js supports
          // fire-and-forget style fs operations, we have to dance a bit here.

          var missingCallback = typeof args[lastArgIndex] !== 'function';
          var callback = maybeCallback(args[lastArgIndex]); // Deal with path arguments, validating and normalizing Buffer and file:// URLs

          if (method.absPathArgs) {
            method.absPathArgs.forEach(function (pathArg) {
              return processPathArg(args, pathArg, false);
            });
          }

          if (method.relPathArgs) {
            method.relPathArgs.forEach(function (pathArg) {
              return processPathArg(args, pathArg, true);
            });
          }

          var error = fs.queueOrRun(function () {
            var context = fs.provider.openReadWriteContext(); // Fail early if the filesystem is in an error state (e.g.,
            // provider failed to open.

            if (FS_ERROR === fs.readyState) {
              var err = new Errors.EFILESYSTEMERROR('filesystem unavailable, operation canceled');
              return callback.call(fs, err);
            } // Wrap the callback so we can explicitly close the context


            function complete() {
              context.close();
              callback.apply(fs, arguments);
            } // Either add or replace the callback with our wrapper complete()


            if (missingCallback) {
              args.push(complete);
            } else {
              args[lastArgIndex] = complete;
            } // Forward this call to the impl's version, using the following
            // call signature, with complete() as the callback/last-arg now:
            // fn(fs, context, arg0, arg1, ... , complete);


            var fnArgs = [context].concat(args);
            impl[methodName].apply(null, fnArgs);
          });

          if (error) {
            callback(error);
          }
        }; // Add to fs.promises if appropriate


        if (shouldPromisify) {
          FileSystem.prototype.promises[methodName] = promisify(FileSystem.prototype[methodName].bind(fs));
        }
      });
    } // Expose storage providers on FileSystem constructor


    FileSystem.providers = providers;
    module.exports = FileSystem;
  }, { "es6-promisify": "b1ZG", "../path.js": "UzoP", "../providers/index.js": "AiW7", "../shell/shell.js": "D1Ra", "../../lib/intercom.js": "u7Jv", "../fs-watcher.js": "VLEe", "../errors.js": "p8GN", "../shared.js": "zBMa", "../constants.js": "iJA9", "./implementation.js": "bsBG", "buffer": "dskh" }], "iIhC": [function (require, module, exports) {
    "use strict";

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    /** @typedef {import("ajv").Ajv} Ajv */

    /** @typedef {import("ajv").ValidateFunction} ValidateFunction */

    /** @typedef {import("../validate").SchemaUtilErrorObject} SchemaUtilErrorObject */

    /**
     * @param {string} message
     * @param {object} schema
     * @param {string} data
     * @returns {SchemaUtilErrorObject}
     */

    function errorMessage(message, schema, data) {
      return {
        // @ts-ignore
        // eslint-disable-next-line no-undefined
        dataPath: undefined,
        // @ts-ignore
        // eslint-disable-next-line no-undefined
        schemaPath: undefined,
        keyword: "absolutePath",
        params: {
          absolutePath: data
        },
        message: message,
        parentSchema: schema
      };
    }
    /**
     * @param {boolean} shouldBeAbsolute
     * @param {object} schema
     * @param {string} data
     * @returns {SchemaUtilErrorObject}
     */


    function getErrorFor(shouldBeAbsolute, schema, data) {
      var message = shouldBeAbsolute ? "The provided value ".concat(JSON.stringify(data), " is not an absolute path!") : "A relative path is expected. However, the provided value ".concat(JSON.stringify(data), " is an absolute path!");
      return errorMessage(message, schema, data);
    }
    /**
     *
     * @param {Ajv} ajv
     * @returns {Ajv}
     */


    function addAbsolutePathKeyword(ajv) {
      ajv.addKeyword("absolutePath", {
        errors: true,
        type: "string",
        compile: function compile(schema, parentSchema) {
          /** @type {ValidateFunction} */
          var callback = function callback(data) {
            var passes = true;
            var isExclamationMarkPresent = data.includes("!");

            if (isExclamationMarkPresent) {
              callback.errors = [errorMessage("The provided value ".concat(JSON.stringify(data), " contains exclamation mark (!) which is not allowed because it's reserved for loader syntax."), parentSchema, data)];
              passes = false;
            } // ?:[A-Za-z]:\\ - Windows absolute path
            // \\\\ - Windows network absolute path
            // \/ - Unix-like OS absolute path


            var isCorrectAbsolutePath = schema === /^(?:[A-Za-z]:(\\|\/)|\\\\|\/)/.test(data);

            if (!isCorrectAbsolutePath) {
              callback.errors = [getErrorFor(schema, parentSchema, data)];
              passes = false;
            }

            return passes;
          };

          callback.errors = [];
          return callback;
        }
      });
      return ajv;
    }

    var _default = addAbsolutePathKeyword;
    exports.default = _default;
  }, {}], "GNtl": [function (require, module, exports) {
    "use strict";
    /**
     * @typedef {[number, boolean]} RangeValue
     */

    /**
     * @callback RangeValueCallback
     * @param {RangeValue} rangeValue
     * @returns {boolean}
     */

    function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

    function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

    function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

    function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

    function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

    function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    var Range = /*#__PURE__*/function () {
      function Range() {
        _classCallCheck(this, Range);

        /** @type {Array<RangeValue>} */
        this._left = [];
        /** @type {Array<RangeValue>} */

        this._right = [];
      }
      /**
       * @param {number} value
       * @param {boolean=} exclusive
       */


      _createClass(Range, [{
        key: "left",
        value: function left(value) {
          var exclusive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          this._left.push([value, exclusive]);
        }
        /**
         * @param {number} value
         * @param {boolean=} exclusive
         */

      }, {
        key: "right",
        value: function right(value) {
          var exclusive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          this._right.push([value, exclusive]);
        }
        /**
         * @param {boolean} logic is not logic applied
         * @return {string} "smart" range string representation
         */

      }, {
        key: "format",
        value: function format() {
          var logic = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

          var _Range$getRangeValue = Range.getRangeValue(this._left, logic),
            _Range$getRangeValue2 = _slicedToArray(_Range$getRangeValue, 2),
            start = _Range$getRangeValue2[0],
            leftExclusive = _Range$getRangeValue2[1];

          var _Range$getRangeValue3 = Range.getRangeValue(this._right, !logic),
            _Range$getRangeValue4 = _slicedToArray(_Range$getRangeValue3, 2),
            end = _Range$getRangeValue4[0],
            rightExclusive = _Range$getRangeValue4[1];

          if (!Number.isFinite(start) && !Number.isFinite(end)) {
            return "";
          }

          var realStart = leftExclusive ? start + 1 : start;
          var realEnd = rightExclusive ? end - 1 : end; // e.g. 5 < x < 7, 5 < x <= 6, 6 <= x <= 6

          if (realStart === realEnd) {
            return "should be ".concat(logic ? "" : "!", "= ").concat(realStart);
          } // e.g. 4 < x < ∞


          if (Number.isFinite(start) && !Number.isFinite(end)) {
            return Range.formatLeft(start, logic, leftExclusive);
          } // e.g. ∞ < x < 4


          if (!Number.isFinite(start) && Number.isFinite(end)) {
            return Range.formatRight(end, logic, rightExclusive);
          }

          return Range.formatRange(start, end, leftExclusive, rightExclusive, logic);
        }
      }], [{
        key: "getOperator",
        value:
          /**
           * @param {"left" | "right"} side
           * @param {boolean} exclusive
           * @returns {">" | ">=" | "<" | "<="}
           */
          function getOperator(side, exclusive) {
            if (side === "left") {
              return exclusive ? ">" : ">=";
            }

            return exclusive ? "<" : "<=";
          }
        /**
         * @param {number} value
         * @param {boolean} logic is not logic applied
         * @param {boolean} exclusive is range exclusive
         * @returns {string}
         */

      }, {
        key: "formatRight",
        value: function formatRight(value, logic, exclusive) {
          if (logic === false) {
            return Range.formatLeft(value, !logic, !exclusive);
          }

          return "should be ".concat(Range.getOperator("right", exclusive), " ").concat(value);
        }
        /**
         * @param {number} value
         * @param {boolean} logic is not logic applied
         * @param {boolean} exclusive is range exclusive
         * @returns {string}
         */

      }, {
        key: "formatLeft",
        value: function formatLeft(value, logic, exclusive) {
          if (logic === false) {
            return Range.formatRight(value, !logic, !exclusive);
          }

          return "should be ".concat(Range.getOperator("left", exclusive), " ").concat(value);
        }
        /**
         * @param {number} start left side value
         * @param {number} end right side value
         * @param {boolean} startExclusive is range exclusive from left side
         * @param {boolean} endExclusive is range exclusive from right side
         * @param {boolean} logic is not logic applied
         * @returns {string}
         */

      }, {
        key: "formatRange",
        value: function formatRange(start, end, startExclusive, endExclusive, logic) {
          var result = "should be";
          result += " ".concat(Range.getOperator(logic ? "left" : "right", logic ? startExclusive : !startExclusive), " ").concat(start, " ");
          result += logic ? "and" : "or";
          result += " ".concat(Range.getOperator(logic ? "right" : "left", logic ? endExclusive : !endExclusive), " ").concat(end);
          return result;
        }
        /**
         * @param {Array<RangeValue>} values
         * @param {boolean} logic is not logic applied
         * @return {RangeValue} computed value and it's exclusive flag
         */

      }, {
        key: "getRangeValue",
        value: function getRangeValue(values, logic) {
          var minMax = logic ? Infinity : -Infinity;
          var j = -1;
          var predicate = logic ?
            /** @type {RangeValueCallback} */
            function (_ref) {
              var _ref2 = _slicedToArray(_ref, 1),
                value = _ref2[0];

              return value <= minMax;
            } :
            /** @type {RangeValueCallback} */
            function (_ref3) {
              var _ref4 = _slicedToArray(_ref3, 1),
                value = _ref4[0];

              return value >= minMax;
            };

          for (var i = 0; i < values.length; i++) {
            if (predicate(values[i])) {
              var _values$i = _slicedToArray(values[i], 1);

              minMax = _values$i[0];
              j = i;
            }
          }

          if (j > -1) {
            return values[j];
          }

          return [Infinity, true];
        }
      }]);

      return Range;
    }();

    module.exports = Range;
  }, {}], "SqDh": [function (require, module, exports) {
    "use strict";

    function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

    function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

    function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

    var Range = require("./Range");
    /** @typedef {import("../validate").Schema} Schema */

    /**
     * @param {Schema} schema
     * @param {boolean} logic
     * @return {string[]}
     */


    module.exports.stringHints = function stringHints(schema, logic) {
      var hints = [];
      var type = "string";

      var currentSchema = _objectSpread({}, schema);

      if (!logic) {
        var tmpLength = currentSchema.minLength;
        var tmpFormat = currentSchema.formatMinimum;
        var tmpExclusive = currentSchema.formatExclusiveMaximum;
        currentSchema.minLength = currentSchema.maxLength;
        currentSchema.maxLength = tmpLength;
        currentSchema.formatMinimum = currentSchema.formatMaximum;
        currentSchema.formatMaximum = tmpFormat;
        currentSchema.formatExclusiveMaximum = !currentSchema.formatExclusiveMinimum;
        currentSchema.formatExclusiveMinimum = !tmpExclusive;
      }

      if (typeof currentSchema.minLength === "number") {
        if (currentSchema.minLength === 1) {
          type = "non-empty string";
        } else {
          var length = Math.max(currentSchema.minLength - 1, 0);
          hints.push("should be longer than ".concat(length, " character").concat(length > 1 ? "s" : ""));
        }
      }

      if (typeof currentSchema.maxLength === "number") {
        if (currentSchema.maxLength === 0) {
          type = "empty string";
        } else {
          var _length = currentSchema.maxLength + 1;

          hints.push("should be shorter than ".concat(_length, " character").concat(_length > 1 ? "s" : ""));
        }
      }

      if (currentSchema.pattern) {
        hints.push("should".concat(logic ? "" : " not", " match pattern ").concat(JSON.stringify(currentSchema.pattern)));
      }

      if (currentSchema.format) {
        hints.push("should".concat(logic ? "" : " not", " match format ").concat(JSON.stringify(currentSchema.format)));
      }

      if (currentSchema.formatMinimum) {
        hints.push("should be ".concat(currentSchema.formatExclusiveMinimum ? ">" : ">=", " ").concat(JSON.stringify(currentSchema.formatMinimum)));
      }

      if (currentSchema.formatMaximum) {
        hints.push("should be ".concat(currentSchema.formatExclusiveMaximum ? "<" : "<=", " ").concat(JSON.stringify(currentSchema.formatMaximum)));
      }

      return [type].concat(hints);
    };
    /**
     * @param {Schema} schema
     * @param {boolean} logic
     * @return {string[]}
     */


    module.exports.numberHints = function numberHints(schema, logic) {
      var hints = [schema.type === "integer" ? "integer" : "number"];
      var range = new Range();

      if (typeof schema.minimum === "number") {
        range.left(schema.minimum);
      }

      if (typeof schema.exclusiveMinimum === "number") {
        range.left(schema.exclusiveMinimum, true);
      }

      if (typeof schema.maximum === "number") {
        range.right(schema.maximum);
      }

      if (typeof schema.exclusiveMaximum === "number") {
        range.right(schema.exclusiveMaximum, true);
      }

      var rangeFormat = range.format(logic);

      if (rangeFormat) {
        hints.push(rangeFormat);
      }

      if (typeof schema.multipleOf === "number") {
        hints.push("should".concat(logic ? "" : " not", " be multiple of ").concat(schema.multipleOf));
      }

      return hints;
    };
  }, { "./Range": "GNtl" }], "ySUA": [function (require, module, exports) {
    "use strict";

    function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

    function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

    function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

    function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }

    function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

    function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

    function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

    function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

    function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

    function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

    function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

    function _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

    function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

    function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

    function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

    function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

    function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () { })); return true; } catch (e) { return false; } }

    function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

    function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

    function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

    function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _require = require("./util/hints"),
      stringHints = _require.stringHints,
      numberHints = _require.numberHints;
    /** @typedef {import("json-schema").JSONSchema6} JSONSchema6 */

    /** @typedef {import("json-schema").JSONSchema7} JSONSchema7 */

    /** @typedef {import("./validate").Schema} Schema */

    /** @typedef {import("./validate").ValidationErrorConfiguration} ValidationErrorConfiguration */

    /** @typedef {import("./validate").PostFormatter} PostFormatter */

    /** @typedef {import("./validate").SchemaUtilErrorObject} SchemaUtilErrorObject */

    /** @enum {number} */


    var SPECIFICITY = {
      type: 1,
      not: 1,
      oneOf: 1,
      anyOf: 1,
      if: 1,
      enum: 1,
      const: 1,
      instanceof: 1,
      required: 2,
      pattern: 2,
      patternRequired: 2,
      format: 2,
      formatMinimum: 2,
      formatMaximum: 2,
      minimum: 2,
      exclusiveMinimum: 2,
      maximum: 2,
      exclusiveMaximum: 2,
      multipleOf: 2,
      uniqueItems: 2,
      contains: 2,
      minLength: 2,
      maxLength: 2,
      minItems: 2,
      maxItems: 2,
      minProperties: 2,
      maxProperties: 2,
      dependencies: 2,
      propertyNames: 2,
      additionalItems: 2,
      additionalProperties: 2,
      absolutePath: 2
    };
    /**
     *
     * @param {Array<SchemaUtilErrorObject>} array
     * @param {(item: SchemaUtilErrorObject) => number} fn
     * @returns {Array<SchemaUtilErrorObject>}
     */

    function filterMax(array, fn) {
      var evaluatedMax = array.reduce(function (max, item) {
        return Math.max(max, fn(item));
      }, 0);
      return array.filter(function (item) {
        return fn(item) === evaluatedMax;
      });
    }
    /**
     *
     * @param {Array<SchemaUtilErrorObject>} children
     * @returns {Array<SchemaUtilErrorObject>}
     */


    function filterChildren(children) {
      var newChildren = children;
      newChildren = filterMax(newChildren,
        /**
         *
         * @param {SchemaUtilErrorObject} error
         * @returns {number}
         */
        function (error) {
          return error.dataPath ? error.dataPath.length : 0;
        });
      newChildren = filterMax(newChildren,
        /**
         * @param {SchemaUtilErrorObject} error
         * @returns {number}
         */
        function (error) {
          return SPECIFICITY[
            /** @type {keyof typeof SPECIFICITY} */
            error.keyword] || 2;
        });
      return newChildren;
    }
    /**
     * Find all children errors
     * @param {Array<SchemaUtilErrorObject>} children
     * @param {Array<string>} schemaPaths
     * @return {number} returns index of first child
     */


    function findAllChildren(children, schemaPaths) {
      var i = children.length - 1;

      var predicate =
        /**
         * @param {string} schemaPath
         * @returns {boolean}
         */
        function predicate(schemaPath) {
          return children[i].schemaPath.indexOf(schemaPath) !== 0;
        };

      while (i > -1 && !schemaPaths.every(predicate)) {
        if (children[i].keyword === "anyOf" || children[i].keyword === "oneOf") {
          var refs = extractRefs(children[i]);
          var childrenStart = findAllChildren(children.slice(0, i), refs.concat(children[i].schemaPath));
          i = childrenStart - 1;
        } else {
          i -= 1;
        }
      }

      return i + 1;
    }
    /**
     * Extracts all refs from schema
     * @param {SchemaUtilErrorObject} error
     * @return {Array<string>}
     */


    function extractRefs(error) {
      var schema = error.schema;

      if (!Array.isArray(schema)) {
        return [];
      }

      return schema.map(function (_ref) {
        var $ref = _ref.$ref;
        return $ref;
      }).filter(function (s) {
        return s;
      });
    }
    /**
     * Groups children by their first level parent (assuming that error is root)
     * @param {Array<SchemaUtilErrorObject>} children
     * @return {Array<SchemaUtilErrorObject>}
     */


    function groupChildrenByFirstChild(children) {
      var result = [];
      var i = children.length - 1;

      while (i > 0) {
        var child = children[i];

        if (child.keyword === "anyOf" || child.keyword === "oneOf") {
          var refs = extractRefs(child);
          var childrenStart = findAllChildren(children.slice(0, i), refs.concat(child.schemaPath));

          if (childrenStart !== i) {
            result.push(Object.assign({}, child, {
              children: children.slice(childrenStart, i)
            }));
            i = childrenStart;
          } else {
            result.push(child);
          }
        } else {
          result.push(child);
        }

        i -= 1;
      }

      if (i === 0) {
        result.push(children[i]);
      }

      return result.reverse();
    }
    /**
     * @param {string} str
     * @param {string} prefix
     * @returns {string}
     */


    function indent(str, prefix) {
      return str.replace(/\n(?!$)/g, "\n".concat(prefix));
    }
    /**
     * @param {Schema} schema
     * @returns {schema is (Schema & {not: Schema})}
     */


    function hasNotInSchema(schema) {
      return !!schema.not;
    }
    /**
     * @param {Schema} schema
     * @return {Schema}
     */


    function findFirstTypedSchema(schema) {
      if (hasNotInSchema(schema)) {
        return findFirstTypedSchema(schema.not);
      }

      return schema;
    }
    /**
     * @param {Schema} schema
     * @return {boolean}
     */


    function canApplyNot(schema) {
      var typedSchema = findFirstTypedSchema(schema);
      return likeNumber(typedSchema) || likeInteger(typedSchema) || likeString(typedSchema) || likeNull(typedSchema) || likeBoolean(typedSchema);
    }
    /**
     * @param {any} maybeObj
     * @returns {boolean}
     */


    function isObject(maybeObj) {
      return _typeof(maybeObj) === "object" && maybeObj !== null;
    }
    /**
     * @param {Schema} schema
     * @returns {boolean}
     */


    function likeNumber(schema) {
      return schema.type === "number" || typeof schema.minimum !== "undefined" || typeof schema.exclusiveMinimum !== "undefined" || typeof schema.maximum !== "undefined" || typeof schema.exclusiveMaximum !== "undefined" || typeof schema.multipleOf !== "undefined";
    }
    /**
     * @param {Schema} schema
     * @returns {boolean}
     */


    function likeInteger(schema) {
      return schema.type === "integer" || typeof schema.minimum !== "undefined" || typeof schema.exclusiveMinimum !== "undefined" || typeof schema.maximum !== "undefined" || typeof schema.exclusiveMaximum !== "undefined" || typeof schema.multipleOf !== "undefined";
    }
    /**
     * @param {Schema} schema
     * @returns {boolean}
     */


    function likeString(schema) {
      return schema.type === "string" || typeof schema.minLength !== "undefined" || typeof schema.maxLength !== "undefined" || typeof schema.pattern !== "undefined" || typeof schema.format !== "undefined" || typeof schema.formatMinimum !== "undefined" || typeof schema.formatMaximum !== "undefined";
    }
    /**
     * @param {Schema} schema
     * @returns {boolean}
     */


    function likeBoolean(schema) {
      return schema.type === "boolean";
    }
    /**
     * @param {Schema} schema
     * @returns {boolean}
     */


    function likeArray(schema) {
      return schema.type === "array" || typeof schema.minItems === "number" || typeof schema.maxItems === "number" || typeof schema.uniqueItems !== "undefined" || typeof schema.items !== "undefined" || typeof schema.additionalItems !== "undefined" || typeof schema.contains !== "undefined";
    }
    /**
     * @param {Schema & {patternRequired?: Array<string>}} schema
     * @returns {boolean}
     */


    function likeObject(schema) {
      return schema.type === "object" || typeof schema.minProperties !== "undefined" || typeof schema.maxProperties !== "undefined" || typeof schema.required !== "undefined" || typeof schema.properties !== "undefined" || typeof schema.patternProperties !== "undefined" || typeof schema.additionalProperties !== "undefined" || typeof schema.dependencies !== "undefined" || typeof schema.propertyNames !== "undefined" || typeof schema.patternRequired !== "undefined";
    }
    /**
     * @param {Schema} schema
     * @returns {boolean}
     */


    function likeNull(schema) {
      return schema.type === "null";
    }
    /**
     * @param {string} type
     * @returns {string}
     */


    function getArticle(type) {
      if (/^[aeiou]/i.test(type)) {
        return "an";
      }

      return "a";
    }
    /**
     * @param {Schema=} schema
     * @returns {string}
     */


    function getSchemaNonTypes(schema) {
      if (!schema) {
        return "";
      }

      if (!schema.type) {
        if (likeNumber(schema) || likeInteger(schema)) {
          return " | should be any non-number";
        }

        if (likeString(schema)) {
          return " | should be any non-string";
        }

        if (likeArray(schema)) {
          return " | should be any non-array";
        }

        if (likeObject(schema)) {
          return " | should be any non-object";
        }
      }

      return "";
    }
    /**
     * @param {Array<string>} hints
     * @returns {string}
     */


    function formatHints(hints) {
      return hints.length > 0 ? "(".concat(hints.join(", "), ")") : "";
    }
    /**
     * @param {Schema} schema
     * @param {boolean} logic
     * @returns {string[]}
     */


    function getHints(schema, logic) {
      if (likeNumber(schema) || likeInteger(schema)) {
        return numberHints(schema, logic);
      } else if (likeString(schema)) {
        return stringHints(schema, logic);
      }

      return [];
    }

    var ValidationError = /*#__PURE__*/function (_Error) {
      _inherits(ValidationError, _Error);

      var _super = _createSuper(ValidationError);

      /**
       * @param {Array<SchemaUtilErrorObject>} errors
       * @param {Schema} schema
       * @param {ValidationErrorConfiguration} configuration
       */
      function ValidationError(errors, schema) {
        var _this;

        var configuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        _classCallCheck(this, ValidationError);

        _this = _super.call(this);
        /** @type {string} */

        _this.name = "ValidationError";
        /** @type {Array<SchemaUtilErrorObject>} */

        _this.errors = errors;
        /** @type {Schema} */

        _this.schema = schema;
        var headerNameFromSchema;
        var baseDataPathFromSchema;

        if (schema.title && (!configuration.name || !configuration.baseDataPath)) {
          var splittedTitleFromSchema = schema.title.match(/^(.+) (.+)$/);

          if (splittedTitleFromSchema) {
            if (!configuration.name) {
              var _splittedTitleFromSch = _slicedToArray(splittedTitleFromSchema, 2);

              headerNameFromSchema = _splittedTitleFromSch[1];
            }

            if (!configuration.baseDataPath) {
              var _splittedTitleFromSch2 = _slicedToArray(splittedTitleFromSchema, 3);

              baseDataPathFromSchema = _splittedTitleFromSch2[2];
            }
          }
        }
        /** @type {string} */


        _this.headerName = configuration.name || headerNameFromSchema || "Object";
        /** @type {string} */

        _this.baseDataPath = configuration.baseDataPath || baseDataPathFromSchema || "configuration";
        /** @type {PostFormatter | null} */

        _this.postFormatter = configuration.postFormatter || null;
        var header = "Invalid ".concat(_this.baseDataPath, " object. ").concat(_this.headerName, " has been initialized using ").concat(getArticle(_this.baseDataPath), " ").concat(_this.baseDataPath, " object that does not match the API schema.\n");
        /** @type {string} */

        _this.message = "".concat(header).concat(_this.formatValidationErrors(errors));
        Error.captureStackTrace(_assertThisInitialized(_this), _this.constructor);
        return _this;
      }
      /**
       * @param {string} path
       * @returns {Schema}
       */


      _createClass(ValidationError, [{
        key: "getSchemaPart",
        value: function getSchemaPart(path) {
          var newPath = path.split("/");
          var schemaPart = this.schema;

          for (var i = 1; i < newPath.length; i++) {
            var inner = schemaPart[
              /** @type {keyof Schema} */
              newPath[i]];

            if (!inner) {
              break;
            }

            schemaPart = inner;
          }

          return schemaPart;
        }
        /**
         * @param {Schema} schema
         * @param {boolean} logic
         * @param {Array<Object>} prevSchemas
         * @returns {string}
         */

      }, {
        key: "formatSchema",
        value: function formatSchema(schema) {
          var _this2 = this;

          var logic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          var prevSchemas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
          var newLogic = logic;

          var formatInnerSchema =
            /**
             *
             * @param {Object} innerSchema
             * @param {boolean=} addSelf
             * @returns {string}
             */
            function formatInnerSchema(innerSchema, addSelf) {
              if (!addSelf) {
                return _this2.formatSchema(innerSchema, newLogic, prevSchemas);
              }

              if (prevSchemas.includes(innerSchema)) {
                return "(recursive)";
              }

              return _this2.formatSchema(innerSchema, newLogic, prevSchemas.concat(schema));
            };

          if (hasNotInSchema(schema) && !likeObject(schema)) {
            if (canApplyNot(schema.not)) {
              newLogic = !logic;
              return formatInnerSchema(schema.not);
            }

            var needApplyLogicHere = !schema.not.not;
            var prefix = logic ? "" : "non ";
            newLogic = !logic;
            return needApplyLogicHere ? prefix + formatInnerSchema(schema.not) : formatInnerSchema(schema.not);
          }

          if (
            /** @type {Schema & {instanceof: string | Array<string>}} */
            schema.instanceof) {
            var value =
              /** @type {Schema & {instanceof: string | Array<string>}} */
              schema.instanceof;
            var values = !Array.isArray(value) ? [value] : value;
            return values.map(
              /**
               * @param {string} item
               * @returns {string}
               */
              function (item) {
                return item === "Function" ? "function" : item;
              }).join(" | ");
          }

          if (schema.enum) {
            return (
              /** @type {Array<any>} */
              schema.enum.map(function (item) {
                return JSON.stringify(item);
              }).join(" | ")
            );
          }

          if (typeof schema.const !== "undefined") {
            return JSON.stringify(schema.const);
          }

          if (schema.oneOf) {
            return (
              /** @type {Array<Schema>} */
              schema.oneOf.map(function (item) {
                return formatInnerSchema(item, true);
              }).join(" | ")
            );
          }

          if (schema.anyOf) {
            return (
              /** @type {Array<Schema>} */
              schema.anyOf.map(function (item) {
                return formatInnerSchema(item, true);
              }).join(" | ")
            );
          }

          if (schema.allOf) {
            return (
              /** @type {Array<Schema>} */
              schema.allOf.map(function (item) {
                return formatInnerSchema(item, true);
              }).join(" & ")
            );
          }

          if (
            /** @type {JSONSchema7} */
            schema.if) {
            var ifValue =
              /** @type {JSONSchema7} */
              schema.if,
              thenValue = schema.then,
              elseValue = schema.else;
            return "".concat(ifValue ? "if ".concat(formatInnerSchema(ifValue)) : "").concat(thenValue ? " then ".concat(formatInnerSchema(thenValue)) : "").concat(elseValue ? " else ".concat(formatInnerSchema(elseValue)) : "");
          }

          if (schema.$ref) {
            return formatInnerSchema(this.getSchemaPart(schema.$ref), true);
          }

          if (likeNumber(schema) || likeInteger(schema)) {
            var _getHints = getHints(schema, logic),
              _getHints2 = _toArray(_getHints),
              type = _getHints2[0],
              hints = _getHints2.slice(1);

            var str = "".concat(type).concat(hints.length > 0 ? " ".concat(formatHints(hints)) : "");
            return logic ? str : hints.length > 0 ? "non-".concat(type, " | ").concat(str) : "non-".concat(type);
          }

          if (likeString(schema)) {
            var _getHints3 = getHints(schema, logic),
              _getHints4 = _toArray(_getHints3),
              _type = _getHints4[0],
              _hints = _getHints4.slice(1);

            var _str = "".concat(_type).concat(_hints.length > 0 ? " ".concat(formatHints(_hints)) : "");

            return logic ? _str : _str === "string" ? "non-string" : "non-string | ".concat(_str);
          }

          if (likeBoolean(schema)) {
            return "".concat(logic ? "" : "non-", "boolean");
          }

          if (likeArray(schema)) {
            // not logic already applied in formatValidationError
            newLogic = true;
            var _hints2 = [];

            if (typeof schema.minItems === "number") {
              _hints2.push("should not have fewer than ".concat(schema.minItems, " item").concat(schema.minItems > 1 ? "s" : ""));
            }

            if (typeof schema.maxItems === "number") {
              _hints2.push("should not have more than ".concat(schema.maxItems, " item").concat(schema.maxItems > 1 ? "s" : ""));
            }

            if (schema.uniqueItems) {
              _hints2.push("should not have duplicate items");
            }

            var hasAdditionalItems = typeof schema.additionalItems === "undefined" || Boolean(schema.additionalItems);
            var items = "";

            if (schema.items) {
              if (Array.isArray(schema.items) && schema.items.length > 0) {
                items = "".concat(
                  /** @type {Array<Schema>} */
                  schema.items.map(function (item) {
                    return formatInnerSchema(item);
                  }).join(", "));

                if (hasAdditionalItems) {
                  if (schema.additionalItems && isObject(schema.additionalItems) && Object.keys(schema.additionalItems).length > 0) {
                    _hints2.push("additional items should be ".concat(formatInnerSchema(schema.additionalItems)));
                  }
                }
              } else if (schema.items && Object.keys(schema.items).length > 0) {
                // "additionalItems" is ignored
                items = "".concat(formatInnerSchema(schema.items));
              } else {
                // Fallback for empty `items` value
                items = "any";
              }
            } else {
              // "additionalItems" is ignored
              items = "any";
            }

            if (schema.contains && Object.keys(schema.contains).length > 0) {
              _hints2.push("should contains at least one ".concat(this.formatSchema(schema.contains), " item"));
            }

            return "[".concat(items).concat(hasAdditionalItems ? ", ..." : "", "]").concat(_hints2.length > 0 ? " (".concat(_hints2.join(", "), ")") : "");
          }

          if (likeObject(schema)) {
            // not logic already applied in formatValidationError
            newLogic = true;
            var _hints3 = [];

            if (typeof schema.minProperties === "number") {
              _hints3.push("should not have fewer than ".concat(schema.minProperties, " ").concat(schema.minProperties > 1 ? "properties" : "property"));
            }

            if (typeof schema.maxProperties === "number") {
              _hints3.push("should not have more than ".concat(schema.maxProperties, " ").concat(schema.minProperties && schema.minProperties > 1 ? "properties" : "property"));
            }

            if (schema.patternProperties && Object.keys(schema.patternProperties).length > 0) {
              var patternProperties = Object.keys(schema.patternProperties);

              _hints3.push("additional property names should match pattern".concat(patternProperties.length > 1 ? "s" : "", " ").concat(patternProperties.map(function (pattern) {
                return JSON.stringify(pattern);
              }).join(" | ")));
            }

            var properties = schema.properties ? Object.keys(schema.properties) : [];
            var required = schema.required ? schema.required : [];

            var allProperties = _toConsumableArray(new Set(
              /** @type {Array<string>} */
              [].concat(required).concat(properties)));

            var objectStructure = allProperties.map(function (property) {
              var isRequired = required.includes(property); // Some properties need quotes, maybe we should add check
              // Maybe we should output type of property (`foo: string`), but it is looks very unreadable

              return "".concat(property).concat(isRequired ? "" : "?");
            }).concat(typeof schema.additionalProperties === "undefined" || Boolean(schema.additionalProperties) ? schema.additionalProperties && isObject(schema.additionalProperties) ? ["<key>: ".concat(formatInnerSchema(schema.additionalProperties))] : ["…"] : []).join(", ");
            var dependencies =
              /** @type {Schema & {patternRequired?: Array<string>;}} */
              schema.dependencies,
              propertyNames = schema.propertyNames,
              patternRequired = schema.patternRequired;

            if (dependencies) {
              Object.keys(dependencies).forEach(function (dependencyName) {
                var dependency = dependencies[dependencyName];

                if (Array.isArray(dependency)) {
                  _hints3.push("should have ".concat(dependency.length > 1 ? "properties" : "property", " ").concat(dependency.map(function (dep) {
                    return "'".concat(dep, "'");
                  }).join(", "), " when property '").concat(dependencyName, "' is present"));
                } else {
                  _hints3.push("should be valid according to the schema ".concat(formatInnerSchema(dependency), " when property '").concat(dependencyName, "' is present"));
                }
              });
            }

            if (propertyNames && Object.keys(propertyNames).length > 0) {
              _hints3.push("each property name should match format ".concat(JSON.stringify(schema.propertyNames.format)));
            }

            if (patternRequired && patternRequired.length > 0) {
              _hints3.push("should have property matching pattern ".concat(patternRequired.map(
                /**
                 * @param {string} item
                 * @returns {string}
                 */
                function (item) {
                  return JSON.stringify(item);
                })));
            }

            return "object {".concat(objectStructure ? " ".concat(objectStructure, " ") : "", "}").concat(_hints3.length > 0 ? " (".concat(_hints3.join(", "), ")") : "");
          }

          if (likeNull(schema)) {
            return "".concat(logic ? "" : "non-", "null");
          }

          if (Array.isArray(schema.type)) {
            // not logic already applied in formatValidationError
            return "".concat(schema.type.join(" | "));
          } // Fallback for unknown keywords
          // not logic already applied in formatValidationError

          /* istanbul ignore next */


          return JSON.stringify(schema, null, 2);
        }
        /**
         * @param {Schema=} schemaPart
         * @param {(boolean | Array<string>)=} additionalPath
         * @param {boolean=} needDot
         * @param {boolean=} logic
         * @returns {string}
         */

      }, {
        key: "getSchemaPartText",
        value: function getSchemaPartText(schemaPart, additionalPath) {
          var needDot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var logic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

          if (!schemaPart) {
            return "";
          }

          if (Array.isArray(additionalPath)) {
            for (var i = 0; i < additionalPath.length; i++) {
              /** @type {Schema | undefined} */
              var inner = schemaPart[
                /** @type {keyof Schema} */
                additionalPath[i]];

              if (inner) {
                // eslint-disable-next-line no-param-reassign
                schemaPart = inner;
              } else {
                break;
              }
            }
          }

          while (schemaPart.$ref) {
            // eslint-disable-next-line no-param-reassign
            schemaPart = this.getSchemaPart(schemaPart.$ref);
          }

          var schemaText = "".concat(this.formatSchema(schemaPart, logic)).concat(needDot ? "." : "");

          if (schemaPart.description) {
            schemaText += "\n-> ".concat(schemaPart.description);
          }

          if (schemaPart.link) {
            schemaText += "\n-> Read more at ".concat(schemaPart.link);
          }

          return schemaText;
        }
        /**
         * @param {Schema=} schemaPart
         * @returns {string}
         */

      }, {
        key: "getSchemaPartDescription",
        value: function getSchemaPartDescription(schemaPart) {
          if (!schemaPart) {
            return "";
          }

          while (schemaPart.$ref) {
            // eslint-disable-next-line no-param-reassign
            schemaPart = this.getSchemaPart(schemaPart.$ref);
          }

          var schemaText = "";

          if (schemaPart.description) {
            schemaText += "\n-> ".concat(schemaPart.description);
          }

          if (schemaPart.link) {
            schemaText += "\n-> Read more at ".concat(schemaPart.link);
          }

          return schemaText;
        }
        /**
         * @param {SchemaUtilErrorObject} error
         * @returns {string}
         */

      }, {
        key: "formatValidationError",
        value: function formatValidationError(error) {
          var _this3 = this;

          var keyword = error.keyword,
            errorDataPath = error.dataPath;
          var dataPath = "".concat(this.baseDataPath).concat(errorDataPath);

          switch (keyword) {
            case "type":
              {
                var parentSchema = error.parentSchema,
                  params = error.params; // eslint-disable-next-line default-case

                switch (
                /** @type {import("ajv").TypeParams} */
                params.type) {
                  case "number":
                    return "".concat(dataPath, " should be a ").concat(this.getSchemaPartText(parentSchema, false, true));

                  case "integer":
                    return "".concat(dataPath, " should be an ").concat(this.getSchemaPartText(parentSchema, false, true));

                  case "string":
                    return "".concat(dataPath, " should be a ").concat(this.getSchemaPartText(parentSchema, false, true));

                  case "boolean":
                    return "".concat(dataPath, " should be a ").concat(this.getSchemaPartText(parentSchema, false, true));

                  case "array":
                    return "".concat(dataPath, " should be an array:\n").concat(this.getSchemaPartText(parentSchema));

                  case "object":
                    return "".concat(dataPath, " should be an object:\n").concat(this.getSchemaPartText(parentSchema));

                  case "null":
                    return "".concat(dataPath, " should be a ").concat(this.getSchemaPartText(parentSchema, false, true));

                  default:
                    return "".concat(dataPath, " should be:\n").concat(this.getSchemaPartText(parentSchema));
                }
              }

            case "instanceof":
              {
                var _parentSchema = error.parentSchema;
                return "".concat(dataPath, " should be an instance of ").concat(this.getSchemaPartText(_parentSchema, false, true));
              }

            case "pattern":
              {
                var _params = error.params,
                  _parentSchema2 = error.parentSchema;
                var pattern =
                  /** @type {import("ajv").PatternParams} */
                  _params.pattern;
                return "".concat(dataPath, " should match pattern ").concat(JSON.stringify(pattern)).concat(getSchemaNonTypes(_parentSchema2), ".").concat(this.getSchemaPartDescription(_parentSchema2));
              }

            case "format":
              {
                var _params2 = error.params,
                  _parentSchema3 = error.parentSchema;
                var format =
                  /** @type {import("ajv").FormatParams} */
                  _params2.format;
                return "".concat(dataPath, " should match format ").concat(JSON.stringify(format)).concat(getSchemaNonTypes(_parentSchema3), ".").concat(this.getSchemaPartDescription(_parentSchema3));
              }

            case "formatMinimum":
            case "formatMaximum":
              {
                var _params3 = error.params,
                  _parentSchema4 = error.parentSchema;
                var comparison =
                  /** @type {import("ajv").ComparisonParams} */
                  _params3.comparison,
                  limit = _params3.limit;
                return "".concat(dataPath, " should be ").concat(comparison, " ").concat(JSON.stringify(limit)).concat(getSchemaNonTypes(_parentSchema4), ".").concat(this.getSchemaPartDescription(_parentSchema4));
              }

            case "minimum":
            case "maximum":
            case "exclusiveMinimum":
            case "exclusiveMaximum":
              {
                var _parentSchema5 = error.parentSchema,
                  _params4 = error.params;
                var _comparison =
                  /** @type {import("ajv").ComparisonParams} */
                  _params4.comparison,
                  _limit = _params4.limit;

                var _getHints5 = getHints(
                  /** @type {Schema} */
                  _parentSchema5, true),
                  _getHints6 = _toArray(_getHints5),
                  hints = _getHints6.slice(1);

                if (hints.length === 0) {
                  hints.push("should be ".concat(_comparison, " ").concat(_limit));
                }

                return "".concat(dataPath, " ").concat(hints.join(" ")).concat(getSchemaNonTypes(_parentSchema5), ".").concat(this.getSchemaPartDescription(_parentSchema5));
              }

            case "multipleOf":
              {
                var _params5 = error.params,
                  _parentSchema6 = error.parentSchema;
                var multipleOf =
                  /** @type {import("ajv").MultipleOfParams} */
                  _params5.multipleOf;
                return "".concat(dataPath, " should be multiple of ").concat(multipleOf).concat(getSchemaNonTypes(_parentSchema6), ".").concat(this.getSchemaPartDescription(_parentSchema6));
              }

            case "patternRequired":
              {
                var _params6 = error.params,
                  _parentSchema7 = error.parentSchema;
                var missingPattern =
                  /** @type {import("ajv").PatternRequiredParams} */
                  _params6.missingPattern;
                return "".concat(dataPath, " should have property matching pattern ").concat(JSON.stringify(missingPattern)).concat(getSchemaNonTypes(_parentSchema7), ".").concat(this.getSchemaPartDescription(_parentSchema7));
              }

            case "minLength":
              {
                var _params7 = error.params,
                  _parentSchema8 = error.parentSchema;
                var _limit2 =
                  /** @type {import("ajv").LimitParams} */
                  _params7.limit;

                if (_limit2 === 1) {
                  return "".concat(dataPath, " should be a non-empty string").concat(getSchemaNonTypes(_parentSchema8), ".").concat(this.getSchemaPartDescription(_parentSchema8));
                }

                var length = _limit2 - 1;
                return "".concat(dataPath, " should be longer than ").concat(length, " character").concat(length > 1 ? "s" : "").concat(getSchemaNonTypes(_parentSchema8), ".").concat(this.getSchemaPartDescription(_parentSchema8));
              }

            case "minItems":
              {
                var _params8 = error.params,
                  _parentSchema9 = error.parentSchema;
                var _limit3 =
                  /** @type {import("ajv").LimitParams} */
                  _params8.limit;

                if (_limit3 === 1) {
                  return "".concat(dataPath, " should be a non-empty array").concat(getSchemaNonTypes(_parentSchema9), ".").concat(this.getSchemaPartDescription(_parentSchema9));
                }

                return "".concat(dataPath, " should not have fewer than ").concat(_limit3, " items").concat(getSchemaNonTypes(_parentSchema9), ".").concat(this.getSchemaPartDescription(_parentSchema9));
              }

            case "minProperties":
              {
                var _params9 = error.params,
                  _parentSchema10 = error.parentSchema;
                var _limit4 =
                  /** @type {import("ajv").LimitParams} */
                  _params9.limit;

                if (_limit4 === 1) {
                  return "".concat(dataPath, " should be a non-empty object").concat(getSchemaNonTypes(_parentSchema10), ".").concat(this.getSchemaPartDescription(_parentSchema10));
                }

                return "".concat(dataPath, " should not have fewer than ").concat(_limit4, " properties").concat(getSchemaNonTypes(_parentSchema10), ".").concat(this.getSchemaPartDescription(_parentSchema10));
              }

            case "maxLength":
              {
                var _params10 = error.params,
                  _parentSchema11 = error.parentSchema;
                var _limit5 =
                  /** @type {import("ajv").LimitParams} */
                  _params10.limit;
                var max = _limit5 + 1;
                return "".concat(dataPath, " should be shorter than ").concat(max, " character").concat(max > 1 ? "s" : "").concat(getSchemaNonTypes(_parentSchema11), ".").concat(this.getSchemaPartDescription(_parentSchema11));
              }

            case "maxItems":
              {
                var _params11 = error.params,
                  _parentSchema12 = error.parentSchema;
                var _limit6 =
                  /** @type {import("ajv").LimitParams} */
                  _params11.limit;
                return "".concat(dataPath, " should not have more than ").concat(_limit6, " items").concat(getSchemaNonTypes(_parentSchema12), ".").concat(this.getSchemaPartDescription(_parentSchema12));
              }

            case "maxProperties":
              {
                var _params12 = error.params,
                  _parentSchema13 = error.parentSchema;
                var _limit7 =
                  /** @type {import("ajv").LimitParams} */
                  _params12.limit;
                return "".concat(dataPath, " should not have more than ").concat(_limit7, " properties").concat(getSchemaNonTypes(_parentSchema13), ".").concat(this.getSchemaPartDescription(_parentSchema13));
              }

            case "uniqueItems":
              {
                var _params13 = error.params,
                  _parentSchema14 = error.parentSchema;
                var i =
                  /** @type {import("ajv").UniqueItemsParams} */
                  _params13.i;
                return "".concat(dataPath, " should not contain the item '").concat(error.data[i], "' twice").concat(getSchemaNonTypes(_parentSchema14), ".").concat(this.getSchemaPartDescription(_parentSchema14));
              }

            case "additionalItems":
              {
                var _params14 = error.params,
                  _parentSchema15 = error.parentSchema;
                var _limit8 =
                  /** @type {import("ajv").LimitParams} */
                  _params14.limit;
                return "".concat(dataPath, " should not have more than ").concat(_limit8, " items").concat(getSchemaNonTypes(_parentSchema15), ". These items are valid:\n").concat(this.getSchemaPartText(_parentSchema15));
              }

            case "contains":
              {
                var _parentSchema16 = error.parentSchema;
                return "".concat(dataPath, " should contains at least one ").concat(this.getSchemaPartText(_parentSchema16, ["contains"]), " item").concat(getSchemaNonTypes(_parentSchema16), ".");
              }

            case "required":
              {
                var _parentSchema17 = error.parentSchema,
                  _params15 = error.params;

                var missingProperty =
                  /** @type {import("ajv").DependenciesParams} */
                  _params15.missingProperty.replace(/^\./, "");

                var hasProperty = _parentSchema17 && Boolean(
                  /** @type {Schema} */
                  _parentSchema17.properties &&
                  /** @type {Schema} */
                  _parentSchema17.properties[missingProperty]);

                return "".concat(dataPath, " misses the property '").concat(missingProperty, "'").concat(getSchemaNonTypes(_parentSchema17), ".").concat(hasProperty ? " Should be:\n".concat(this.getSchemaPartText(_parentSchema17, ["properties", missingProperty])) : this.getSchemaPartDescription(_parentSchema17));
              }

            case "additionalProperties":
              {
                var _params16 = error.params,
                  _parentSchema18 = error.parentSchema;
                var additionalProperty =
                  /** @type {import("ajv").AdditionalPropertiesParams} */
                  _params16.additionalProperty;
                return "".concat(dataPath, " has an unknown property '").concat(additionalProperty, "'").concat(getSchemaNonTypes(_parentSchema18), ". These properties are valid:\n").concat(this.getSchemaPartText(_parentSchema18));
              }

            case "dependencies":
              {
                var _params17 = error.params,
                  _parentSchema19 = error.parentSchema;
                var property =
                  /** @type {import("ajv").DependenciesParams} */
                  _params17.property,
                  deps = _params17.deps;
                var dependencies = deps.split(",").map(
                  /**
                   * @param {string} dep
                   * @returns {string}
                   */
                  function (dep) {
                    return "'".concat(dep.trim(), "'");
                  }).join(", ");
                return "".concat(dataPath, " should have properties ").concat(dependencies, " when property '").concat(property, "' is present").concat(getSchemaNonTypes(_parentSchema19), ".").concat(this.getSchemaPartDescription(_parentSchema19));
              }

            case "propertyNames":
              {
                var _params18 = error.params,
                  _parentSchema20 = error.parentSchema,
                  schema = error.schema;
                var propertyName =
                  /** @type {import("ajv").PropertyNamesParams} */
                  _params18.propertyName;
                return "".concat(dataPath, " property name '").concat(propertyName, "' is invalid").concat(getSchemaNonTypes(_parentSchema20), ". Property names should be match format ").concat(JSON.stringify(schema.format), ".").concat(this.getSchemaPartDescription(_parentSchema20));
              }

            case "enum":
              {
                var _parentSchema21 = error.parentSchema;

                if (_parentSchema21 &&
                  /** @type {Schema} */
                  _parentSchema21.enum &&
                  /** @type {Schema} */
                  _parentSchema21.enum.length === 1) {
                  return "".concat(dataPath, " should be ").concat(this.getSchemaPartText(_parentSchema21, false, true));
                }

                return "".concat(dataPath, " should be one of these:\n").concat(this.getSchemaPartText(_parentSchema21));
              }

            case "const":
              {
                var _parentSchema22 = error.parentSchema;
                return "".concat(dataPath, " should be equal to constant ").concat(this.getSchemaPartText(_parentSchema22, false, true));
              }

            case "not":
              {
                var postfix = likeObject(
                  /** @type {Schema} */
                  error.parentSchema) ? "\n".concat(this.getSchemaPartText(error.parentSchema)) : "";
                var schemaOutput = this.getSchemaPartText(error.schema, false, false, false);

                if (canApplyNot(error.schema)) {
                  return "".concat(dataPath, " should be any ").concat(schemaOutput).concat(postfix, ".");
                }

                var _schema = error.schema,
                  _parentSchema23 = error.parentSchema;
                return "".concat(dataPath, " should not be ").concat(this.getSchemaPartText(_schema, false, true)).concat(_parentSchema23 && likeObject(_parentSchema23) ? "\n".concat(this.getSchemaPartText(_parentSchema23)) : "");
              }

            case "oneOf":
            case "anyOf":
              {
                var _parentSchema24 = error.parentSchema,
                  children = error.children;

                if (children && children.length > 0) {
                  if (error.schema.length === 1) {
                    var lastChild = children[children.length - 1];
                    var remainingChildren = children.slice(0, children.length - 1);
                    return this.formatValidationError(Object.assign({}, lastChild, {
                      children: remainingChildren,
                      parentSchema: Object.assign({}, _parentSchema24, lastChild.parentSchema)
                    }));
                  }

                  var filteredChildren = filterChildren(children);

                  if (filteredChildren.length === 1) {
                    return this.formatValidationError(filteredChildren[0]);
                  }

                  filteredChildren = groupChildrenByFirstChild(filteredChildren);
                  return "".concat(dataPath, " should be one of these:\n").concat(this.getSchemaPartText(_parentSchema24), "\nDetails:\n").concat(filteredChildren.map(
                    /**
                     * @param {SchemaUtilErrorObject} nestedError
                     * @returns {string}
                     */
                    function (nestedError) {
                      return " * ".concat(indent(_this3.formatValidationError(nestedError), "   "));
                    }).join("\n"));
                }

                return "".concat(dataPath, " should be one of these:\n").concat(this.getSchemaPartText(_parentSchema24));
              }

            case "if":
              {
                var _params19 = error.params,
                  _parentSchema25 = error.parentSchema;
                var failingKeyword =
                  /** @type {import("ajv").IfParams} */
                  _params19.failingKeyword;
                return "".concat(dataPath, " should match \"").concat(failingKeyword, "\" schema:\n").concat(this.getSchemaPartText(_parentSchema25, [failingKeyword]));
              }

            case "absolutePath":
              {
                var message = error.message,
                  _parentSchema26 = error.parentSchema;
                return "".concat(dataPath, ": ").concat(message).concat(this.getSchemaPartDescription(_parentSchema26));
              }

            /* istanbul ignore next */

            default:
              {
                var _message = error.message,
                  _parentSchema27 = error.parentSchema;
                var ErrorInJSON = JSON.stringify(error, null, 2); // For `custom`, `false schema`, `$ref` keywords
                // Fallback for unknown keywords

                return "".concat(dataPath, " ").concat(_message, " (").concat(ErrorInJSON, ").\n").concat(this.getSchemaPartText(_parentSchema27, false));
              }
          }
        }
        /**
         * @param {Array<SchemaUtilErrorObject>} errors
         * @returns {string}
         */

      }, {
        key: "formatValidationErrors",
        value: function formatValidationErrors(errors) {
          var _this4 = this;

          return errors.map(function (error) {
            var formattedError = _this4.formatValidationError(error);

            if (_this4.postFormatter) {
              formattedError = _this4.postFormatter(formattedError, error);
            }

            return " - ".concat(indent(formattedError, "   "));
          }).join("\n");
        }
      }]);

      return ValidationError;
    }( /*#__PURE__*/_wrapNativeSuper(Error));

    var _default = ValidationError;
    exports.default = _default;
  }, { "./util/hints": "SqDh" }], "wWOq": [function (require, module, exports) {
    var define;
    var global = arguments[3];
    /** @license URI.js v4.2.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
    (function (global, factory) {
      typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
        typeof define === 'function' && define.amd ? define(['exports'], factory) :
          (factory((global.URI = global.URI || {})));
    }(this, (function (exports) {
      'use strict';

      function merge() {
        for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
          sets[_key] = arguments[_key];
        }

        if (sets.length > 1) {
          sets[0] = sets[0].slice(0, -1);
          var xl = sets.length - 1;
          for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
          }
          sets[xl] = sets[xl].slice(1);
          return sets.join('');
        } else {
          return sets[0];
        }
      }
      function subexp(str) {
        return "(?:" + str + ")";
      }
      function typeOf(o) {
        return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
      }
      function toUpperCase(str) {
        return str.toUpperCase();
      }
      function toArray(obj) {
        return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
      }
      function assign(target, source) {
        var obj = target;
        if (source) {
          for (var key in source) {
            obj[key] = source[key];
          }
        }
        return obj;
      }

      function buildExps(isIRI) {
        var ALPHA$$ = "[A-Za-z]",
          CR$ = "[\\x0D]",
          DIGIT$$ = "[0-9]",
          DQUOTE$$ = "[\\x22]",
          HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
          //case-insensitive
          LF$$ = "[\\x0A]",
          SP$$ = "[\\x20]",
          PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),
          //expanded
          GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
          SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
          RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
          UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
          //subset, excludes bidi control characters
          IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]",
          //subset
          UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$),
          SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"),
          USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*"),
          DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$),
          DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),
          //relaxed parsing rules
          IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$),
          H16$ = subexp(HEXDIG$$ + "{1,4}"),
          LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
          IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
          //                           6( h16 ":" ) ls32
          IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$),
          //                      "::" 5( h16 ":" ) ls32
          IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$),
          //[               h16 ] "::" 4( h16 ":" ) ls32
          IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$),
          //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
          IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$),
          //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
          IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$),
          //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
          IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$),
          //[ *4( h16 ":" ) h16 ] "::"              ls32
          IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$),
          //[ *5( h16 ":" ) h16 ] "::"              h16
          IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"),
          //[ *6( h16 ":" ) h16 ] "::"
          IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),
          ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"),
          //RFC 6874
          IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$),
          //RFC 6874
          IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + ZONEID$),
          //RFC 6874, with relaxed parsing rules
          IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+"),
          IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"),
          //RFC 6874
          REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"),
          HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")" + "|" + REG_NAME$),
          PORT$ = subexp(DIGIT$$ + "*"),
          AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"),
          PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]")),
          SEGMENT$ = subexp(PCHAR$ + "*"),
          SEGMENT_NZ$ = subexp(PCHAR$ + "+"),
          SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+"),
          PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"),
          PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"),
          //simplified
          PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),
          //simplified
          PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),
          //simplified
          PATH_EMPTY$ = "(?!" + PCHAR$ + ")",
          PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
          QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"),
          FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"),
          HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
          URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
          RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$),
          RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
          URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$),
          ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"),
          GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
          RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
          ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$",
          SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
          AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
        return {
          NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
          NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
          NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
          NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
          NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
          NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
          NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
          ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
          UNRESERVED: new RegExp(UNRESERVED$$, "g"),
          OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
          PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
          IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
          IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules
        };
      }
      var URI_PROTOCOL = buildExps(false);

      var IRI_PROTOCOL = buildExps(true);

      var slicedToArray = function () {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = undefined;

          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);

              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }

          return _arr;
        }

        return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();













      var toConsumableArray = function (arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

          return arr2;
        } else {
          return Array.from(arr);
        }
      };

      /** Highest positive signed 32-bit float value */

      var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

      /** Bootstring parameters */
      var base = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128; // 0x80
      var delimiter = '-'; // '\x2D'

      /** Regular expressions */
      var regexPunycode = /^xn--/;
      var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
      var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

      /** Error messages */
      var errors = {
        'overflow': 'Overflow: input needs wider integers to process',
        'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
        'invalid-input': 'Invalid input'
      };

      /** Convenience shortcuts */
      var baseMinusTMin = base - tMin;
      var floor = Math.floor;
      var stringFromCharCode = String.fromCharCode;

      /*--------------------------------------------------------------------------*/

      /**
       * A generic error utility function.
       * @private
       * @param {String} type The error type.
       * @returns {Error} Throws a `RangeError` with the applicable error message.
       */
      function error$1(type) {
        throw new RangeError(errors[type]);
      }

      /**
       * A generic `Array#map` utility function.
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} callback The function that gets called for every array
       * item.
       * @returns {Array} A new array of values returned by the callback function.
       */
      function map(array, fn) {
        var result = [];
        var length = array.length;
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }

      /**
       * A simple `Array#map`-like wrapper to work with domain name strings or email
       * addresses.
       * @private
       * @param {String} domain The domain name or email address.
       * @param {Function} callback The function that gets called for every
       * character.
       * @returns {Array} A new string of characters returned by the callback
       * function.
       */
      function mapDomain(string, fn) {
        var parts = string.split('@');
        var result = '';
        if (parts.length > 1) {
          // In email addresses, only the domain name should be punycoded. Leave
          // the local part (i.e. everything up to `@`) intact.
          result = parts[0] + '@';
          string = parts[1];
        }
        // Avoid `split(regex)` for IE8 compatibility. See #17.
        string = string.replace(regexSeparators, '\x2E');
        var labels = string.split('.');
        var encoded = map(labels, fn).join('.');
        return result + encoded;
      }

      /**
       * Creates an array containing the numeric code points of each Unicode
       * character in the string. While JavaScript uses UCS-2 internally,
       * this function will convert a pair of surrogate halves (each of which
       * UCS-2 exposes as separate characters) into a single code point,
       * matching UTF-16.
       * @see `punycode.ucs2.encode`
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode.ucs2
       * @name decode
       * @param {String} string The Unicode input string (UCS-2).
       * @returns {Array} The new array of code points.
       */
      function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        while (counter < length) {
          var value = string.charCodeAt(counter++);
          if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
            // It's a high surrogate, and there is a next character.
            var extra = string.charCodeAt(counter++);
            if ((extra & 0xFC00) == 0xDC00) {
              // Low surrogate.
              output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
            } else {
              // It's an unmatched surrogate; only append this code unit, in case the
              // next code unit is the high surrogate of a surrogate pair.
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }

      /**
       * Creates a string based on an array of numeric code points.
       * @see `punycode.ucs2.decode`
       * @memberOf punycode.ucs2
       * @name encode
       * @param {Array} codePoints The array of numeric code points.
       * @returns {String} The new Unicode string (UCS-2).
       */
      var ucs2encode = function ucs2encode(array) {
        return String.fromCodePoint.apply(String, toConsumableArray(array));
      };

      /**
       * Converts a basic code point into a digit/integer.
       * @see `digitToBasic()`
       * @private
       * @param {Number} codePoint The basic numeric code point value.
       * @returns {Number} The numeric value of a basic code point (for use in
       * representing integers) in the range `0` to `base - 1`, or `base` if
       * the code point does not represent a value.
       */
      var basicToDigit = function basicToDigit(codePoint) {
        if (codePoint - 0x30 < 0x0A) {
          return codePoint - 0x16;
        }
        if (codePoint - 0x41 < 0x1A) {
          return codePoint - 0x41;
        }
        if (codePoint - 0x61 < 0x1A) {
          return codePoint - 0x61;
        }
        return base;
      };

      /**
       * Converts a digit/integer into a basic code point.
       * @see `basicToDigit()`
       * @private
       * @param {Number} digit The numeric value of a basic code point.
       * @returns {Number} The basic code point whose value (when used for
       * representing integers) is `digit`, which needs to be in the range
       * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
       * used; else, the lowercase form is used. The behavior is undefined
       * if `flag` is non-zero and `digit` has no uppercase form.
       */
      var digitToBasic = function digitToBasic(digit, flag) {
        //  0..25 map to ASCII a..z or A..Z
        // 26..35 map to ASCII 0..9
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      };

      /**
       * Bias adaptation function as per section 3.4 of RFC 3492.
       * https://tools.ietf.org/html/rfc3492#section-3.4
       * @private
       */
      var adapt = function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      };

      /**
       * Converts a Punycode string of ASCII-only symbols to a string of Unicode
       * symbols.
       * @memberOf punycode
       * @param {String} input The Punycode string of ASCII-only symbols.
       * @returns {String} The resulting string of Unicode symbols.
       */
      var decode = function decode(input) {
        // Don't use UCS-2.
        var output = [];
        var inputLength = input.length;
        var i = 0;
        var n = initialN;
        var bias = initialBias;

        // Handle the basic code points: let `basic` be the number of input code
        // points before the last delimiter, or `0` if there is none, then copy
        // the first basic code points to the output.

        var basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }

        for (var j = 0; j < basic; ++j) {
          // if it's not a basic code point
          if (input.charCodeAt(j) >= 0x80) {
            error$1('not-basic');
          }
          output.push(input.charCodeAt(j));
        }

        // Main decoding loop: start just after the last delimiter if any basic code
        // points were copied; start at the beginning otherwise.

        for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */ {

          // `index` is the index of the next character to be consumed.
          // Decode a generalized variable-length integer into `delta`,
          // which gets added to `i`. The overflow checking is easier
          // if we increase `i` as we go, then subtract off its starting
          // value at the end to obtain `delta`.
          var oldi = i;
          for (var w = 1, k = base; ; /* no condition */k += base) {

            if (index >= inputLength) {
              error$1('invalid-input');
            }

            var digit = basicToDigit(input.charCodeAt(index++));

            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error$1('overflow');
            }

            i += digit * w;
            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

            if (digit < t) {
              break;
            }

            var baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error$1('overflow');
            }

            w *= baseMinusT;
          }

          var out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);

          // `i` was supposed to wrap around from `out` to `0`,
          // incrementing `n` each time, so we'll fix that now:
          if (floor(i / out) > maxInt - n) {
            error$1('overflow');
          }

          n += floor(i / out);
          i %= out;

          // Insert `n` at position `i` of the output.
          output.splice(i++, 0, n);
        }

        return String.fromCodePoint.apply(String, output);
      };

      /**
       * Converts a string of Unicode symbols (e.g. a domain name label) to a
       * Punycode string of ASCII-only symbols.
       * @memberOf punycode
       * @param {String} input The string of Unicode symbols.
       * @returns {String} The resulting Punycode string of ASCII-only symbols.
       */
      var encode = function encode(input) {
        var output = [];

        // Convert the input in UCS-2 to an array of Unicode code points.
        input = ucs2decode(input);

        // Cache the length.
        var inputLength = input.length;

        // Initialize the state.
        var n = initialN;
        var delta = 0;
        var bias = initialBias;

        // Handle the basic code points.
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _currentValue2 = _step.value;

            if (_currentValue2 < 0x80) {
              output.push(stringFromCharCode(_currentValue2));
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var basicLength = output.length;
        var handledCPCount = basicLength;

        // `handledCPCount` is the number of code points that have been handled;
        // `basicLength` is the number of basic code points.

        // Finish the basic string with a delimiter unless it's empty.
        if (basicLength) {
          output.push(delimiter);
        }

        // Main encoding loop:
        while (handledCPCount < inputLength) {

          // All non-basic code points < n have been handled already. Find the next
          // larger one:
          var m = maxInt;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var currentValue = _step2.value;

              if (currentValue >= n && currentValue < m) {
                m = currentValue;
              }
            }

            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
            // but guard against overflow.
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          var handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error$1('overflow');
          }

          delta += (m - n) * handledCPCountPlusOne;
          n = m;

          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _currentValue = _step3.value;

              if (_currentValue < n && ++delta > maxInt) {
                error$1('overflow');
              }
              if (_currentValue == n) {
                // Represent delta as a generalized variable-length integer.
                var q = delta;
                for (var k = base; ; /* no condition */k += base) {
                  var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q < t) {
                    break;
                  }
                  var qMinusT = q - t;
                  var baseMinusT = base - t;
                  output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                  q = floor(qMinusT / baseMinusT);
                }

                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }

          ++delta;
          ++n;
        }
        return output.join('');
      };

      /**
       * Converts a Punycode string representing a domain name or an email address
       * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
       * it doesn't matter if you call it on a string that has already been
       * converted to Unicode.
       * @memberOf punycode
       * @param {String} input The Punycoded domain name or email address to
       * convert to Unicode.
       * @returns {String} The Unicode representation of the given Punycode
       * string.
       */
      var toUnicode = function toUnicode(input) {
        return mapDomain(input, function (string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      };

      /**
       * Converts a Unicode string representing a domain name or an email address to
       * Punycode. Only the non-ASCII parts of the domain name will be converted,
       * i.e. it doesn't matter if you call it with a domain that's already in
       * ASCII.
       * @memberOf punycode
       * @param {String} input The domain name or email address to convert, as a
       * Unicode string.
       * @returns {String} The Punycode representation of the given domain name or
       * email address.
       */
      var toASCII = function toASCII(input) {
        return mapDomain(input, function (string) {
          return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
        });
      };

      /*--------------------------------------------------------------------------*/

      /** Define the public API */
      var punycode = {
        /**
        * A string representing the current Punycode.js version number.
        * @memberOf punycode
        * @type String
        */
        'version': '2.1.0',
        /**
        * An object of methods to convert from JavaScript's internal character
        * representation (UCS-2) to Unicode code points, and back.
        * @see <https://mathiasbynens.be/notes/javascript-encoding>
        * @memberOf punycode
        * @type Object
        */
        'ucs2': {
          'decode': ucs2decode,
          'encode': ucs2encode
        },
        'decode': decode,
        'encode': encode,
        'toASCII': toASCII,
        'toUnicode': toUnicode
      };

      /**
       * URI.js
       *
       * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
       * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
       * @see http://github.com/garycourt/uri-js
       */
      /**
       * Copyright 2011 Gary Court. All rights reserved.
       *
       * Redistribution and use in source and binary forms, with or without modification, are
       * permitted provided that the following conditions are met:
       *
       *    1. Redistributions of source code must retain the above copyright notice, this list of
       *       conditions and the following disclaimer.
       *
       *    2. Redistributions in binary form must reproduce the above copyright notice, this list
       *       of conditions and the following disclaimer in the documentation and/or other materials
       *       provided with the distribution.
       *
       * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
       * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
       * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
       * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
       * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
       * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
       * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
       * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
       * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
       *
       * The views and conclusions contained in the software and documentation are those of the
       * authors and should not be interpreted as representing official policies, either expressed
       * or implied, of Gary Court.
       */
      var SCHEMES = {};
      function pctEncChar(chr) {
        var c = chr.charCodeAt(0);
        var e = void 0;
        if (c < 16) e = "%0" + c.toString(16).toUpperCase(); else if (c < 128) e = "%" + c.toString(16).toUpperCase(); else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase(); else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        return e;
      }
      function pctDecChars(str) {
        var newStr = "";
        var i = 0;
        var il = str.length;
        while (i < il) {
          var c = parseInt(str.substr(i + 1, 2), 16);
          if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
          } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
              var c2 = parseInt(str.substr(i + 4, 2), 16);
              newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
              newStr += str.substr(i, 6);
            }
            i += 6;
          } else if (c >= 224) {
            if (il - i >= 9) {
              var _c = parseInt(str.substr(i + 4, 2), 16);
              var c3 = parseInt(str.substr(i + 7, 2), 16);
              newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
              newStr += str.substr(i, 9);
            }
            i += 9;
          } else {
            newStr += str.substr(i, 3);
            i += 3;
          }
        }
        return newStr;
      }
      function _normalizeComponentEncoding(components, protocol) {
        function decodeUnreserved(str) {
          var decStr = pctDecChars(str);
          return !decStr.match(protocol.UNRESERVED) ? str : decStr;
        }
        if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
        if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        return components;
      }

      function _stripLeadingZeros(str) {
        return str.replace(/^0*(.*)/, "$1") || "0";
      }
      function _normalizeIPv4(host, protocol) {
        var matches = host.match(protocol.IPV4ADDRESS) || [];

        var _matches = slicedToArray(matches, 2),
          address = _matches[1];

        if (address) {
          return address.split(".").map(_stripLeadingZeros).join(".");
        } else {
          return host;
        }
      }
      function _normalizeIPv6(host, protocol) {
        var matches = host.match(protocol.IPV6ADDRESS) || [];

        var _matches2 = slicedToArray(matches, 3),
          address = _matches2[1],
          zone = _matches2[2];

        if (address) {
          var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
            last = _address$toLowerCase$2[0],
            first = _address$toLowerCase$2[1];

          var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
          var lastFields = last.split(":").map(_stripLeadingZeros);
          var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
          var fieldCount = isLastFieldIPv4Address ? 7 : 8;
          var lastFieldsStart = lastFields.length - fieldCount;
          var fields = Array(fieldCount);
          for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
          }
          if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
          }
          var allZeroFields = fields.reduce(function (acc, field, index) {
            if (!field || field === "0") {
              var lastLongest = acc[acc.length - 1];
              if (lastLongest && lastLongest.index + lastLongest.length === index) {
                lastLongest.length++;
              } else {
                acc.push({ index: index, length: 1 });
              }
            }
            return acc;
          }, []);
          var longestZeroFields = allZeroFields.sort(function (a, b) {
            return b.length - a.length;
          })[0];
          var newHost = void 0;
          if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
          } else {
            newHost = fields.join(":");
          }
          if (zone) {
            newHost += "%" + zone;
          }
          return newHost;
        } else {
          return host;
        }
      }
      var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
      var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
      function parse(uriString) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var components = {};
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches = uriString.match(URI_PARSE);
        if (matches) {
          if (NO_MATCH_IS_UNDEFINED) {
            //store each component
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            //fix port number
            if (isNaN(components.port)) {
              components.port = matches[5];
            }
          } else {
            //IE FIX for improper RegExp matching
            //store each component
            components.scheme = matches[1] || undefined;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
            //fix port number
            if (isNaN(components.port)) {
              components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
            }
          }
          if (components.host) {
            //normalize IP hosts
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
          }
          //determine reference type
          if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
            components.reference = "same-document";
          } else if (components.scheme === undefined) {
            components.reference = "relative";
          } else if (components.fragment === undefined) {
            components.reference = "absolute";
          } else {
            components.reference = "uri";
          }
          //check for reference errors
          if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
          }
          //find scheme handler
          var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          //check if scheme can't handle IRIs
          if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            //if host component is a domain name
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
              //convert Unicode IDN -> ASCII IDN
              try {
                components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
              } catch (e) {
                components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
              }
            }
            //convert IRI -> URI
            _normalizeComponentEncoding(components, URI_PROTOCOL);
          } else {
            //normalize encodings
            _normalizeComponentEncoding(components, protocol);
          }
          //perform scheme specific parsing
          if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
          }
        } else {
          components.error = components.error || "URI can not be parsed.";
        }
        return components;
      }

      function _recomposeAuthority(components, options) {
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== undefined) {
          uriTokens.push(components.userinfo);
          uriTokens.push("@");
        }
        if (components.host !== undefined) {
          //normalize IP hosts, add brackets and escape zone separator for IPv6
          uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
          }));
        }
        if (typeof components.port === "number") {
          uriTokens.push(":");
          uriTokens.push(components.port.toString(10));
        }
        return uriTokens.length ? uriTokens.join("") : undefined;
      }

      var RDS1 = /^\.\.?\//;
      var RDS2 = /^\/\.(\/|$)/;
      var RDS3 = /^\/\.\.(\/|$)/;
      var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
      function removeDotSegments(input) {
        var output = [];
        while (input.length) {
          if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
          } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
          } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
          } else if (input === "." || input === "..") {
            input = "";
          } else {
            var im = input.match(RDS5);
            if (im) {
              var s = im[0];
              input = input.slice(s.length);
              output.push(s);
            } else {
              throw new Error("Unexpected dot segment condition");
            }
          }
        }
        return output.join("");
      }

      function serialize(components) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        //find scheme handler
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        //perform scheme specific serialization
        if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
        if (components.host) {
          //if host component is an IPv6 address
          if (protocol.IPV6ADDRESS.test(components.host)) { }
          //TODO: normalize IPv6 address as per RFC 5952

          //if host component is a domain name
          else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
            //convert IDN via punycode
            try {
              components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
          }
        }
        //normalize encoding
        _normalizeComponentEncoding(components, protocol);
        if (options.reference !== "suffix" && components.scheme) {
          uriTokens.push(components.scheme);
          uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== undefined) {
          if (options.reference !== "suffix") {
            uriTokens.push("//");
          }
          uriTokens.push(authority);
          if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
          }
        }
        if (components.path !== undefined) {
          var s = components.path;
          if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
          }
          if (authority === undefined) {
            s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
          }
          uriTokens.push(s);
        }
        if (components.query !== undefined) {
          uriTokens.push("?");
          uriTokens.push(components.query);
        }
        if (components.fragment !== undefined) {
          uriTokens.push("#");
          uriTokens.push(components.fragment);
        }
        return uriTokens.join(""); //merge tokens into a string
      }

      function resolveComponents(base, relative) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var skipNormalization = arguments[3];

        var target = {};
        if (!skipNormalization) {
          base = parse(serialize(base, options), options); //normalize base components
          relative = parse(serialize(relative, options), options); //normalize relative components
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
          target.scheme = relative.scheme;
          //target.authority = relative.authority;
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
            //target.authority = relative.authority;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (!relative.path) {
              target.path = base.path;
              if (relative.query !== undefined) {
                target.query = relative.query;
              } else {
                target.query = base.query;
              }
            } else {
              if (relative.path.charAt(0) === "/") {
                target.path = removeDotSegments(relative.path);
              } else {
                if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
                  target.path = "/" + relative.path;
                } else if (!base.path) {
                  target.path = relative.path;
                } else {
                  target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
                }
                target.path = removeDotSegments(target.path);
              }
              target.query = relative.query;
            }
            //target.authority = base.authority;
            target.userinfo = base.userinfo;
            target.host = base.host;
            target.port = base.port;
          }
          target.scheme = base.scheme;
        }
        target.fragment = relative.fragment;
        return target;
      }

      function resolve(baseURI, relativeURI, options) {
        var schemelessOptions = assign({ scheme: 'null' }, options);
        return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
      }

      function normalize(uri, options) {
        if (typeof uri === "string") {
          uri = serialize(parse(uri, options), options);
        } else if (typeOf(uri) === "object") {
          uri = parse(serialize(uri, options), options);
        }
        return uri;
      }

      function equal(uriA, uriB, options) {
        if (typeof uriA === "string") {
          uriA = serialize(parse(uriA, options), options);
        } else if (typeOf(uriA) === "object") {
          uriA = serialize(uriA, options);
        }
        if (typeof uriB === "string") {
          uriB = serialize(parse(uriB, options), options);
        } else if (typeOf(uriB) === "object") {
          uriB = serialize(uriB, options);
        }
        return uriA === uriB;
      }

      function escapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
      }

      function unescapeComponent(str, options) {
        return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
      }

      var handler = {
        scheme: "http",
        domainHost: true,
        parse: function parse(components, options) {
          //report missing host
          if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
          }
          return components;
        },
        serialize: function serialize(components, options) {
          //normalize the default port
          if (components.port === (String(components.scheme).toLowerCase() !== "https" ? 80 : 443) || components.port === "") {
            components.port = undefined;
          }
          //normalize the empty path
          if (!components.path) {
            components.path = "/";
          }
          //NOTE: We do not parse query strings for HTTP URIs
          //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
          //and not the HTTP spec.
          return components;
        }
      };

      var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize
      };

      var O = {};
      var isIRI = true;
      //RFC 3986
      var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
      var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
      var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
      //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
      //const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
      //const WSP$$ = "[\\x20\\x09]";
      //const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
      //const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
      //const VCHAR$$ = "[\\x21-\\x7E]";
      //const WSP$$ = "[\\x20\\x09]";
      //const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
      //const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
      //const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
      //const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
      var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
      var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
      var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
      var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
      var UNRESERVED = new RegExp(UNRESERVED$$, "g");
      var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
      var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
      var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
      var NOT_HFVALUE = NOT_HFNAME;
      function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(UNRESERVED) ? str : decStr;
      }
      var handler$2 = {
        scheme: "mailto",
        parse: function parse$$1(components, options) {
          var mailtoComponents = components;
          var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
          mailtoComponents.path = undefined;
          if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
              var hfield = hfields[x].split("=");
              switch (hfield[0]) {
                case "to":
                  var toAddrs = hfield[1].split(",");
                  for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                    to.push(toAddrs[_x]);
                  }
                  break;
                case "subject":
                  mailtoComponents.subject = unescapeComponent(hfield[1], options);
                  break;
                case "body":
                  mailtoComponents.body = unescapeComponent(hfield[1], options);
                  break;
                default:
                  unknownHeaders = true;
                  headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                  break;
              }
            }
            if (unknownHeaders) mailtoComponents.headers = headers;
          }
          mailtoComponents.query = undefined;
          for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
              //convert Unicode IDN -> ASCII IDN
              try {
                addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
              } catch (e) {
                mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
              }
            } else {
              addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
          }
          return mailtoComponents;
        },
        serialize: function serialize$$1(mailtoComponents, options) {
          var components = mailtoComponents;
          var to = toArray(mailtoComponents.to);
          if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
              var toAddr = String(to[x]);
              var atIdx = toAddr.lastIndexOf("@");
              var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
              var domain = toAddr.slice(atIdx + 1);
              //convert IDN via punycode
              try {
                domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
              } catch (e) {
                components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
              }
              to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
          }
          var headers = mailtoComponents.headers = mailtoComponents.headers || {};
          if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
          if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
          var fields = [];
          for (var name in headers) {
            if (headers[name] !== O[name]) {
              fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
          }
          if (fields.length) {
            components.query = fields.join("&");
          }
          return components;
        }
      };

      var URN_PARSE = /^([^\:]+)\:(.*)/;
      //RFC 2141
      var handler$3 = {
        scheme: "urn",
        parse: function parse$$1(components, options) {
          var matches = components.path && components.path.match(URN_PARSE);
          var urnComponents = components;
          if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = undefined;
            if (schemeHandler) {
              urnComponents = schemeHandler.parse(urnComponents, options);
            }
          } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
          }
          return urnComponents;
        },
        serialize: function serialize$$1(urnComponents, options) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = urnComponents.nid;
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
          }
          var uriComponents = urnComponents;
          var nss = urnComponents.nss;
          uriComponents.path = (nid || options.nid) + ":" + nss;
          return uriComponents;
        }
      };

      var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
      //RFC 4122
      var handler$4 = {
        scheme: "urn:uuid",
        parse: function parse(urnComponents, options) {
          var uuidComponents = urnComponents;
          uuidComponents.uuid = uuidComponents.nss;
          uuidComponents.nss = undefined;
          if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
          }
          return uuidComponents;
        },
        serialize: function serialize(uuidComponents, options) {
          var urnComponents = uuidComponents;
          //normalize UUID
          urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
          return urnComponents;
        }
      };

      SCHEMES[handler.scheme] = handler;
      SCHEMES[handler$1.scheme] = handler$1;
      SCHEMES[handler$2.scheme] = handler$2;
      SCHEMES[handler$3.scheme] = handler$3;
      SCHEMES[handler$4.scheme] = handler$4;

      exports.SCHEMES = SCHEMES;
      exports.pctEncChar = pctEncChar;
      exports.pctDecChars = pctDecChars;
      exports.parse = parse;
      exports.removeDotSegments = removeDotSegments;
      exports.serialize = serialize;
      exports.resolveComponents = resolveComponents;
      exports.resolve = resolve;
      exports.normalize = normalize;
      exports.equal = equal;
      exports.escapeComponent = escapeComponent;
      exports.unescapeComponent = unescapeComponent;

      Object.defineProperty(exports, '__esModule', { value: true });

    })));


  }, {}], "dPQH": [function (require, module, exports) {
    'use strict';

    // do not edit .js files directly - edit src/index.jst



    module.exports = function equal(a, b) {
      if (a === b) return true;

      if (a && b && typeof a == 'object' && typeof b == 'object') {
        if (a.constructor !== b.constructor) return false;

        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0;)
            if (!equal(a[i], b[i])) return false;
          return true;
        }



        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;

        for (i = length; i-- !== 0;)
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

        for (i = length; i-- !== 0;) {
          var key = keys[i];

          if (!equal(a[key], b[key])) return false;
        }

        return true;
      }

      // true if both NaN, false otherwise
      return a !== a && b !== b;
    };

  }, {}], "rD0p": [function (require, module, exports) {
    'use strict';

    // https://mathiasbynens.be/notes/javascript-encoding
    // https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
    module.exports = function ucs2length(str) {
      var length = 0
        , len = str.length
        , pos = 0
        , value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
          // high surrogate, and there is a next character
          value = str.charCodeAt(pos);
          if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate
        }
      }
      return length;
    };

  }, {}], "Q1F7": [function (require, module, exports) {
    'use strict';


    module.exports = {
      copy: copy,
      checkDataType: checkDataType,
      checkDataTypes: checkDataTypes,
      coerceToTypes: coerceToTypes,
      toHash: toHash,
      getProperty: getProperty,
      escapeQuotes: escapeQuotes,
      equal: require('fast-deep-equal'),
      ucs2length: require('./ucs2length'),
      varOccurences: varOccurences,
      varReplace: varReplace,
      schemaHasRules: schemaHasRules,
      schemaHasRulesExcept: schemaHasRulesExcept,
      schemaUnknownRules: schemaUnknownRules,
      toQuotedString: toQuotedString,
      getPathExpr: getPathExpr,
      getPath: getPath,
      getData: getData,
      unescapeFragment: unescapeFragment,
      unescapeJsonPointer: unescapeJsonPointer,
      escapeFragment: escapeFragment,
      escapeJsonPointer: escapeJsonPointer
    };


    function copy(o, to) {
      to = to || {};
      for (var key in o) to[key] = o[key];
      return to;
    }


    function checkDataType(dataType, data, strictNumbers, negate) {
      var EQUAL = negate ? ' !== ' : ' === '
        , AND = negate ? ' || ' : ' && '
        , OK = negate ? '!' : ''
        , NOT = negate ? '' : '!';
      switch (dataType) {
        case 'null': return data + EQUAL + 'null';
        case 'array': return OK + 'Array.isArray(' + data + ')';
        case 'object': return '(' + OK + data + AND +
          'typeof ' + data + EQUAL + '"object"' + AND +
          NOT + 'Array.isArray(' + data + '))';
        case 'integer': return '(typeof ' + data + EQUAL + '"number"' + AND +
          NOT + '(' + data + ' % 1)' +
          AND + data + EQUAL + data +
          (strictNumbers ? (AND + OK + 'isFinite(' + data + ')') : '') + ')';
        case 'number': return '(typeof ' + data + EQUAL + '"' + dataType + '"' +
          (strictNumbers ? (AND + OK + 'isFinite(' + data + ')') : '') + ')';
        default: return 'typeof ' + data + EQUAL + '"' + dataType + '"';
      }
    }


    function checkDataTypes(dataTypes, data, strictNumbers) {
      switch (dataTypes.length) {
        case 1: return checkDataType(dataTypes[0], data, strictNumbers, true);
        default:
          var code = '';
          var types = toHash(dataTypes);
          if (types.array && types.object) {
            code = types.null ? '(' : '(!' + data + ' || ';
            code += 'typeof ' + data + ' !== "object")';
            delete types.null;
            delete types.array;
            delete types.object;
          }
          if (types.number) delete types.integer;
          for (var t in types)
            code += (code ? ' && ' : '') + checkDataType(t, data, strictNumbers, true);

          return code;
      }
    }


    var COERCE_TO_TYPES = toHash(['string', 'number', 'integer', 'boolean', 'null']);
    function coerceToTypes(optionCoerceTypes, dataTypes) {
      if (Array.isArray(dataTypes)) {
        var types = [];
        for (var i = 0; i < dataTypes.length; i++) {
          var t = dataTypes[i];
          if (COERCE_TO_TYPES[t]) types[types.length] = t;
          else if (optionCoerceTypes === 'array' && t === 'array') types[types.length] = t;
        }
        if (types.length) return types;
      } else if (COERCE_TO_TYPES[dataTypes]) {
        return [dataTypes];
      } else if (optionCoerceTypes === 'array' && dataTypes === 'array') {
        return ['array'];
      }
    }


    function toHash(arr) {
      var hash = {};
      for (var i = 0; i < arr.length; i++) hash[arr[i]] = true;
      return hash;
    }


    var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var SINGLE_QUOTE = /'|\\/g;
    function getProperty(key) {
      return typeof key == 'number'
        ? '[' + key + ']'
        : IDENTIFIER.test(key)
          ? '.' + key
          : "['" + escapeQuotes(key) + "']";
    }


    function escapeQuotes(str) {
      return str.replace(SINGLE_QUOTE, '\\$&')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/\f/g, '\\f')
        .replace(/\t/g, '\\t');
    }


    function varOccurences(str, dataVar) {
      dataVar += '[^0-9]';
      var matches = str.match(new RegExp(dataVar, 'g'));
      return matches ? matches.length : 0;
    }


    function varReplace(str, dataVar, expr) {
      dataVar += '([^0-9])';
      expr = expr.replace(/\$/g, '$$$$');
      return str.replace(new RegExp(dataVar, 'g'), expr + '$1');
    }


    function schemaHasRules(schema, rules) {
      if (typeof schema == 'boolean') return !schema;
      for (var key in schema) if (rules[key]) return true;
    }


    function schemaHasRulesExcept(schema, rules, exceptKeyword) {
      if (typeof schema == 'boolean') return !schema && exceptKeyword != 'not';
      for (var key in schema) if (key != exceptKeyword && rules[key]) return true;
    }


    function schemaUnknownRules(schema, rules) {
      if (typeof schema == 'boolean') return;
      for (var key in schema) if (!rules[key]) return key;
    }


    function toQuotedString(str) {
      return '\'' + escapeQuotes(str) + '\'';
    }


    function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
      var path = jsonPointers // false by default
        ? '\'/\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \'~0\').replace(/\\//g, \'~1\')')
        : (isNumber ? '\'[\' + ' + expr + ' + \']\'' : '\'[\\\'\' + ' + expr + ' + \'\\\']\'');
      return joinPaths(currentPath, path);
    }


    function getPath(currentPath, prop, jsonPointers) {
      var path = jsonPointers // false by default
        ? toQuotedString('/' + escapeJsonPointer(prop))
        : toQuotedString(getProperty(prop));
      return joinPaths(currentPath, path);
    }


    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, lvl, paths) {
      var up, jsonPointer, data, matches;
      if ($data === '') return 'rootData';
      if ($data[0] == '/') {
        if (!JSON_POINTER.test($data)) throw new Error('Invalid JSON-pointer: ' + $data);
        jsonPointer = $data;
        data = 'rootData';
      } else {
        matches = $data.match(RELATIVE_JSON_POINTER);
        if (!matches) throw new Error('Invalid JSON-pointer: ' + $data);
        up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer == '#') {
          if (up >= lvl) throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);
          return paths[lvl - up];
        }

        if (up > lvl) throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);
        data = 'data' + ((lvl - up) || '');
        if (!jsonPointer) return data;
      }

      var expr = data;
      var segments = jsonPointer.split('/');
      for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];
        if (segment) {
          data += getProperty(unescapeJsonPointer(segment));
          expr += ' && ' + data;
        }
      }
      return expr;
    }


    function joinPaths(a, b) {
      if (a == '""') return b;
      return (a + ' + ' + b).replace(/([^\\])' \+ '/g, '$1');
    }


    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }


    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }


    function escapeJsonPointer(str) {
      return str.replace(/~/g, '~0').replace(/\//g, '~1');
    }


    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, '/').replace(/~0/g, '~');
    }

  }, { "fast-deep-equal": "dPQH", "./ucs2length": "rD0p" }], "HHLG": [function (require, module, exports) {
    'use strict';

    var util = require('./util');

    module.exports = SchemaObject;

    function SchemaObject(obj) {
      util.copy(obj, this);
    }

  }, { "./util": "Q1F7" }], "uMRE": [function (require, module, exports) {
    'use strict';

    var traverse = module.exports = function (schema, opts, cb) {
      // Legacy support for v0.3.1 and earlier.
      if (typeof opts == 'function') {
        cb = opts;
        opts = {};
      }

      cb = opts.cb || cb;
      var pre = (typeof cb == 'function') ? cb : cb.pre || function () { };
      var post = cb.post || function () { };

      _traverse(opts, pre, post, schema, '', schema);
    };


    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true
    };

    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };

    traverse.propsKeywords = {
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };

    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };


    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == 'object') {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
            _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }


    function escapeJsonPtr(str) {
      return str.replace(/~/g, '~0').replace(/\//g, '~1');
    }

  }, {}], "w10T": [function (require, module, exports) {
    'use strict';

    var URI = require('uri-js')
      , equal = require('fast-deep-equal')
      , util = require('./util')
      , SchemaObject = require('./schema_obj')
      , traverse = require('json-schema-traverse');

    module.exports = resolve;

    resolve.normalizeId = normalizeId;
    resolve.fullPath = getFullPath;
    resolve.url = resolveUrl;
    resolve.ids = resolveIds;
    resolve.inlineRef = inlineRef;
    resolve.schema = resolveSchema;

    /**
     * [resolve and compile the references ($ref)]
     * @this   Ajv
     * @param  {Function} compile reference to schema compilation funciton (localCompile)
     * @param  {Object} root object with information about the root schema for the current schema
     * @param  {String} ref reference to resolve
     * @return {Object|Function} schema object (if the schema can be inlined) or validation function
     */
    function resolve(compile, root, ref) {
      /* jshint validthis: true */
      var refVal = this._refs[ref];
      if (typeof refVal == 'string') {
        if (this._refs[refVal]) refVal = this._refs[refVal];
        else return resolve.call(this, compile, root, refVal);
      }

      refVal = refVal || this._schemas[ref];
      if (refVal instanceof SchemaObject) {
        return inlineRef(refVal.schema, this._opts.inlineRefs)
          ? refVal.schema
          : refVal.validate || this._compile(refVal);
      }

      var res = resolveSchema.call(this, root, ref);
      var schema, v, baseId;
      if (res) {
        schema = res.schema;
        root = res.root;
        baseId = res.baseId;
      }

      if (schema instanceof SchemaObject) {
        v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
      } else if (schema !== undefined) {
        v = inlineRef(schema, this._opts.inlineRefs)
          ? schema
          : compile.call(this, schema, root, undefined, baseId);
      }

      return v;
    }


    /**
     * Resolve schema, its root and baseId
     * @this Ajv
     * @param  {Object} root root object with properties schema, refVal, refs
     * @param  {String} ref  reference to resolve
     * @return {Object} object with properties schema, root, baseId
     */
    function resolveSchema(root, ref) {
      /* jshint validthis: true */
      var p = URI.parse(ref)
        , refPath = _getFullPath(p)
        , baseId = getFullPath(this._getId(root.schema));
      if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
        var id = normalizeId(refPath);
        var refVal = this._refs[id];
        if (typeof refVal == 'string') {
          return resolveRecursive.call(this, root, refVal, p);
        } else if (refVal instanceof SchemaObject) {
          if (!refVal.validate) this._compile(refVal);
          root = refVal;
        } else {
          refVal = this._schemas[id];
          if (refVal instanceof SchemaObject) {
            if (!refVal.validate) this._compile(refVal);
            if (id == normalizeId(ref))
              return { schema: refVal, root: root, baseId: baseId };
            root = refVal;
          } else {
            return;
          }
        }
        if (!root.schema) return;
        baseId = getFullPath(this._getId(root.schema));
      }
      return getJsonPointer.call(this, p, baseId, root.schema, root);
    }


    /* @this Ajv */
    function resolveRecursive(root, ref, parsedRef) {
      /* jshint validthis: true */
      var res = resolveSchema.call(this, root, ref);
      if (res) {
        var schema = res.schema;
        var baseId = res.baseId;
        root = res.root;
        var id = this._getId(schema);
        if (id) baseId = resolveUrl(baseId, id);
        return getJsonPointer.call(this, parsedRef, baseId, schema, root);
      }
    }


    var PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);
    /* @this Ajv */
    function getJsonPointer(parsedRef, baseId, schema, root) {
      /* jshint validthis: true */
      parsedRef.fragment = parsedRef.fragment || '';
      if (parsedRef.fragment.slice(0, 1) != '/') return;
      var parts = parsedRef.fragment.split('/');

      for (var i = 1; i < parts.length; i++) {
        var part = parts[i];
        if (part) {
          part = util.unescapeFragment(part);
          schema = schema[part];
          if (schema === undefined) break;
          var id;
          if (!PREVENT_SCOPE_CHANGE[part]) {
            id = this._getId(schema);
            if (id) baseId = resolveUrl(baseId, id);
            if (schema.$ref) {
              var $ref = resolveUrl(baseId, schema.$ref);
              var res = resolveSchema.call(this, root, $ref);
              if (res) {
                schema = res.schema;
                root = res.root;
                baseId = res.baseId;
              }
            }
          }
        }
      }
      if (schema !== undefined && schema !== root.schema)
        return { schema: schema, root: root, baseId: baseId };
    }


    var SIMPLE_INLINED = util.toHash([
      'type', 'format', 'pattern',
      'maxLength', 'minLength',
      'maxProperties', 'minProperties',
      'maxItems', 'minItems',
      'maximum', 'minimum',
      'uniqueItems', 'multipleOf',
      'required', 'enum'
    ]);
    function inlineRef(schema, limit) {
      if (limit === false) return false;
      if (limit === undefined || limit === true) return checkNoRef(schema);
      else if (limit) return countKeys(schema) <= limit;
    }


    function checkNoRef(schema) {
      var item;
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++) {
          item = schema[i];
          if (typeof item == 'object' && !checkNoRef(item)) return false;
        }
      } else {
        for (var key in schema) {
          if (key == '$ref') return false;
          item = schema[key];
          if (typeof item == 'object' && !checkNoRef(item)) return false;
        }
      }
      return true;
    }


    function countKeys(schema) {
      var count = 0, item;
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++) {
          item = schema[i];
          if (typeof item == 'object') count += countKeys(item);
          if (count == Infinity) return Infinity;
        }
      } else {
        for (var key in schema) {
          if (key == '$ref') return Infinity;
          if (SIMPLE_INLINED[key]) {
            count++;
          } else {
            item = schema[key];
            if (typeof item == 'object') count += countKeys(item) + 1;
            if (count == Infinity) return Infinity;
          }
        }
      }
      return count;
    }


    function getFullPath(id, normalize) {
      if (normalize !== false) id = normalizeId(id);
      var p = URI.parse(id);
      return _getFullPath(p);
    }


    function _getFullPath(p) {
      return URI.serialize(p).split('#')[0] + '#';
    }


    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, '') : '';
    }


    function resolveUrl(baseId, id) {
      id = normalizeId(id);
      return URI.resolve(baseId, id);
    }


    /* @this Ajv */
    function resolveIds(schema) {
      var schemaId = normalizeId(this._getId(schema));
      var baseIds = { '': schemaId };
      var fullPaths = { '': getFullPath(schemaId, false) };
      var localRefs = {};
      var self = this;

      traverse(schema, { allKeys: true }, function (sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
        if (jsonPtr === '') return;
        var id = self._getId(sch);
        var baseId = baseIds[parentJsonPtr];
        var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;
        if (keyIndex !== undefined)
          fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util.escapeFragment(keyIndex));

        if (typeof id == 'string') {
          id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);

          var refVal = self._refs[id];
          if (typeof refVal == 'string') refVal = self._refs[refVal];
          if (refVal && refVal.schema) {
            if (!equal(sch, refVal.schema))
              throw new Error('id "' + id + '" resolves to more than one schema');
          } else if (id != normalizeId(fullPath)) {
            if (id[0] == '#') {
              if (localRefs[id] && !equal(sch, localRefs[id]))
                throw new Error('id "' + id + '" resolves to more than one schema');
              localRefs[id] = sch;
            } else {
              self._refs[id] = fullPath;
            }
          }
        }
        baseIds[jsonPtr] = baseId;
        fullPaths[jsonPtr] = fullPath;
      });

      return localRefs;
    }

  }, { "uri-js": "wWOq", "fast-deep-equal": "dPQH", "./util": "Q1F7", "./schema_obj": "HHLG", "json-schema-traverse": "uMRE" }], "OtNE": [function (require, module, exports) {
    'use strict';

    var resolve = require('./resolve');

    module.exports = {
      Validation: errorSubclass(ValidationError),
      MissingRef: errorSubclass(MissingRefError)
    };


    function ValidationError(errors) {
      this.message = 'validation failed';
      this.errors = errors;
      this.ajv = this.validation = true;
    }


    MissingRefError.message = function (baseId, ref) {
      return 'can\'t resolve reference ' + ref + ' from id ' + baseId;
    };


    function MissingRefError(baseId, ref, message) {
      this.message = message || MissingRefError.message(baseId, ref);
      this.missingRef = resolve.url(baseId, ref);
      this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
    }


    function errorSubclass(Subclass) {
      Subclass.prototype = Object.create(Error.prototype);
      Subclass.prototype.constructor = Subclass;
      return Subclass;
    }

  }, { "./resolve": "w10T" }], "Xb3N": [function (require, module, exports) {
    'use strict';

    module.exports = function (data, opts) {
      if (!opts) opts = {};
      if (typeof opts === 'function') opts = { cmp: opts };
      var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;

      var cmp = opts.cmp && (function (f) {
        return function (node) {
          return function (a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      })(opts.cmp);

      var seen = [];
      return (function stringify(node) {
        if (node && node.toJSON && typeof node.toJSON === 'function') {
          node = node.toJSON();
        }

        if (node === undefined) return;
        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
        if (typeof node !== 'object') return JSON.stringify(node);

        var i, out;
        if (Array.isArray(node)) {
          out = '[';
          for (i = 0; i < node.length; i++) {
            if (i) out += ',';
            out += stringify(node[i]) || 'null';
          }
          return out + ']';
        }

        if (node === null) return 'null';

        if (seen.indexOf(node) !== -1) {
          if (cycles) return JSON.stringify('__cycle__');
          throw new TypeError('Converting circular structure to JSON');
        }

        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = '';
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          var value = stringify(node[key]);

          if (!value) continue;
          if (out) out += ',';
          out += JSON.stringify(key) + ':' + value;
        }
        seen.splice(seenIndex, 1);
        return '{' + out + '}';
      })(data);
    };

  }, {}], "yhC1": [function (require, module, exports) {
    'use strict';
    module.exports = function generate_validate(it, $keyword, $ruleType) {
      var out = '';
      var $async = it.schema.$async === true,
        $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref'),
        $id = it.self._getId(it.schema);
      if (it.opts.strictKeywords) {
        var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
        if ($unknownKwd) {
          var $keywordsMsg = 'unknown keyword: ' + $unknownKwd;
          if (it.opts.strictKeywords === 'log') it.logger.warn($keywordsMsg);
          else throw new Error($keywordsMsg);
        }
      }
      if (it.isTop) {
        out += ' var validate = ';
        if ($async) {
          it.async = true;
          out += 'async ';
        }
        out += 'function(data, dataPath, parentData, parentDataProperty, rootData) { \'use strict\'; ';
        if ($id && (it.opts.sourceCode || it.opts.processCode)) {
          out += ' ' + ('/\*# sourceURL=' + $id + ' */') + ' ';
        }
      }
      if (typeof it.schema == 'boolean' || !($refKeywords || it.schema.$ref)) {
        var $keyword = 'false schema';
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $errorKeyword;
        var $data = 'data' + ($dataLvl || '');
        var $valid = 'valid' + $lvl;
        if (it.schema === false) {
          if (it.isTop) {
            $breakOnError = true;
          } else {
            out += ' var ' + ($valid) + ' = false; ';
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ($errorKeyword || 'false schema') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
            if (it.opts.messages !== false) {
              out += ' , message: \'boolean schema is false\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + (__err) + ']); ';
            } else {
              out += ' validate.errors = [' + (__err) + ']; return false; ';
            }
          } else {
            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
        } else {
          if (it.isTop) {
            if ($async) {
              out += ' return data; ';
            } else {
              out += ' validate.errors = null; return true; ';
            }
          } else {
            out += ' var ' + ($valid) + ' = true; ';
          }
        }
        if (it.isTop) {
          out += ' }; return validate; ';
        }
        return out;
      }
      if (it.isTop) {
        var $top = it.isTop,
          $lvl = it.level = 0,
          $dataLvl = it.dataLevel = 0,
          $data = 'data';
        it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
        it.baseId = it.baseId || it.rootId;
        delete it.isTop;
        it.dataPathArr = [""];
        if (it.schema.default !== undefined && it.opts.useDefaults && it.opts.strictDefaults) {
          var $defaultMsg = 'default is ignored in the schema root';
          if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
          else throw new Error($defaultMsg);
        }
        out += ' var vErrors = null; ';
        out += ' var errors = 0;     ';
        out += ' if (rootData === undefined) rootData = data; ';
      } else {
        var $lvl = it.level,
          $dataLvl = it.dataLevel,
          $data = 'data' + ($dataLvl || '');
        if ($id) it.baseId = it.resolve.url(it.baseId, $id);
        if ($async && !it.async) throw new Error('async schema in sync schema');
        out += ' var errs_' + ($lvl) + ' = errors;';
      }
      var $valid = 'valid' + $lvl,
        $breakOnError = !it.opts.allErrors,
        $closingBraces1 = '',
        $closingBraces2 = '';
      var $errorKeyword;
      var $typeSchema = it.schema.type,
        $typeIsArray = Array.isArray($typeSchema);
      if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
        if ($typeIsArray) {
          if ($typeSchema.indexOf('null') == -1) $typeSchema = $typeSchema.concat('null');
        } else if ($typeSchema != 'null') {
          $typeSchema = [$typeSchema, 'null'];
          $typeIsArray = true;
        }
      }
      if ($typeIsArray && $typeSchema.length == 1) {
        $typeSchema = $typeSchema[0];
        $typeIsArray = false;
      }
      if (it.schema.$ref && $refKeywords) {
        if (it.opts.extendRefs == 'fail') {
          throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
        } else if (it.opts.extendRefs !== true) {
          $refKeywords = false;
          it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
        }
      }
      if (it.schema.$comment && it.opts.$comment) {
        out += ' ' + (it.RULES.all.$comment.code(it, '$comment'));
      }
      if ($typeSchema) {
        if (it.opts.coerceTypes) {
          var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
        }
        var $rulesGroup = it.RULES.types[$typeSchema];
        if ($coerceToTypes || $typeIsArray || $rulesGroup === true || ($rulesGroup && !$shouldUseGroup($rulesGroup))) {
          var $schemaPath = it.schemaPath + '.type',
            $errSchemaPath = it.errSchemaPath + '/type';
          var $schemaPath = it.schemaPath + '.type',
            $errSchemaPath = it.errSchemaPath + '/type',
            $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
          out += ' if (' + (it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true)) + ') { ';
          if ($coerceToTypes) {
            var $dataType = 'dataType' + $lvl,
              $coerced = 'coerced' + $lvl;
            out += ' var ' + ($dataType) + ' = typeof ' + ($data) + '; var ' + ($coerced) + ' = undefined; ';
            if (it.opts.coerceTypes == 'array') {
              out += ' if (' + ($dataType) + ' == \'object\' && Array.isArray(' + ($data) + ') && ' + ($data) + '.length == 1) { ' + ($data) + ' = ' + ($data) + '[0]; ' + ($dataType) + ' = typeof ' + ($data) + '; if (' + (it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers)) + ') ' + ($coerced) + ' = ' + ($data) + '; } ';
            }
            out += ' if (' + ($coerced) + ' !== undefined) ; ';
            var arr1 = $coerceToTypes;
            if (arr1) {
              var $type, $i = -1,
                l1 = arr1.length - 1;
              while ($i < l1) {
                $type = arr1[$i += 1];
                if ($type == 'string') {
                  out += ' else if (' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\') ' + ($coerced) + ' = \'\' + ' + ($data) + '; else if (' + ($data) + ' === null) ' + ($coerced) + ' = \'\'; ';
                } else if ($type == 'number' || $type == 'integer') {
                  out += ' else if (' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' === null || (' + ($dataType) + ' == \'string\' && ' + ($data) + ' && ' + ($data) + ' == +' + ($data) + ' ';
                  if ($type == 'integer') {
                    out += ' && !(' + ($data) + ' % 1)';
                  }
                  out += ')) ' + ($coerced) + ' = +' + ($data) + '; ';
                } else if ($type == 'boolean') {
                  out += ' else if (' + ($data) + ' === \'false\' || ' + ($data) + ' === 0 || ' + ($data) + ' === null) ' + ($coerced) + ' = false; else if (' + ($data) + ' === \'true\' || ' + ($data) + ' === 1) ' + ($coerced) + ' = true; ';
                } else if ($type == 'null') {
                  out += ' else if (' + ($data) + ' === \'\' || ' + ($data) + ' === 0 || ' + ($data) + ' === false) ' + ($coerced) + ' = null; ';
                } else if (it.opts.coerceTypes == 'array' && $type == 'array') {
                  out += ' else if (' + ($dataType) + ' == \'string\' || ' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' == null) ' + ($coerced) + ' = [' + ($data) + ']; ';
                }
              }
            }
            out += ' else {   ';
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
              if ($typeIsArray) {
                out += '' + ($typeSchema.join(","));
              } else {
                out += '' + ($typeSchema);
              }
              out += '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should be ';
                if ($typeIsArray) {
                  out += '' + ($typeSchema.join(","));
                } else {
                  out += '' + ($typeSchema);
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + (__err) + ']); ';
              } else {
                out += ' validate.errors = [' + (__err) + ']; return false; ';
              }
            } else {
              out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
            out += ' } if (' + ($coerced) + ' !== undefined) {  ';
            var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
              $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
            out += ' ' + ($data) + ' = ' + ($coerced) + '; ';
            if (!$dataLvl) {
              out += 'if (' + ($parentData) + ' !== undefined)';
            }
            out += ' ' + ($parentData) + '[' + ($parentDataProperty) + '] = ' + ($coerced) + '; } ';
          } else {
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
              if ($typeIsArray) {
                out += '' + ($typeSchema.join(","));
              } else {
                out += '' + ($typeSchema);
              }
              out += '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should be ';
                if ($typeIsArray) {
                  out += '' + ($typeSchema.join(","));
                } else {
                  out += '' + ($typeSchema);
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + (__err) + ']); ';
              } else {
                out += ' validate.errors = [' + (__err) + ']; return false; ';
              }
            } else {
              out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
          }
          out += ' } ';
        }
      }
      if (it.schema.$ref && !$refKeywords) {
        out += ' ' + (it.RULES.all.$ref.code(it, '$ref')) + ' ';
        if ($breakOnError) {
          out += ' } if (errors === ';
          if ($top) {
            out += '0';
          } else {
            out += 'errs_' + ($lvl);
          }
          out += ') { ';
          $closingBraces2 += '}';
        }
      } else {
        var arr2 = it.RULES;
        if (arr2) {
          var $rulesGroup, i2 = -1,
            l2 = arr2.length - 1;
          while (i2 < l2) {
            $rulesGroup = arr2[i2 += 1];
            if ($shouldUseGroup($rulesGroup)) {
              if ($rulesGroup.type) {
                out += ' if (' + (it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers)) + ') { ';
              }
              if (it.opts.useDefaults) {
                if ($rulesGroup.type == 'object' && it.schema.properties) {
                  var $schema = it.schema.properties,
                    $schemaKeys = Object.keys($schema);
                  var arr3 = $schemaKeys;
                  if (arr3) {
                    var $propertyKey, i3 = -1,
                      l3 = arr3.length - 1;
                    while (i3 < l3) {
                      $propertyKey = arr3[i3 += 1];
                      var $sch = $schema[$propertyKey];
                      if ($sch.default !== undefined) {
                        var $passData = $data + it.util.getProperty($propertyKey);
                        if (it.compositeRule) {
                          if (it.opts.strictDefaults) {
                            var $defaultMsg = 'default is ignored for: ' + $passData;
                            if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
                            else throw new Error($defaultMsg);
                          }
                        } else {
                          out += ' if (' + ($passData) + ' === undefined ';
                          if (it.opts.useDefaults == 'empty') {
                            out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \'\' ';
                          }
                          out += ' ) ' + ($passData) + ' = ';
                          if (it.opts.useDefaults == 'shared') {
                            out += ' ' + (it.useDefault($sch.default)) + ' ';
                          } else {
                            out += ' ' + (JSON.stringify($sch.default)) + ' ';
                          }
                          out += '; ';
                        }
                      }
                    }
                  }
                } else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) {
                  var arr4 = it.schema.items;
                  if (arr4) {
                    var $sch, $i = -1,
                      l4 = arr4.length - 1;
                    while ($i < l4) {
                      $sch = arr4[$i += 1];
                      if ($sch.default !== undefined) {
                        var $passData = $data + '[' + $i + ']';
                        if (it.compositeRule) {
                          if (it.opts.strictDefaults) {
                            var $defaultMsg = 'default is ignored for: ' + $passData;
                            if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
                            else throw new Error($defaultMsg);
                          }
                        } else {
                          out += ' if (' + ($passData) + ' === undefined ';
                          if (it.opts.useDefaults == 'empty') {
                            out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \'\' ';
                          }
                          out += ' ) ' + ($passData) + ' = ';
                          if (it.opts.useDefaults == 'shared') {
                            out += ' ' + (it.useDefault($sch.default)) + ' ';
                          } else {
                            out += ' ' + (JSON.stringify($sch.default)) + ' ';
                          }
                          out += '; ';
                        }
                      }
                    }
                  }
                }
              }
              var arr5 = $rulesGroup.rules;
              if (arr5) {
                var $rule, i5 = -1,
                  l5 = arr5.length - 1;
                while (i5 < l5) {
                  $rule = arr5[i5 += 1];
                  if ($shouldUseRule($rule)) {
                    var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                    if ($code) {
                      out += ' ' + ($code) + ' ';
                      if ($breakOnError) {
                        $closingBraces1 += '}';
                      }
                    }
                  }
                }
              }
              if ($breakOnError) {
                out += ' ' + ($closingBraces1) + ' ';
                $closingBraces1 = '';
              }
              if ($rulesGroup.type) {
                out += ' } ';
                if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
                  out += ' else { ';
                  var $schemaPath = it.schemaPath + '.type',
                    $errSchemaPath = it.errSchemaPath + '/type';
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = ''; /* istanbul ignore else */
                  if (it.createErrors !== false) {
                    out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
                    if ($typeIsArray) {
                      out += '' + ($typeSchema.join(","));
                    } else {
                      out += '' + ($typeSchema);
                    }
                    out += '\' } ';
                    if (it.opts.messages !== false) {
                      out += ' , message: \'should be ';
                      if ($typeIsArray) {
                        out += '' + ($typeSchema.join(","));
                      } else {
                        out += '' + ($typeSchema);
                      }
                      out += '\' ';
                    }
                    if (it.opts.verbose) {
                      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                    }
                    out += ' } ';
                  } else {
                    out += ' {} ';
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */
                    if (it.async) {
                      out += ' throw new ValidationError([' + (__err) + ']); ';
                    } else {
                      out += ' validate.errors = [' + (__err) + ']; return false; ';
                    }
                  } else {
                    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                  }
                  out += ' } ';
                }
              }
              if ($breakOnError) {
                out += ' if (errors === ';
                if ($top) {
                  out += '0';
                } else {
                  out += 'errs_' + ($lvl);
                }
                out += ') { ';
                $closingBraces2 += '}';
              }
            }
          }
        }
      }
      if ($breakOnError) {
        out += ' ' + ($closingBraces2) + ' ';
      }
      if ($top) {
        if ($async) {
          out += ' if (errors === 0) return data;           ';
          out += ' else throw new ValidationError(vErrors); ';
        } else {
          out += ' validate.errors = vErrors; ';
          out += ' return errors === 0;       ';
        }
        out += ' }; return validate;';
      } else {
        out += ' var ' + ($valid) + ' = errors === errs_' + ($lvl) + ';';
      }

      function $shouldUseGroup($rulesGroup) {
        var rules = $rulesGroup.rules;
        for (var i = 0; i < rules.length; i++)
          if ($shouldUseRule(rules[i])) return true;
      }

      function $shouldUseRule($rule) {
        return it.schema[$rule.keyword] !== undefined || ($rule.implements && $ruleImplementsSomeKeyword($rule));
      }

      function $ruleImplementsSomeKeyword($rule) {
        var impl = $rule.implements;
        for (var i = 0; i < impl.length; i++)
          if (it.schema[impl[i]] !== undefined) return true;
      }
      return out;
    }

  }, {}], "qdYs": [function (require, module, exports) {
    'use strict';

    var resolve = require('./resolve')
      , util = require('./util')
      , errorClasses = require('./error_classes')
      , stableStringify = require('fast-json-stable-stringify');

    var validateGenerator = require('../dotjs/validate');

    /**
     * Functions below are used inside compiled validations function
     */

    var ucs2length = util.ucs2length;
    var equal = require('fast-deep-equal');

    // this error is thrown by async schemas to return validation errors via exception
    var ValidationError = errorClasses.Validation;

    module.exports = compile;


    /**
     * Compiles schema to validation function
     * @this   Ajv
     * @param  {Object} schema schema object
     * @param  {Object} root object with information about the root schema for this schema
     * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
     * @param  {String} baseId base ID for IDs in the schema
     * @return {Function} validation function
     */
    function compile(schema, root, localRefs, baseId) {
      /* jshint validthis: true, evil: true */
      /* eslint no-shadow: 0 */
      var self = this
        , opts = this._opts
        , refVal = [undefined]
        , refs = {}
        , patterns = []
        , patternsHash = {}
        , defaults = []
        , defaultsHash = {}
        , customRules = [];

      root = root || { schema: schema, refVal: refVal, refs: refs };

      var c = checkCompiling.call(this, schema, root, baseId);
      var compilation = this._compilations[c.index];
      if (c.compiling) return (compilation.callValidate = callValidate);

      var formats = this._formats;
      var RULES = this.RULES;

      try {
        var v = localCompile(schema, root, localRefs, baseId);
        compilation.validate = v;
        var cv = compilation.callValidate;
        if (cv) {
          cv.schema = v.schema;
          cv.errors = null;
          cv.refs = v.refs;
          cv.refVal = v.refVal;
          cv.root = v.root;
          cv.$async = v.$async;
          if (opts.sourceCode) cv.source = v.source;
        }
        return v;
      } finally {
        endCompiling.call(this, schema, root, baseId);
      }

      /* @this   {*} - custom context, see passContext option */
      function callValidate() {
        /* jshint validthis: true */
        var validate = compilation.validate;
        var result = validate.apply(this, arguments);
        callValidate.errors = validate.errors;
        return result;
      }

      function localCompile(_schema, _root, localRefs, baseId) {
        var isRoot = !_root || (_root && _root.schema == _schema);
        if (_root.schema != root.schema)
          return compile.call(self, _schema, _root, localRefs, baseId);

        var $async = _schema.$async === true;

        var sourceCode = validateGenerator({
          isTop: true,
          schema: _schema,
          isRoot: isRoot,
          baseId: baseId,
          root: _root,
          schemaPath: '',
          errSchemaPath: '#',
          errorPath: '""',
          MissingRefError: errorClasses.MissingRef,
          RULES: RULES,
          validate: validateGenerator,
          util: util,
          resolve: resolve,
          resolveRef: resolveRef,
          usePattern: usePattern,
          useDefault: useDefault,
          useCustomRule: useCustomRule,
          opts: opts,
          formats: formats,
          logger: self.logger,
          self: self
        });

        sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)
          + vars(defaults, defaultCode) + vars(customRules, customRuleCode)
          + sourceCode;

        if (opts.processCode) sourceCode = opts.processCode(sourceCode, _schema);
        // console.log('\n\n\n *** \n', JSON.stringify(sourceCode));
        var validate;
        try {
          var makeValidate = new Function(
            'self',
            'RULES',
            'formats',
            'root',
            'refVal',
            'defaults',
            'customRules',
            'equal',
            'ucs2length',
            'ValidationError',
            sourceCode
          );

          validate = makeValidate(
            self,
            RULES,
            formats,
            root,
            refVal,
            defaults,
            customRules,
            equal,
            ucs2length,
            ValidationError
          );

          refVal[0] = validate;
        } catch (e) {
          self.logger.error('Error compiling schema, function code:', sourceCode);
          throw e;
        }

        validate.schema = _schema;
        validate.errors = null;
        validate.refs = refs;
        validate.refVal = refVal;
        validate.root = isRoot ? validate : _root;
        if ($async) validate.$async = true;
        if (opts.sourceCode === true) {
          validate.source = {
            code: sourceCode,
            patterns: patterns,
            defaults: defaults
          };
        }

        return validate;
      }

      function resolveRef(baseId, ref, isRoot) {
        ref = resolve.url(baseId, ref);
        var refIndex = refs[ref];
        var _refVal, refCode;
        if (refIndex !== undefined) {
          _refVal = refVal[refIndex];
          refCode = 'refVal[' + refIndex + ']';
          return resolvedRef(_refVal, refCode);
        }
        if (!isRoot && root.refs) {
          var rootRefId = root.refs[ref];
          if (rootRefId !== undefined) {
            _refVal = root.refVal[rootRefId];
            refCode = addLocalRef(ref, _refVal);
            return resolvedRef(_refVal, refCode);
          }
        }

        refCode = addLocalRef(ref);
        var v = resolve.call(self, localCompile, root, ref);
        if (v === undefined) {
          var localSchema = localRefs && localRefs[ref];
          if (localSchema) {
            v = resolve.inlineRef(localSchema, opts.inlineRefs)
              ? localSchema
              : compile.call(self, localSchema, root, localRefs, baseId);
          }
        }

        if (v === undefined) {
          removeLocalRef(ref);
        } else {
          replaceLocalRef(ref, v);
          return resolvedRef(v, refCode);
        }
      }

      function addLocalRef(ref, v) {
        var refId = refVal.length;
        refVal[refId] = v;
        refs[ref] = refId;
        return 'refVal' + refId;
      }

      function removeLocalRef(ref) {
        delete refs[ref];
      }

      function replaceLocalRef(ref, v) {
        var refId = refs[ref];
        refVal[refId] = v;
      }

      function resolvedRef(refVal, code) {
        return typeof refVal == 'object' || typeof refVal == 'boolean'
          ? { code: code, schema: refVal, inline: true }
          : { code: code, $async: refVal && !!refVal.$async };
      }

      function usePattern(regexStr) {
        var index = patternsHash[regexStr];
        if (index === undefined) {
          index = patternsHash[regexStr] = patterns.length;
          patterns[index] = regexStr;
        }
        return 'pattern' + index;
      }

      function useDefault(value) {
        switch (typeof value) {
          case 'boolean':
          case 'number':
            return '' + value;
          case 'string':
            return util.toQuotedString(value);
          case 'object':
            if (value === null) return 'null';
            var valueStr = stableStringify(value);
            var index = defaultsHash[valueStr];
            if (index === undefined) {
              index = defaultsHash[valueStr] = defaults.length;
              defaults[index] = value;
            }
            return 'default' + index;
        }
      }

      function useCustomRule(rule, schema, parentSchema, it) {
        if (self._opts.validateSchema !== false) {
          var deps = rule.definition.dependencies;
          if (deps && !deps.every(function (keyword) {
            return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
          }))
            throw new Error('parent schema must have all required keywords: ' + deps.join(','));

          var validateSchema = rule.definition.validateSchema;
          if (validateSchema) {
            var valid = validateSchema(schema);
            if (!valid) {
              var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);
              if (self._opts.validateSchema == 'log') self.logger.error(message);
              else throw new Error(message);
            }
          }
        }

        var compile = rule.definition.compile
          , inline = rule.definition.inline
          , macro = rule.definition.macro;

        var validate;
        if (compile) {
          validate = compile.call(self, schema, parentSchema, it);
        } else if (macro) {
          validate = macro.call(self, schema, parentSchema, it);
          if (opts.validateSchema !== false) self.validateSchema(validate, true);
        } else if (inline) {
          validate = inline.call(self, it, rule.keyword, schema, parentSchema);
        } else {
          validate = rule.definition.validate;
          if (!validate) return;
        }

        if (validate === undefined)
          throw new Error('custom keyword "' + rule.keyword + '"failed to compile');

        var index = customRules.length;
        customRules[index] = validate;

        return {
          code: 'customRule' + index,
          validate: validate
        };
      }
    }


    /**
     * Checks if the schema is currently compiled
     * @this   Ajv
     * @param  {Object} schema schema to compile
     * @param  {Object} root root object
     * @param  {String} baseId base schema ID
     * @return {Object} object with properties "index" (compilation index) and "compiling" (boolean)
     */
    function checkCompiling(schema, root, baseId) {
      /* jshint validthis: true */
      var index = compIndex.call(this, schema, root, baseId);
      if (index >= 0) return { index: index, compiling: true };
      index = this._compilations.length;
      this._compilations[index] = {
        schema: schema,
        root: root,
        baseId: baseId
      };
      return { index: index, compiling: false };
    }


    /**
     * Removes the schema from the currently compiled list
     * @this   Ajv
     * @param  {Object} schema schema to compile
     * @param  {Object} root root object
     * @param  {String} baseId base schema ID
     */
    function endCompiling(schema, root, baseId) {
      /* jshint validthis: true */
      var i = compIndex.call(this, schema, root, baseId);
      if (i >= 0) this._compilations.splice(i, 1);
    }


    /**
     * Index of schema compilation in the currently compiled list
     * @this   Ajv
     * @param  {Object} schema schema to compile
     * @param  {Object} root root object
     * @param  {String} baseId base schema ID
     * @return {Integer} compilation index
     */
    function compIndex(schema, root, baseId) {
      /* jshint validthis: true */
      for (var i = 0; i < this._compilations.length; i++) {
        var c = this._compilations[i];
        if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
      }
      return -1;
    }


    function patternCode(i, patterns) {
      return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';
    }


    function defaultCode(i) {
      return 'var default' + i + ' = defaults[' + i + '];';
    }


    function refValCode(i, refVal) {
      return refVal[i] === undefined ? '' : 'var refVal' + i + ' = refVal[' + i + '];';
    }


    function customRuleCode(i) {
      return 'var customRule' + i + ' = customRules[' + i + '];';
    }


    function vars(arr, statement) {
      if (!arr.length) return '';
      var code = '';
      for (var i = 0; i < arr.length; i++)
        code += statement(i, arr);
      return code;
    }

  }, { "./resolve": "w10T", "./util": "Q1F7", "./error_classes": "OtNE", "fast-json-stable-stringify": "Xb3N", "../dotjs/validate": "yhC1", "fast-deep-equal": "dPQH" }], "fXCy": [function (require, module, exports) {
    'use strict';


    var Cache = module.exports = function Cache() {
      this._cache = {};
    };


    Cache.prototype.put = function Cache_put(key, value) {
      this._cache[key] = value;
    };


    Cache.prototype.get = function Cache_get(key) {
      return this._cache[key];
    };


    Cache.prototype.del = function Cache_del(key) {
      delete this._cache[key];
    };


    Cache.prototype.clear = function Cache_clear() {
      this._cache = {};
    };

  }, {}], "dfAH": [function (require, module, exports) {
    'use strict';

    var util = require('./util');

    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
    var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    // uri-template: https://tools.ietf.org/html/rfc6570
    var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
    // For the source: https://gist.github.com/dperini/729294
    // For test cases: https://mathiasbynens.be/demo/url-regex
    // @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.
    // var URL = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
    var URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
    var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
    var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
    var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
    var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;


    module.exports = formats;

    function formats(mode) {
      mode = mode == 'full' ? 'full' : 'fast';
      return util.copy(formats[mode]);
    }


    formats.fast = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
      'date-time': /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      'uri-reference': /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      'uri-template': URITEMPLATE,
      url: URL,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
      hostname: HOSTNAME,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex: regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: UUID,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      'json-pointer': JSON_POINTER,
      'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      'relative-json-pointer': RELATIVE_JSON_POINTER
    };


    formats.full = {
      date: date,
      time: time,
      'date-time': date_time,
      uri: uri,
      'uri-reference': URIREF,
      'uri-template': URITEMPLATE,
      url: URL,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: HOSTNAME,
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex: regex,
      uuid: UUID,
      'json-pointer': JSON_POINTER,
      'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
      'relative-json-pointer': RELATIVE_JSON_POINTER
    };


    function isLeapYear(year) {
      // https://tools.ietf.org/html/rfc3339#appendix-C
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }


    function date(str) {
      // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
      var matches = str.match(DATE);
      if (!matches) return false;

      var year = +matches[1];
      var month = +matches[2];
      var day = +matches[3];

      return month >= 1 && month <= 12 && day >= 1 &&
        day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }


    function time(str, full) {
      var matches = str.match(TIME);
      if (!matches) return false;

      var hour = matches[1];
      var minute = matches[2];
      var second = matches[3];
      var timeZone = matches[5];
      return ((hour <= 23 && minute <= 59 && second <= 59) ||
        (hour == 23 && minute == 59 && second == 60)) &&
        (!full || timeZone);
    }


    var DATE_TIME_SEPARATOR = /t|\s/i;
    function date_time(str) {
      // http://tools.ietf.org/html/rfc3339#section-5.6
      var dateTime = str.split(DATE_TIME_SEPARATOR);
      return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
    }


    var NOT_URI_FRAGMENT = /\/|:/;
    function uri(str) {
      // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }


    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str)) return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }

  }, { "./util": "Q1F7" }], "a2na": [function (require, module, exports) {
    'use strict';
    module.exports = function generate_ref(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $async, $refCode;
      if ($schema == '#' || $schema == '#/') {
        if (it.isRoot) {
          $async = it.async;
          $refCode = 'validate';
        } else {
          $async = it.root.schema.$async === true;
          $refCode = 'root.refVal[0]';
        }
      } else {
        var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
        if ($refVal === undefined) {
          var $message = it.MissingRefError.message(it.baseId, $schema);
          if (it.opts.missingRefs == 'fail') {
            it.logger.error($message);
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ('$ref') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { ref: \'' + (it.util.escapeQuotes($schema)) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'can\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + (__err) + ']); ';
              } else {
                out += ' validate.errors = [' + (__err) + ']; return false; ';
              }
            } else {
              out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
            if ($breakOnError) {
              out += ' if (false) { ';
            }
          } else if (it.opts.missingRefs == 'ignore') {
            it.logger.warn($message);
            if ($breakOnError) {
              out += ' if (true) { ';
            }
          } else {
            throw new it.MissingRefError(it.baseId, $schema, $message);
          }
        } else if ($refVal.inline) {
          var $it = it.util.copy(it);
          $it.level++;
          var $nextValid = 'valid' + $it.level;
          $it.schema = $refVal.schema;
          $it.schemaPath = '';
          $it.errSchemaPath = $schema;
          var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
          out += ' ' + ($code) + ' ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
          }
        } else {
          $async = $refVal.$async === true || (it.async && $refVal.$async !== false);
          $refCode = $refVal.code;
        }
      }
      if ($refCode) {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = '';
        if (it.opts.passContext) {
          out += ' ' + ($refCode) + '.call(this, ';
        } else {
          out += ' ' + ($refCode) + '( ';
        }
        out += ' ' + ($data) + ', (dataPath || \'\')';
        if (it.errorPath != '""') {
          out += ' + ' + (it.errorPath);
        }
        var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
          $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
        out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ', rootData)  ';
        var __callValidate = out;
        out = $$outStack.pop();
        if ($async) {
          if (!it.async) throw new Error('async schema referenced by sync schema');
          if ($breakOnError) {
            out += ' var ' + ($valid) + '; ';
          }
          out += ' try { await ' + (__callValidate) + '; ';
          if ($breakOnError) {
            out += ' ' + ($valid) + ' = true; ';
          }
          out += ' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ';
          if ($breakOnError) {
            out += ' ' + ($valid) + ' = false; ';
          }
          out += ' } ';
          if ($breakOnError) {
            out += ' if (' + ($valid) + ') { ';
          }
        } else {
          out += ' if (!' + (__callValidate) + ') { if (vErrors === null) vErrors = ' + ($refCode) + '.errors; else vErrors = vErrors.concat(' + ($refCode) + '.errors); errors = vErrors.length; } ';
          if ($breakOnError) {
            out += ' else { ';
          }
        }
      }
      return out;
    }

  }, {}], "hRgn": [function (require, module, exports) {
    'use strict';
    module.exports = function generate_allOf(it, $keyword, $ruleType) {
      var out = ' ';
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $it = it.util.copy(it);
      var $closingBraces = '';
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      var $currentBaseId = $it.baseId,
        $allSchemasEmpty = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1,
          l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
            $allSchemasEmpty = false;
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + '[' + $i + ']';
            $it.errSchemaPath = $errSchemaPath + '/' + $i;
            out += '  ' + (it.validate($it)) + ' ';
            $it.baseId = $currentBaseId;
            if ($breakOnError) {
              out += ' if (' + ($nextValid) + ') { ';
              $closingBraces += '}';
            }
          }
        }
      }
      if ($breakOnError) {
        if ($allSchemasEmpty) {
          out += ' if (true) { ';
        } else {
          out += ' ' + ($closingBraces.slice(0, -1)) + ' ';
        }
      }
      return out;
    }

  }, {}], "lo6J": [function (require, module, exports) {
    'use strict';
    module.exports = function generate_anyOf(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $errs = 'errs__' + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = '';
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      var $noEmptySchema = $schema.every(function ($sch) {
        return (it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all));
      });
      if ($noEmptySchema) {
        var $currentBaseId = $it.baseId;
        out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = false;  ';
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1,
            l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + '[' + $i + ']';
            $it.errSchemaPath = $errSchemaPath + '/' + $i;
            out += '  ' + (it.validate($it)) + ' ';
            $it.baseId = $currentBaseId;
            out += ' ' + ($valid) + ' = ' + ($valid) + ' || ' + ($nextValid) + '; if (!' + ($valid) + ') { ';
            $closingBraces += '}';
          }
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += ' ' + ($closingBraces) + ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('anyOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should match some schema in anyOf\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError(vErrors); ';
          } else {
            out += ' validate.errors = vErrors; return false; ';
          }
        }
        out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
        if (it.opts.allErrors) {
          out += ' } ';
        }
      } else {
        if ($breakOnError) {
          out += ' if (true) { ';
        }
      }
      return out;
    }

  }, {}], "Kkzr": [function (require, module, exports) {
    'use strict';
    module.exports = function generate_comment(it, $keyword, $ruleType) {
      var out = ' ';
      var $schema = it.schema[$keyword];
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $comment = it.util.toQuotedString($schema);
      if (it.opts.$comment === true) {
        out += ' console.log(' + ($comment) + ');';
      } else if (typeof it.opts.$comment == 'function') {
        out += ' self._opts.$comment(' + ($comment) + ', ' + (it.util.toQuotedString($errSchemaPath)) + ', validate.root.schema);';
      }
      return out;
    }

  }, {}], "U4sD": [function (require, module, exports) {
    'use strict';
    module.exports = function generate_const(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data,
        $schemaValue;
      if ($isData) {
        out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!$isData) {
        out += ' var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + ';';
      }
      out += 'var ' + ($valid) + ' = equal(' + ($data) + ', schema' + ($lvl) + '); if (!' + ($valid) + ') {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ('const') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValue: schema' + ($lvl) + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should be equal to constant\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' }';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    }

  }, {}], "EypH": [function (require, module, exports) {
    'use strict';
    module.exports = function generate_contains(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $errs = 'errs__' + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = '';
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      var $idx = 'i' + $lvl,
        $dataNxt = $it.dataLevel = it.dataLevel + 1,
        $nextData = 'data' + $dataNxt,
        $currentBaseId = it.baseId,
        $nonEmptySchema = (it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all));
      out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
      if ($nonEmptySchema) {
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += ' var ' + ($nextValid) + ' = false; for (var ' + ($idx) + ' = 0; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + '[' + $idx + ']';
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
        } else {
          out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
        }
        out += ' if (' + ($nextValid) + ') break; }  ';
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += ' ' + ($closingBraces) + ' if (!' + ($nextValid) + ') {';
      } else {
        out += ' if (' + ($data) + '.length == 0) {';
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ('contains') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should contain a valid item\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' } else { ';
      if ($nonEmptySchema) {
        out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
      }
      if (it.opts.allErrors) {
        out += ' } ';
      }
      return out;
    }

  }, {}], "Cpp7": [function (require, module, exports) {
    'use strict';
    module.exports = function generate_dependencies(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $errs = 'errs__' + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = '';
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      var $schemaDeps = {},
        $propertyDeps = {},
        $ownProperties = it.opts.ownProperties;
      for ($property in $schema) {
        if ($property == '__proto__') continue;
        var $sch = $schema[$property];
        var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
        $deps[$property] = $sch;
      }
      out += 'var ' + ($errs) + ' = errors;';
      var $currentErrorPath = it.errorPath;
      out += 'var missing' + ($lvl) + ';';
      for (var $property in $propertyDeps) {
        $deps = $propertyDeps[$property];
        if ($deps.length) {
          out += ' if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
          if ($ownProperties) {
            out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($property)) + '\') ';
          }
          if ($breakOnError) {
            out += ' && ( ';
            var arr1 = $deps;
            if (arr1) {
              var $propertyKey, $i = -1,
                l1 = arr1.length - 1;
              while ($i < l1) {
                $propertyKey = arr1[$i += 1];
                if ($i) {
                  out += ' || ';
                }
                var $prop = it.util.getProperty($propertyKey),
                  $useData = $data + $prop;
                out += ' ( ( ' + ($useData) + ' === undefined ';
                if ($ownProperties) {
                  out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                }
                out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
              }
            }
            out += ')) {  ';
            var $propertyPath = 'missing' + $lvl,
              $missingProperty = '\' + ' + $propertyPath + ' + \'';
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ('dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should have ';
                if ($deps.length == 1) {
                  out += 'property ' + (it.util.escapeQuotes($deps[0]));
                } else {
                  out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
                }
                out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + (__err) + ']); ';
              } else {
                out += ' validate.errors = [' + (__err) + ']; return false; ';
              }
            } else {
              out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
          } else {
            out += ' ) { ';
            var arr2 = $deps;
            if (arr2) {
              var $propertyKey, i2 = -1,
                l2 = arr2.length - 1;
              while (i2 < l2) {
                $propertyKey = arr2[i2 += 1];
                var $prop = it.util.getProperty($propertyKey),
                  $missingProperty = it.util.escapeQuotes($propertyKey),
                  $useData = $data + $prop;
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                out += ' if ( ' + ($useData) + ' === undefined ';
                if ($ownProperties) {
                  out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                }
                out += ') {  var err =   '; /* istanbul ignore else */
                if (it.createErrors !== false) {
                  out += ' { keyword: \'' + ('dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
                  if (it.opts.messages !== false) {
                    out += ' , message: \'should have ';
                    if ($deps.length == 1) {
                      out += 'property ' + (it.util.escapeQuotes($deps[0]));
                    } else {
                      out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
                    }
                    out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
                  }
                  if (it.opts.verbose) {
                    out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                  }
                  out += ' } ';
                } else {
                  out += ' {} ';
                }
                out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
              }
            }
          }
          out += ' }   ';
          if ($breakOnError) {
            $closingBraces += '}';
            out += ' else { ';
          }
        }
      }
      it.errorPath = $currentErrorPath;
      var $currentBaseId = $it.baseId;
      for (var $property in $schemaDeps) {
        var $sch = $schemaDeps[$property];
        if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
          out += ' ' + ($nextValid) + ' = true; if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
          if ($ownProperties) {
            out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($property)) + '\') ';
          }
          out += ') { ';
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + it.util.getProperty($property);
          $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);
          out += '  ' + (it.validate($it)) + ' ';
          $it.baseId = $currentBaseId;
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
            $closingBraces += '}';
          }
        }
      }
      if ($breakOnError) {
        out += '   ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
      }
      return out;
    }

  }, {}], "fqDY": [function (require, module, exports) {
    'use strict';
    module.exports = function generate_enum(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data,
        $schemaValue;
      if ($isData) {
        out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $i = 'i' + $lvl,
        $vSchema = 'schema' + $lvl;
      if (!$isData) {
        out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + ';';
      }
      out += 'var ' + ($valid) + ';';
      if ($isData) {
        out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
      }
      out += '' + ($valid) + ' = false;for (var ' + ($i) + '=0; ' + ($i) + '<' + ($vSchema) + '.length; ' + ($i) + '++) if (equal(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + '])) { ' + ($valid) + ' = true; break; }';
      if ($isData) {
        out += '  }  ';
      }
      out += ' if (!' + ($valid) + ') {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ('enum') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValues: schema' + ($lvl) + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should be equal to one of the allowed values\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' }';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    }

  }, {}], "avoW": [function (require, module, exports) {
    'use strict';
    module.exports = function generate_format(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      if (it.opts.format === false) {
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      }
      var $isData = it.opts.$data && $schema && $schema.$data,
        $schemaValue;
      if ($isData) {
        out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $unknownFormats = it.opts.unknownFormats,
        $allowUnknown = Array.isArray($unknownFormats);
      if ($isData) {
        var $format = 'format' + $lvl,
          $isObject = 'isObject' + $lvl,
          $formatType = 'formatType' + $lvl;
        out += ' var ' + ($format) + ' = formats[' + ($schemaValue) + ']; var ' + ($isObject) + ' = typeof ' + ($format) + ' == \'object\' && !(' + ($format) + ' instanceof RegExp) && ' + ($format) + '.validate; var ' + ($formatType) + ' = ' + ($isObject) + ' && ' + ($format) + '.type || \'string\'; if (' + ($isObject) + ') { ';
        if (it.async) {
          out += ' var async' + ($lvl) + ' = ' + ($format) + '.async; ';
        }
        out += ' ' + ($format) + ' = ' + ($format) + '.validate; } if (  ';
        if ($isData) {
          out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
        }
        out += ' (';
        if ($unknownFormats != 'ignore') {
          out += ' (' + ($schemaValue) + ' && !' + ($format) + ' ';
          if ($allowUnknown) {
            out += ' && self._opts.unknownFormats.indexOf(' + ($schemaValue) + ') == -1 ';
          }
          out += ') || ';
        }
        out += ' (' + ($format) + ' && ' + ($formatType) + ' == \'' + ($ruleType) + '\' && !(typeof ' + ($format) + ' == \'function\' ? ';
        if (it.async) {
          out += ' (async' + ($lvl) + ' ? await ' + ($format) + '(' + ($data) + ') : ' + ($format) + '(' + ($data) + ')) ';
        } else {
          out += ' ' + ($format) + '(' + ($data) + ') ';
        }
        out += ' : ' + ($format) + '.test(' + ($data) + '))))) {';
      } else {
        var $format = it.formats[$schema];
        if (!$format) {
          if ($unknownFormats == 'ignore') {
            it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
            if ($breakOnError) {
              out += ' if (true) { ';
            }
            return out;
          } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
            if ($breakOnError) {
              out += ' if (true) { ';
            }
            return out;
          } else {
            throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
          }
        }
        var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate;
        var $formatType = $isObject && $format.type || 'string';
        if ($isObject) {
          var $async = $format.async === true;
          $format = $format.validate;
        }
        if ($formatType != $ruleType) {
          if ($breakOnError) {
            out += ' if (true) { ';
          }
          return out;
        }
        if ($async) {
          if (!it.async) throw new Error('async format in sync schema');
          var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';
          out += ' if (!(await ' + ($formatRef) + '(' + ($data) + '))) { ';
        } else {
          out += ' if (! ';
          var $formatRef = 'formats' + it.util.getProperty($schema);
          if ($isObject) $formatRef += '.validate';
          if (typeof $format == 'function') {
            out += ' ' + ($formatRef) + '(' + ($data) + ') ';
          } else {
            out += ' ' + ($formatRef) + '.test(' + ($data) + ') ';
          }
          out += ') { ';
        }
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ('format') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { format:  ';
        if ($isData) {
          out += '' + ($schemaValue);
        } else {
          out += '' + (it.util.toQuotedString($schema));
        }
        out += '  } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should match format "';
          if ($isData) {
            out += '\' + ' + ($schemaValue) + ' + \'';
          } else {
            out += '' + (it.util.escapeQuotes($schema));
          }
          out += '"\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema:  ';
          if ($isData) {
            out += 'validate.schema' + ($schemaPath);
          } else {
            out += '' + (it.util.toQuotedString($schema));
          }
          out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' } ';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    }

  }, {}], "JHQ3": [function (require, module, exports) {
    'use strict';
    module.exports = function generate_if(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $errs = 'errs__' + $lvl;
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      var $thenSch = it.schema['then'],
        $elseSch = it.schema['else'],
        $thenPresent = $thenSch !== undefined && (it.opts.strictKeywords ? (typeof $thenSch == 'object' && Object.keys($thenSch).length > 0) || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)),
        $elsePresent = $elseSch !== undefined && (it.opts.strictKeywords ? (typeof $elseSch == 'object' && Object.keys($elseSch).length > 0) || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)),
        $currentBaseId = $it.baseId;
      if ($thenPresent || $elsePresent) {
        var $ifClause;
        $it.createErrors = false;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = true;  ';
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        $it.createErrors = true;
        out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }  ';
        it.compositeRule = $it.compositeRule = $wasComposite;
        if ($thenPresent) {
          out += ' if (' + ($nextValid) + ') {  ';
          $it.schema = it.schema['then'];
          $it.schemaPath = it.schemaPath + '.then';
          $it.errSchemaPath = it.errSchemaPath + '/then';
          out += '  ' + (it.validate($it)) + ' ';
          $it.baseId = $currentBaseId;
          out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
          if ($thenPresent && $elsePresent) {
            $ifClause = 'ifClause' + $lvl;
            out += ' var ' + ($ifClause) + ' = \'then\'; ';
          } else {
            $ifClause = '\'then\'';
          }
          out += ' } ';
          if ($elsePresent) {
            out += ' else { ';
          }
        } else {
          out += ' if (!' + ($nextValid) + ') { ';
        }
        if ($elsePresent) {
          $it.schema = it.schema['else'];
          $it.schemaPath = it.schemaPath + '.else';
          $it.errSchemaPath = it.errSchemaPath + '/else';
          out += '  ' + (it.validate($it)) + ' ';
          $it.baseId = $currentBaseId;
          out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
          if ($thenPresent && $elsePresent) {
            $ifClause = 'ifClause' + $lvl;
            out += ' var ' + ($ifClause) + ' = \'else\'; ';
          } else {
            $ifClause = '\'else\'';
          }
          out += ' } ';
        }
        out += ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('if') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { failingKeyword: ' + ($ifClause) + ' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should match "\' + ' + ($ifClause) + ' + \'" schema\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError(vErrors); ';
          } else {
            out += ' validate.errors = vErrors; return false; ';
          }
        }
        out += ' }   ';
        if ($breakOnError) {
          out += ' else { ';
        }
      } else {
        if ($breakOnError) {
          out += ' if (true) { ';
        }
      }
      return out;
    }

  }, {}], "aiPb": [function (require, module, exports) {
    'use strict';
    module.exports = function generate_items(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $errs = 'errs__' + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = '';
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      var $idx = 'i' + $lvl,
        $dataNxt = $it.dataLevel = it.dataLevel + 1,
        $nextData = 'data' + $dataNxt,
        $currentBaseId = it.baseId;
      out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
      if (Array.isArray($schema)) {
        var $additionalItems = it.schema.additionalItems;
        if ($additionalItems === false) {
          out += ' ' + ($valid) + ' = ' + ($data) + '.length <= ' + ($schema.length) + '; ';
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + '/additionalItems';
          out += '  if (!' + ($valid) + ') {   ';
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ('additionalItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schema.length) + ' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'should NOT have more than ' + ($schema.length) + ' items\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + (__err) + ']); ';
            } else {
              out += ' validate.errors = [' + (__err) + ']; return false; ';
            }
          } else {
            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          out += ' } ';
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            $closingBraces += '}';
            out += ' else { ';
          }
        }
        var arr1 = $schema;
        if (arr1) {
          var $sch, $i = -1,
            l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
              out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($i) + ') { ';
              var $passData = $data + '[' + $i + ']';
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + '[' + $i + ']';
              $it.errSchemaPath = $errSchemaPath + '/' + $i;
              $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
              $it.dataPathArr[$dataNxt] = $i;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
              } else {
                out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
              }
              out += ' }  ';
              if ($breakOnError) {
                out += ' if (' + ($nextValid) + ') { ';
                $closingBraces += '}';
              }
            }
          }
        }
        if (typeof $additionalItems == 'object' && (it.opts.strictKeywords ? (typeof $additionalItems == 'object' && Object.keys($additionalItems).length > 0) || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
          $it.schema = $additionalItems;
          $it.schemaPath = it.schemaPath + '.additionalItems';
          $it.errSchemaPath = it.errSchemaPath + '/additionalItems';
          out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($schema.length) + ') {  for (var ' + ($idx) + ' = ' + ($schema.length) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
          $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
          var $passData = $data + '[' + $idx + ']';
          $it.dataPathArr[$dataNxt] = $idx;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + ($nextValid) + ') break; ';
          }
          out += ' } }  ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
            $closingBraces += '}';
          }
        }
      } else if ((it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += '  for (var ' + ($idx) + ' = ' + (0) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + '[' + $idx + ']';
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
        } else {
          out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
        }
        if ($breakOnError) {
          out += ' if (!' + ($nextValid) + ') break; ';
        }
        out += ' }';
      }
      if ($breakOnError) {
        out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
      }
      return out;
    }

  }, {}], "UJAl": [function (require, module, exports) {
    'use strict';
    module.exports = function generate__limit(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = 'data' + ($dataLvl || '');
      var $isData = it.opts.$data && $schema && $schema.$data,
        $schemaValue;
      if ($isData) {
        out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $isMax = $keyword == 'maximum',
        $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',
        $schemaExcl = it.schema[$exclusiveKeyword],
        $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,
        $op = $isMax ? '<' : '>',
        $notOp = $isMax ? '>' : '<',
        $errorKeyword = undefined;
      if (!($isData || typeof $schema == 'number' || $schema === undefined)) {
        throw new Error($keyword + ' must be number');
      }
      if (!($isDataExcl || $schemaExcl === undefined || typeof $schemaExcl == 'number' || typeof $schemaExcl == 'boolean')) {
        throw new Error($exclusiveKeyword + ' must be number or boolean');
      }
      if ($isDataExcl) {
        var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
          $exclusive = 'exclusive' + $lvl,
          $exclType = 'exclType' + $lvl,
          $exclIsNumber = 'exclIsNumber' + $lvl,
          $opExpr = 'op' + $lvl,
          $opStr = '\' + ' + $opExpr + ' + \'';
        out += ' var schemaExcl' + ($lvl) + ' = ' + ($schemaValueExcl) + '; ';
        $schemaValueExcl = 'schemaExcl' + $lvl;
        out += ' var ' + ($exclusive) + '; var ' + ($exclType) + ' = typeof ' + ($schemaValueExcl) + '; if (' + ($exclType) + ' != \'boolean\' && ' + ($exclType) + ' != \'undefined\' && ' + ($exclType) + ' != \'number\') { ';
        var $errorKeyword = $exclusiveKeyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || '_exclusiveLimit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
          if (it.opts.messages !== false) {
            out += ' , message: \'' + ($exclusiveKeyword) + ' should be boolean\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else if ( ';
        if ($isData) {
          out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
        }
        out += ' ' + ($exclType) + ' == \'number\' ? ( (' + ($exclusive) + ' = ' + ($schemaValue) + ' === undefined || ' + ($schemaValueExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ') ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValueExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) : ( (' + ($exclusive) + ' = ' + ($schemaValueExcl) + ' === true) ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValue) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { var op' + ($lvl) + ' = ' + ($exclusive) + ' ? \'' + ($op) + '\' : \'' + ($op) + '=\'; ';
        if ($schema === undefined) {
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
          $schemaValue = $schemaValueExcl;
          $isData = $isDataExcl;
        }
      } else {
        var $exclIsNumber = typeof $schemaExcl == 'number',
          $opStr = $op;
        if ($exclIsNumber && $isData) {
          var $opExpr = '\'' + $opStr + '\'';
          out += ' if ( ';
          if ($isData) {
            out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
          }
          out += ' ( ' + ($schemaValue) + ' === undefined || ' + ($schemaExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ' ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { ';
        } else {
          if ($exclIsNumber && $schema === undefined) {
            $exclusive = true;
            $errorKeyword = $exclusiveKeyword;
            $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
            $schemaValue = $schemaExcl;
            $notOp += '=';
          } else {
            if ($exclIsNumber) $schemaValue = Math[$isMax ? 'min' : 'max']($schemaExcl, $schema);
            if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
              $exclusive = true;
              $errorKeyword = $exclusiveKeyword;
              $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
              $notOp += '=';
            } else {
              $exclusive = false;
              $opStr += '=';
            }
          }
          var $opExpr = '\'' + $opStr + '\'';
          out += ' if ( ';
          if ($isData) {
            out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
          }
          out += ' ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' || ' + ($data) + ' !== ' + ($data) + ') { ';
        }
      }
      $errorKeyword = $errorKeyword || $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || '_limit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { comparison: ' + ($opExpr) + ', limit: ' + ($schemaValue) + ', exclusive: ' + ($exclusive) + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should be ' + ($opStr) + ' ';
          if ($isData) {
            out += '\' + ' + ($schemaValue);
          } else {
            out += '' + ($schemaValue) + '\'';
          }
        }
        if (it.opts.verbose) {
          out += ' , schema:  ';
          if ($isData) {
            out += 'validate.schema' + ($schemaPath);
          } else {
            out += '' + ($schema);
          }
          out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' } ';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    }

  }, {}], "W8ih": [function (require, module, exports) {
    'use strict';
    module.exports = function generate__limitItems(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = 'data' + ($dataLvl || '');
      var $isData = it.opts.$data && $schema && $schema.$data,
        $schemaValue;
      if ($isData) {
        out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == 'number')) {
        throw new Error($keyword + ' must be number');
      }
      var $op = $keyword == 'maxItems' ? '>' : '<';
      out += 'if ( ';
      if ($isData) {
        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
      }
      out += ' ' + ($data) + '.length ' + ($op) + ' ' + ($schemaValue) + ') { ';
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || '_limitItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should NOT have ';
          if ($keyword == 'maxItems') {
            out += 'more';
          } else {
            out += 'fewer';
          }
          out += ' than ';
          if ($isData) {
            out += '\' + ' + ($schemaValue) + ' + \'';
          } else {
            out += '' + ($schema);
          }
          out += ' items\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema:  ';
          if ($isData) {
            out += 'validate.schema' + ($schemaPath);
          } else {
            out += '' + ($schema);
          }
          out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += '} ';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    }

  }, {}], "fZGX": [function (require, module, exports) {
    'use strict';
    module.exports = function generate__limitLength(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = 'data' + ($dataLvl || '');
      var $isData = it.opts.$data && $schema && $schema.$data,
        $schemaValue;
      if ($isData) {
        out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == 'number')) {
        throw new Error($keyword + ' must be number');
      }
      var $op = $keyword == 'maxLength' ? '>' : '<';
      out += 'if ( ';
      if ($isData) {
        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
      }
      if (it.opts.unicode === false) {
        out += ' ' + ($data) + '.length ';
      } else {
        out += ' ucs2length(' + ($data) + ') ';
      }
      out += ' ' + ($op) + ' ' + ($schemaValue) + ') { ';
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || '_limitLength') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should NOT be ';
          if ($keyword == 'maxLength') {
            out += 'longer';
          } else {
            out += 'shorter';
          }
          out += ' than ';
          if ($isData) {
            out += '\' + ' + ($schemaValue) + ' + \'';
          } else {
            out += '' + ($schema);
          }
          out += ' characters\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema:  ';
          if ($isData) {
            out += 'validate.schema' + ($schemaPath);
          } else {
            out += '' + ($schema);
          }
          out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += '} ';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    }

  }, {}], "JAEr": [function (require, module, exports) {
    'use strict';
    module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = 'data' + ($dataLvl || '');
      var $isData = it.opts.$data && $schema && $schema.$data,
        $schemaValue;
      if ($isData) {
        out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == 'number')) {
        throw new Error($keyword + ' must be number');
      }
      var $op = $keyword == 'maxProperties' ? '>' : '<';
      out += 'if ( ';
      if ($isData) {
        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
      }
      out += ' Object.keys(' + ($data) + ').length ' + ($op) + ' ' + ($schemaValue) + ') { ';
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || '_limitProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should NOT have ';
          if ($keyword == 'maxProperties') {
            out += 'more';
          } else {
            out += 'fewer';
          }
          out += ' than ';
          if ($isData) {
            out += '\' + ' + ($schemaValue) + ' + \'';
          } else {
            out += '' + ($schema);
          }
          out += ' properties\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema:  ';
          if ($isData) {
            out += 'validate.schema' + ($schemaPath);
          } else {
            out += '' + ($schema);
          }
          out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += '} ';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    }

  }, {}], "oNPH": [function (require, module, exports) {
    'use strict';
    module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $isData = it.opts.$data && $schema && $schema.$data,
        $schemaValue;
      if ($isData) {
        out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!($isData || typeof $schema == 'number')) {
        throw new Error($keyword + ' must be number');
      }
      out += 'var division' + ($lvl) + ';if (';
      if ($isData) {
        out += ' ' + ($schemaValue) + ' !== undefined && ( typeof ' + ($schemaValue) + ' != \'number\' || ';
      }
      out += ' (division' + ($lvl) + ' = ' + ($data) + ' / ' + ($schemaValue) + ', ';
      if (it.opts.multipleOfPrecision) {
        out += ' Math.abs(Math.round(division' + ($lvl) + ') - division' + ($lvl) + ') > 1e-' + (it.opts.multipleOfPrecision) + ' ';
      } else {
        out += ' division' + ($lvl) + ' !== parseInt(division' + ($lvl) + ') ';
      }
      out += ' ) ';
      if ($isData) {
        out += '  )  ';
      }
      out += ' ) {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ('multipleOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { multipleOf: ' + ($schemaValue) + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should be multiple of ';
          if ($isData) {
            out += '\' + ' + ($schemaValue);
          } else {
            out += '' + ($schemaValue) + '\'';
          }
        }
        if (it.opts.verbose) {
          out += ' , schema:  ';
          if ($isData) {
            out += 'validate.schema' + ($schemaPath);
          } else {
            out += '' + ($schema);
          }
          out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += '} ';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    }

  }, {}], "mmjm": [function (require, module, exports) {
    'use strict';
    module.exports = function generate_not(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $errs = 'errs__' + $lvl;
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      if ((it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += ' var ' + ($errs) + ' = errors;  ';
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.createErrors = false;
        var $allErrorsOption;
        if ($it.opts.allErrors) {
          $allErrorsOption = $it.opts.allErrors;
          $it.opts.allErrors = false;
        }
        out += ' ' + (it.validate($it)) + ' ';
        $it.createErrors = true;
        if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += ' if (' + ($nextValid) + ') {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should NOT be valid\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
        if (it.opts.allErrors) {
          out += ' } ';
        }
      } else {
        out += '  var err =   '; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should NOT be valid\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        if ($breakOnError) {
          out += ' if (false) { ';
        }
      }
      return out;
    }

  }, {}], "SSWF": [function (require, module, exports) {
    'use strict';
    module.exports = function generate_oneOf(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $errs = 'errs__' + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = '';
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      var $currentBaseId = $it.baseId,
        $prevValid = 'prevValid' + $lvl,
        $passingSchemas = 'passingSchemas' + $lvl;
      out += 'var ' + ($errs) + ' = errors , ' + ($prevValid) + ' = false , ' + ($valid) + ' = false , ' + ($passingSchemas) + ' = null; ';
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1,
          l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + '[' + $i + ']';
            $it.errSchemaPath = $errSchemaPath + '/' + $i;
            out += '  ' + (it.validate($it)) + ' ';
            $it.baseId = $currentBaseId;
          } else {
            out += ' var ' + ($nextValid) + ' = true; ';
          }
          if ($i) {
            out += ' if (' + ($nextValid) + ' && ' + ($prevValid) + ') { ' + ($valid) + ' = false; ' + ($passingSchemas) + ' = [' + ($passingSchemas) + ', ' + ($i) + ']; } else { ';
            $closingBraces += '}';
          }
          out += ' if (' + ($nextValid) + ') { ' + ($valid) + ' = ' + ($prevValid) + ' = true; ' + ($passingSchemas) + ' = ' + ($i) + '; }';
        }
      }
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += '' + ($closingBraces) + 'if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ('oneOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { passingSchemas: ' + ($passingSchemas) + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should match exactly one schema in oneOf\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError(vErrors); ';
        } else {
          out += ' validate.errors = vErrors; return false; ';
        }
      }
      out += '} else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }';
      if (it.opts.allErrors) {
        out += ' } ';
      }
      return out;
    }

  }, {}], "mGZS": [function (require, module, exports) {
    'use strict';
    module.exports = function generate_pattern(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $isData = it.opts.$data && $schema && $schema.$data,
        $schemaValue;
      if ($isData) {
        out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $regexp = $isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema);
      out += 'if ( ';
      if ($isData) {
        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
      }
      out += ' !' + ($regexp) + '.test(' + ($data) + ') ) {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ('pattern') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { pattern:  ';
        if ($isData) {
          out += '' + ($schemaValue);
        } else {
          out += '' + (it.util.toQuotedString($schema));
        }
        out += '  } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should match pattern "';
          if ($isData) {
            out += '\' + ' + ($schemaValue) + ' + \'';
          } else {
            out += '' + (it.util.escapeQuotes($schema));
          }
          out += '"\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema:  ';
          if ($isData) {
            out += 'validate.schema' + ($schemaPath);
          } else {
            out += '' + (it.util.toQuotedString($schema));
          }
          out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += '} ';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    }

  }, {}], "jFnx": [function (require, module, exports) {
    'use strict';
    module.exports = function generate_properties(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $errs = 'errs__' + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = '';
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      var $key = 'key' + $lvl,
        $idx = 'idx' + $lvl,
        $dataNxt = $it.dataLevel = it.dataLevel + 1,
        $nextData = 'data' + $dataNxt,
        $dataProperties = 'dataProperties' + $lvl;
      var $schemaKeys = Object.keys($schema || {}).filter(notProto),
        $pProperties = it.schema.patternProperties || {},
        $pPropertyKeys = Object.keys($pProperties).filter(notProto),
        $aProperties = it.schema.additionalProperties,
        $someProperties = $schemaKeys.length || $pPropertyKeys.length,
        $noAdditional = $aProperties === false,
        $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,
        $removeAdditional = it.opts.removeAdditional,
        $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
        $ownProperties = it.opts.ownProperties,
        $currentBaseId = it.baseId;
      var $required = it.schema.required;
      if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {
        var $requiredHash = it.util.toHash($required);
      }

      function notProto(p) {
        return p !== '__proto__';
      }
      out += 'var ' + ($errs) + ' = errors;var ' + ($nextValid) + ' = true;';
      if ($ownProperties) {
        out += ' var ' + ($dataProperties) + ' = undefined;';
      }
      if ($checkAdditional) {
        if ($ownProperties) {
          out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
        } else {
          out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
        }
        if ($someProperties) {
          out += ' var isAdditional' + ($lvl) + ' = !(false ';
          if ($schemaKeys.length) {
            if ($schemaKeys.length > 8) {
              out += ' || validate.schema' + ($schemaPath) + '.hasOwnProperty(' + ($key) + ') ';
            } else {
              var arr1 = $schemaKeys;
              if (arr1) {
                var $propertyKey, i1 = -1,
                  l1 = arr1.length - 1;
                while (i1 < l1) {
                  $propertyKey = arr1[i1 += 1];
                  out += ' || ' + ($key) + ' == ' + (it.util.toQuotedString($propertyKey)) + ' ';
                }
              }
            }
          }
          if ($pPropertyKeys.length) {
            var arr2 = $pPropertyKeys;
            if (arr2) {
              var $pProperty, $i = -1,
                l2 = arr2.length - 1;
              while ($i < l2) {
                $pProperty = arr2[$i += 1];
                out += ' || ' + (it.usePattern($pProperty)) + '.test(' + ($key) + ') ';
              }
            }
          }
          out += ' ); if (isAdditional' + ($lvl) + ') { ';
        }
        if ($removeAdditional == 'all') {
          out += ' delete ' + ($data) + '[' + ($key) + ']; ';
        } else {
          var $currentErrorPath = it.errorPath;
          var $additionalProperty = '\' + ' + $key + ' + \'';
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          }
          if ($noAdditional) {
            if ($removeAdditional) {
              out += ' delete ' + ($data) + '[' + ($key) + ']; ';
            } else {
              out += ' ' + ($nextValid) + ' = false; ';
              var $currErrSchemaPath = $errSchemaPath;
              $errSchemaPath = it.errSchemaPath + '/additionalProperties';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ('additionalProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { additionalProperty: \'' + ($additionalProperty) + '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'';
                  if (it.opts._errorDataPathProperty) {
                    out += 'is an invalid additional property';
                  } else {
                    out += 'should NOT have additional properties';
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              $errSchemaPath = $currErrSchemaPath;
              if ($breakOnError) {
                out += ' break; ';
              }
            }
          } else if ($additionalIsSchema) {
            if ($removeAdditional == 'failing') {
              out += ' var ' + ($errs) + ' = errors;  ';
              var $wasComposite = it.compositeRule;
              it.compositeRule = $it.compositeRule = true;
              $it.schema = $aProperties;
              $it.schemaPath = it.schemaPath + '.additionalProperties';
              $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
              $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + '[' + $key + ']';
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
              } else {
                out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
              }
              out += ' if (!' + ($nextValid) + ') { errors = ' + ($errs) + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + ($data) + '[' + ($key) + ']; }  ';
              it.compositeRule = $it.compositeRule = $wasComposite;
            } else {
              $it.schema = $aProperties;
              $it.schemaPath = it.schemaPath + '.additionalProperties';
              $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
              $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + '[' + $key + ']';
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
              } else {
                out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
              }
              if ($breakOnError) {
                out += ' if (!' + ($nextValid) + ') break; ';
              }
            }
          }
          it.errorPath = $currentErrorPath;
        }
        if ($someProperties) {
          out += ' } ';
        }
        out += ' }  ';
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
      var $useDefaults = it.opts.useDefaults && !it.compositeRule;
      if ($schemaKeys.length) {
        var arr3 = $schemaKeys;
        if (arr3) {
          var $propertyKey, i3 = -1,
            l3 = arr3.length - 1;
          while (i3 < l3) {
            $propertyKey = arr3[i3 += 1];
            var $sch = $schema[$propertyKey];
            if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
              var $prop = it.util.getProperty($propertyKey),
                $passData = $data + $prop,
                $hasDefault = $useDefaults && $sch.default !== undefined;
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + $prop;
              $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);
              $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
              $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                $code = it.util.varReplace($code, $nextData, $passData);
                var $useData = $passData;
              } else {
                var $useData = $nextData;
                out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ';
              }
              if ($hasDefault) {
                out += ' ' + ($code) + ' ';
              } else {
                if ($requiredHash && $requiredHash[$propertyKey]) {
                  out += ' if ( ' + ($useData) + ' === undefined ';
                  if ($ownProperties) {
                    out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                  }
                  out += ') { ' + ($nextValid) + ' = false; ';
                  var $currentErrorPath = it.errorPath,
                    $currErrSchemaPath = $errSchemaPath,
                    $missingProperty = it.util.escapeQuotes($propertyKey);
                  if (it.opts._errorDataPathProperty) {
                    it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                  }
                  $errSchemaPath = it.errSchemaPath + '/required';
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = ''; /* istanbul ignore else */
                  if (it.createErrors !== false) {
                    out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
                    if (it.opts.messages !== false) {
                      out += ' , message: \'';
                      if (it.opts._errorDataPathProperty) {
                        out += 'is a required property';
                      } else {
                        out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                      }
                      out += '\' ';
                    }
                    if (it.opts.verbose) {
                      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                    }
                    out += ' } ';
                  } else {
                    out += ' {} ';
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */
                    if (it.async) {
                      out += ' throw new ValidationError([' + (__err) + ']); ';
                    } else {
                      out += ' validate.errors = [' + (__err) + ']; return false; ';
                    }
                  } else {
                    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                  }
                  $errSchemaPath = $currErrSchemaPath;
                  it.errorPath = $currentErrorPath;
                  out += ' } else { ';
                } else {
                  if ($breakOnError) {
                    out += ' if ( ' + ($useData) + ' === undefined ';
                    if ($ownProperties) {
                      out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                    }
                    out += ') { ' + ($nextValid) + ' = true; } else { ';
                  } else {
                    out += ' if (' + ($useData) + ' !== undefined ';
                    if ($ownProperties) {
                      out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                    }
                    out += ' ) { ';
                  }
                }
                out += ' ' + ($code) + ' } ';
              }
            }
            if ($breakOnError) {
              out += ' if (' + ($nextValid) + ') { ';
              $closingBraces += '}';
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr4 = $pPropertyKeys;
        if (arr4) {
          var $pProperty, i4 = -1,
            l4 = arr4.length - 1;
          while (i4 < l4) {
            $pProperty = arr4[i4 += 1];
            var $sch = $pProperties[$pProperty];
            if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
              $it.schema = $sch;
              $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);
              $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);
              if ($ownProperties) {
                out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
              } else {
                out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
              }
              out += ' if (' + (it.usePattern($pProperty)) + '.test(' + ($key) + ')) { ';
              $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + '[' + $key + ']';
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
              } else {
                out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
              }
              if ($breakOnError) {
                out += ' if (!' + ($nextValid) + ') break; ';
              }
              out += ' } ';
              if ($breakOnError) {
                out += ' else ' + ($nextValid) + ' = true; ';
              }
              out += ' }  ';
              if ($breakOnError) {
                out += ' if (' + ($nextValid) + ') { ';
                $closingBraces += '}';
              }
            }
          }
        }
      }
      if ($breakOnError) {
        out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
      }
      return out;
    }

  }, {}], "XxjR": [function (require, module, exports) {
    'use strict';
    module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $errs = 'errs__' + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = '';
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      out += 'var ' + ($errs) + ' = errors;';
      if ((it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        var $key = 'key' + $lvl,
          $idx = 'idx' + $lvl,
          $i = 'i' + $lvl,
          $invalidName = '\' + ' + $key + ' + \'',
          $dataNxt = $it.dataLevel = it.dataLevel + 1,
          $nextData = 'data' + $dataNxt,
          $dataProperties = 'dataProperties' + $lvl,
          $ownProperties = it.opts.ownProperties,
          $currentBaseId = it.baseId;
        if ($ownProperties) {
          out += ' var ' + ($dataProperties) + ' = undefined; ';
        }
        if ($ownProperties) {
          out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
        } else {
          out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
        }
        out += ' var startErrs' + ($lvl) + ' = errors; ';
        var $passData = $key;
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
        } else {
          out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += ' if (!' + ($nextValid) + ') { for (var ' + ($i) + '=startErrs' + ($lvl) + '; ' + ($i) + '<errors; ' + ($i) + '++) { vErrors[' + ($i) + '].propertyName = ' + ($key) + '; }   var err =   '; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('propertyNames') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { propertyName: \'' + ($invalidName) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'property name \\\'' + ($invalidName) + '\\\' is invalid\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError(vErrors); ';
          } else {
            out += ' validate.errors = vErrors; return false; ';
          }
        }
        if ($breakOnError) {
          out += ' break; ';
        }
        out += ' } }';
      }
      if ($breakOnError) {
        out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
      }
      return out;
    }

  }, {}], "Dht1": [function (require, module, exports) {
    'use strict';
    module.exports = function generate_required(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data,
        $schemaValue;
      if ($isData) {
        out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $vSchema = 'schema' + $lvl;
      if (!$isData) {
        if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
          var $required = [];
          var arr1 = $schema;
          if (arr1) {
            var $property, i1 = -1,
              l1 = arr1.length - 1;
            while (i1 < l1) {
              $property = arr1[i1 += 1];
              var $propertySch = it.schema.properties[$property];
              if (!($propertySch && (it.opts.strictKeywords ? (typeof $propertySch == 'object' && Object.keys($propertySch).length > 0) || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
                $required[$required.length] = $property;
              }
            }
          }
        } else {
          var $required = $schema;
        }
      }
      if ($isData || $required.length) {
        var $currentErrorPath = it.errorPath,
          $loopRequired = $isData || $required.length >= it.opts.loopRequired,
          $ownProperties = it.opts.ownProperties;
        if ($breakOnError) {
          out += ' var missing' + ($lvl) + '; ';
          if ($loopRequired) {
            if (!$isData) {
              out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
            }
            var $i = 'i' + $lvl,
              $propertyPath = 'schema' + $lvl + '[' + $i + ']',
              $missingProperty = '\' + ' + $propertyPath + ' + \'';
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
            }
            out += ' var ' + ($valid) + ' = true; ';
            if ($isData) {
              out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
            }
            out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { ' + ($valid) + ' = ' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] !== undefined ';
            if ($ownProperties) {
              out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
            }
            out += '; if (!' + ($valid) + ') break; } ';
            if ($isData) {
              out += '  }  ';
            }
            out += '  if (!' + ($valid) + ') {   ';
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'';
                if (it.opts._errorDataPathProperty) {
                  out += 'is a required property';
                } else {
                  out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + (__err) + ']); ';
              } else {
                out += ' validate.errors = [' + (__err) + ']; return false; ';
              }
            } else {
              out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
            out += ' } else { ';
          } else {
            out += ' if ( ';
            var arr2 = $required;
            if (arr2) {
              var $propertyKey, $i = -1,
                l2 = arr2.length - 1;
              while ($i < l2) {
                $propertyKey = arr2[$i += 1];
                if ($i) {
                  out += ' || ';
                }
                var $prop = it.util.getProperty($propertyKey),
                  $useData = $data + $prop;
                out += ' ( ( ' + ($useData) + ' === undefined ';
                if ($ownProperties) {
                  out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                }
                out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
              }
            }
            out += ') {  ';
            var $propertyPath = 'missing' + $lvl,
              $missingProperty = '\' + ' + $propertyPath + ' + \'';
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'';
                if (it.opts._errorDataPathProperty) {
                  out += 'is a required property';
                } else {
                  out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + (__err) + ']); ';
              } else {
                out += ' validate.errors = [' + (__err) + ']; return false; ';
              }
            } else {
              out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
            out += ' } else { ';
          }
        } else {
          if ($loopRequired) {
            if (!$isData) {
              out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
            }
            var $i = 'i' + $lvl,
              $propertyPath = 'schema' + $lvl + '[' + $i + ']',
              $missingProperty = '\' + ' + $propertyPath + ' + \'';
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
            }
            if ($isData) {
              out += ' if (' + ($vSchema) + ' && !Array.isArray(' + ($vSchema) + ')) {  var err =   '; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'';
                  if (it.opts._errorDataPathProperty) {
                    out += 'is a required property';
                  } else {
                    out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (' + ($vSchema) + ' !== undefined) { ';
            }
            out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { if (' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
            }
            out += ') {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'';
                if (it.opts._errorDataPathProperty) {
                  out += 'is a required property';
                } else {
                  out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';
            if ($isData) {
              out += '  }  ';
            }
          } else {
            var arr3 = $required;
            if (arr3) {
              var $propertyKey, i3 = -1,
                l3 = arr3.length - 1;
              while (i3 < l3) {
                $propertyKey = arr3[i3 += 1];
                var $prop = it.util.getProperty($propertyKey),
                  $missingProperty = it.util.escapeQuotes($propertyKey),
                  $useData = $data + $prop;
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                out += ' if ( ' + ($useData) + ' === undefined ';
                if ($ownProperties) {
                  out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                }
                out += ') {  var err =   '; /* istanbul ignore else */
                if (it.createErrors !== false) {
                  out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
                  if (it.opts.messages !== false) {
                    out += ' , message: \'';
                    if (it.opts._errorDataPathProperty) {
                      out += 'is a required property';
                    } else {
                      out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                    }
                    out += '\' ';
                  }
                  if (it.opts.verbose) {
                    out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                  }
                  out += ' } ';
                } else {
                  out += ' {} ';
                }
                out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
              }
            }
          }
        }
        it.errorPath = $currentErrorPath;
      } else if ($breakOnError) {
        out += ' if (true) {';
      }
      return out;
    }

  }, {}], "mmFQ": [function (require, module, exports) {
    'use strict';
    module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data,
        $schemaValue;
      if ($isData) {
        out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (($schema || $isData) && it.opts.uniqueItems !== false) {
        if ($isData) {
          out += ' var ' + ($valid) + '; if (' + ($schemaValue) + ' === false || ' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \'boolean\') ' + ($valid) + ' = false; else { ';
        }
        out += ' var i = ' + ($data) + '.length , ' + ($valid) + ' = true , j; if (i > 1) { ';
        var $itemType = it.schema.items && it.schema.items.type,
          $typeIsArray = Array.isArray($itemType);
        if (!$itemType || $itemType == 'object' || $itemType == 'array' || ($typeIsArray && ($itemType.indexOf('object') >= 0 || $itemType.indexOf('array') >= 0))) {
          out += ' outer: for (;i--;) { for (j = i; j--;) { if (equal(' + ($data) + '[i], ' + ($data) + '[j])) { ' + ($valid) + ' = false; break outer; } } } ';
        } else {
          out += ' var itemIndices = {}, item; for (;i--;) { var item = ' + ($data) + '[i]; ';
          var $method = 'checkDataType' + ($typeIsArray ? 's' : '');
          out += ' if (' + (it.util[$method]($itemType, 'item', it.opts.strictNumbers, true)) + ') continue; ';
          if ($typeIsArray) {
            out += ' if (typeof item == \'string\') item = \'"\' + item; ';
          }
          out += ' if (typeof itemIndices[item] == \'number\') { ' + ($valid) + ' = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ';
        }
        out += ' } ';
        if ($isData) {
          out += '  }  ';
        }
        out += ' if (!' + ($valid) + ') {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('uniqueItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { i: i, j: j } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should NOT have duplicate items (items ## \' + j + \' and \' + i + \' are identical)\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema:  ';
            if ($isData) {
              out += 'validate.schema' + ($schemaPath);
            } else {
              out += '' + ($schema);
            }
            out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } ';
        if ($breakOnError) {
          out += ' else { ';
        }
      } else {
        if ($breakOnError) {
          out += ' if (true) { ';
        }
      }
      return out;
    }

  }, {}], "Czyc": [function (require, module, exports) {
    'use strict';

    //all requires must be explicit because browserify won't work with dynamic requires
    module.exports = {
      '$ref': require('./ref'),
      allOf: require('./allOf'),
      anyOf: require('./anyOf'),
      '$comment': require('./comment'),
      const: require('./const'),
      contains: require('./contains'),
      dependencies: require('./dependencies'),
      'enum': require('./enum'),
      format: require('./format'),
      'if': require('./if'),
      items: require('./items'),
      maximum: require('./_limit'),
      minimum: require('./_limit'),
      maxItems: require('./_limitItems'),
      minItems: require('./_limitItems'),
      maxLength: require('./_limitLength'),
      minLength: require('./_limitLength'),
      maxProperties: require('./_limitProperties'),
      minProperties: require('./_limitProperties'),
      multipleOf: require('./multipleOf'),
      not: require('./not'),
      oneOf: require('./oneOf'),
      pattern: require('./pattern'),
      properties: require('./properties'),
      propertyNames: require('./propertyNames'),
      required: require('./required'),
      uniqueItems: require('./uniqueItems'),
      validate: require('./validate')
    };

  }, { "./ref": "a2na", "./allOf": "hRgn", "./anyOf": "lo6J", "./comment": "Kkzr", "./const": "U4sD", "./contains": "EypH", "./dependencies": "Cpp7", "./enum": "fqDY", "./format": "avoW", "./if": "JHQ3", "./items": "aiPb", "./_limit": "UJAl", "./_limitItems": "W8ih", "./_limitLength": "fZGX", "./_limitProperties": "JAEr", "./multipleOf": "oNPH", "./not": "mmjm", "./oneOf": "SSWF", "./pattern": "mGZS", "./properties": "jFnx", "./propertyNames": "XxjR", "./required": "Dht1", "./uniqueItems": "mmFQ", "./validate": "yhC1" }], "vBP0": [function (require, module, exports) {
    'use strict';

    var ruleModules = require('../dotjs')
      , toHash = require('./util').toHash;

    module.exports = function rules() {
      var RULES = [
        {
          type: 'number',
          rules: [{ 'maximum': ['exclusiveMaximum'] },
          { 'minimum': ['exclusiveMinimum'] }, 'multipleOf', 'format']
        },
        {
          type: 'string',
          rules: ['maxLength', 'minLength', 'pattern', 'format']
        },
        {
          type: 'array',
          rules: ['maxItems', 'minItems', 'items', 'contains', 'uniqueItems']
        },
        {
          type: 'object',
          rules: ['maxProperties', 'minProperties', 'required', 'dependencies', 'propertyNames',
            { 'properties': ['additionalProperties', 'patternProperties'] }]
        },
        { rules: ['$ref', 'const', 'enum', 'not', 'anyOf', 'oneOf', 'allOf', 'if'] }
      ];

      var ALL = ['type', '$comment'];
      var KEYWORDS = [
        '$schema', '$id', 'id', '$data', '$async', 'title',
        'description', 'default', 'definitions',
        'examples', 'readOnly', 'writeOnly',
        'contentMediaType', 'contentEncoding',
        'additionalItems', 'then', 'else'
      ];
      var TYPES = ['number', 'integer', 'string', 'array', 'object', 'boolean', 'null'];
      RULES.all = toHash(ALL);
      RULES.types = toHash(TYPES);

      RULES.forEach(function (group) {
        group.rules = group.rules.map(function (keyword) {
          var implKeywords;
          if (typeof keyword == 'object') {
            var key = Object.keys(keyword)[0];
            implKeywords = keyword[key];
            keyword = key;
            implKeywords.forEach(function (k) {
              ALL.push(k);
              RULES.all[k] = true;
            });
          }
          ALL.push(keyword);
          var rule = RULES.all[keyword] = {
            keyword: keyword,
            code: ruleModules[keyword],
            implements: implKeywords
          };
          return rule;
        });

        RULES.all.$comment = {
          keyword: '$comment',
          code: ruleModules.$comment
        };

        if (group.type) RULES.types[group.type] = group;
      });

      RULES.keywords = toHash(ALL.concat(KEYWORDS));
      RULES.custom = {};

      return RULES;
    };

  }, { "../dotjs": "Czyc", "./util": "Q1F7" }], "BunE": [function (require, module, exports) {
    'use strict';

    var KEYWORDS = [
      'multipleOf',
      'maximum',
      'exclusiveMaximum',
      'minimum',
      'exclusiveMinimum',
      'maxLength',
      'minLength',
      'pattern',
      'additionalItems',
      'maxItems',
      'minItems',
      'uniqueItems',
      'maxProperties',
      'minProperties',
      'required',
      'additionalProperties',
      'enum',
      'format',
      'const'
    ];

    module.exports = function (metaSchema, keywordsJsonPointers) {
      for (var i = 0; i < keywordsJsonPointers.length; i++) {
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        var segments = keywordsJsonPointers[i].split('/');
        var keywords = metaSchema;
        var j;
        for (j = 1; j < segments.length; j++)
          keywords = keywords[segments[j]];

        for (j = 0; j < KEYWORDS.length; j++) {
          var key = KEYWORDS[j];
          var schema = keywords[key];
          if (schema) {
            keywords[key] = {
              anyOf: [
                schema,
                { $ref: 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#' }
              ]
            };
          }
        }
      }

      return metaSchema;
    };

  }, {}], "mNRF": [function (require, module, exports) {
    'use strict';

    var MissingRefError = require('./error_classes').MissingRef;

    module.exports = compileAsync;


    /**
     * Creates validating function for passed schema with asynchronous loading of missing schemas.
     * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.
     * @this  Ajv
     * @param {Object}   schema schema object
     * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
     * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
     * @return {Promise} promise that resolves with a validating function.
     */
    function compileAsync(schema, meta, callback) {
      /* eslint no-shadow: 0 */
      /* global Promise */
      /* jshint validthis: true */
      var self = this;
      if (typeof this._opts.loadSchema != 'function')
        throw new Error('options.loadSchema should be a function');

      if (typeof meta == 'function') {
        callback = meta;
        meta = undefined;
      }

      var p = loadMetaSchemaOf(schema).then(function () {
        var schemaObj = self._addSchema(schema, undefined, meta);
        return schemaObj.validate || _compileAsync(schemaObj);
      });

      if (callback) {
        p.then(
          function (v) { callback(null, v); },
          callback
        );
      }

      return p;


      function loadMetaSchemaOf(sch) {
        var $schema = sch.$schema;
        return $schema && !self.getSchema($schema)
          ? compileAsync.call(self, { $ref: $schema }, true)
          : Promise.resolve();
      }


      function _compileAsync(schemaObj) {
        try { return self._compile(schemaObj); }
        catch (e) {
          if (e instanceof MissingRefError) return loadMissingSchema(e);
          throw e;
        }


        function loadMissingSchema(e) {
          var ref = e.missingSchema;
          if (added(ref)) throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');

          var schemaPromise = self._loadingSchemas[ref];
          if (!schemaPromise) {
            schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
            schemaPromise.then(removePromise, removePromise);
          }

          return schemaPromise.then(function (sch) {
            if (!added(ref)) {
              return loadMetaSchemaOf(sch).then(function () {
                if (!added(ref)) self.addSchema(sch, ref, undefined, meta);
              });
            }
          }).then(function () {
            return _compileAsync(schemaObj);
          });

          function removePromise() {
            delete self._loadingSchemas[ref];
          }

          function added(ref) {
            return self._refs[ref] || self._schemas[ref];
          }
        }
      }
    }

  }, { "./error_classes": "OtNE" }], "Mzku": [function (require, module, exports) {
    'use strict';
    module.exports = function generate_custom(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $errs = 'errs__' + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data,
        $schemaValue;
      if ($isData) {
        out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $rule = this,
        $definition = 'definition' + $lvl,
        $rDef = $rule.definition,
        $closingBraces = '';
      var $compile, $inline, $macro, $ruleValidate, $validateCode;
      if ($isData && $rDef.$data) {
        $validateCode = 'keywordValidate' + $lvl;
        var $validateSchema = $rDef.validateSchema;
        out += ' var ' + ($definition) + ' = RULES.custom[\'' + ($keyword) + '\'].definition; var ' + ($validateCode) + ' = ' + ($definition) + '.validate;';
      } else {
        $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
        if (!$ruleValidate) return;
        $schemaValue = 'validate.schema' + $schemaPath;
        $validateCode = $ruleValidate.code;
        $compile = $rDef.compile;
        $inline = $rDef.inline;
        $macro = $rDef.macro;
      }
      var $ruleErrs = $validateCode + '.errors',
        $i = 'i' + $lvl,
        $ruleErr = 'ruleErr' + $lvl,
        $asyncKeyword = $rDef.async;
      if ($asyncKeyword && !it.async) throw new Error('async keyword in sync schema');
      if (!($inline || $macro)) {
        out += '' + ($ruleErrs) + ' = null;';
      }
      out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
      if ($isData && $rDef.$data) {
        $closingBraces += '}';
        out += ' if (' + ($schemaValue) + ' === undefined) { ' + ($valid) + ' = true; } else { ';
        if ($validateSchema) {
          $closingBraces += '}';
          out += ' ' + ($valid) + ' = ' + ($definition) + '.validateSchema(' + ($schemaValue) + '); if (' + ($valid) + ') { ';
        }
      }
      if ($inline) {
        if ($rDef.statements) {
          out += ' ' + ($ruleValidate.validate) + ' ';
        } else {
          out += ' ' + ($valid) + ' = ' + ($ruleValidate.validate) + '; ';
        }
      } else if ($macro) {
        var $it = it.util.copy(it);
        var $closingBraces = '';
        $it.level++;
        var $nextValid = 'valid' + $it.level;
        $it.schema = $ruleValidate.validate;
        $it.schemaPath = '';
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += ' ' + ($code);
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = '';
        out += '  ' + ($validateCode) + '.call( ';
        if (it.opts.passContext) {
          out += 'this';
        } else {
          out += 'self';
        }
        if ($compile || $rDef.schema === false) {
          out += ' , ' + ($data) + ' ';
        } else {
          out += ' , ' + ($schemaValue) + ' , ' + ($data) + ' , validate.schema' + (it.schemaPath) + ' ';
        }
        out += ' , (dataPath || \'\')';
        if (it.errorPath != '""') {
          out += ' + ' + (it.errorPath);
        }
        var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
          $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
        out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ' , rootData )  ';
        var def_callRuleValidate = out;
        out = $$outStack.pop();
        if ($rDef.errors === false) {
          out += ' ' + ($valid) + ' = ';
          if ($asyncKeyword) {
            out += 'await ';
          }
          out += '' + (def_callRuleValidate) + '; ';
        } else {
          if ($asyncKeyword) {
            $ruleErrs = 'customErrors' + $lvl;
            out += ' var ' + ($ruleErrs) + ' = null; try { ' + ($valid) + ' = await ' + (def_callRuleValidate) + '; } catch (e) { ' + ($valid) + ' = false; if (e instanceof ValidationError) ' + ($ruleErrs) + ' = e.errors; else throw e; } ';
          } else {
            out += ' ' + ($ruleErrs) + ' = null; ' + ($valid) + ' = ' + (def_callRuleValidate) + '; ';
          }
        }
      }
      if ($rDef.modifying) {
        out += ' if (' + ($parentData) + ') ' + ($data) + ' = ' + ($parentData) + '[' + ($parentDataProperty) + '];';
      }
      out += '' + ($closingBraces);
      if ($rDef.valid) {
        if ($breakOnError) {
          out += ' if (true) { ';
        }
      } else {
        out += ' if ( ';
        if ($rDef.valid === undefined) {
          out += ' !';
          if ($macro) {
            out += '' + ($nextValid);
          } else {
            out += '' + ($valid);
          }
        } else {
          out += ' ' + (!$rDef.valid) + ' ';
        }
        out += ') { ';
        $errorKeyword = $rule.keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = '';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        var def_customError = out;
        out = $$outStack.pop();
        if ($inline) {
          if ($rDef.errors) {
            if ($rDef.errors != 'full') {
              out += '  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
              if (it.opts.verbose) {
                out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
              }
              out += ' } ';
            }
          } else {
            if ($rDef.errors === false) {
              out += ' ' + (def_customError) + ' ';
            } else {
              out += ' if (' + ($errs) + ' == errors) { ' + (def_customError) + ' } else {  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
              if (it.opts.verbose) {
                out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
              }
              out += ' } } ';
            }
          }
        } else if ($macro) {
          out += '   var err =   '; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError(vErrors); ';
            } else {
              out += ' validate.errors = vErrors; return false; ';
            }
          }
        } else {
          if ($rDef.errors === false) {
            out += ' ' + (def_customError) + ' ';
          } else {
            out += ' if (Array.isArray(' + ($ruleErrs) + ')) { if (vErrors === null) vErrors = ' + ($ruleErrs) + '; else vErrors = vErrors.concat(' + ($ruleErrs) + '); errors = vErrors.length;  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + ';  ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '";  ';
            if (it.opts.verbose) {
              out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
            }
            out += ' } } else { ' + (def_customError) + ' } ';
          }
        }
        out += ' } ';
        if ($breakOnError) {
          out += ' else { ';
        }
      }
      return out;
    }

  }, {}], "ve7q": [function (require, module, exports) {
    module.exports = {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "$id": "http://json-schema.org/draft-07/schema#",
      "title": "Core schema meta-schema",
      "definitions": {
        "schemaArray": {
          "type": "array",
          "minItems": 1,
          "items": { "$ref": "#" }
        },
        "nonNegativeInteger": {
          "type": "integer",
          "minimum": 0
        },
        "nonNegativeIntegerDefault0": {
          "allOf": [
            { "$ref": "#/definitions/nonNegativeInteger" },
            { "default": 0 }
          ]
        },
        "simpleTypes": {
          "enum": [
            "array",
            "boolean",
            "integer",
            "null",
            "number",
            "object",
            "string"
          ]
        },
        "stringArray": {
          "type": "array",
          "items": { "type": "string" },
          "uniqueItems": true,
          "default": []
        }
      },
      "type": ["object", "boolean"],
      "properties": {
        "$id": {
          "type": "string",
          "format": "uri-reference"
        },
        "$schema": {
          "type": "string",
          "format": "uri"
        },
        "$ref": {
          "type": "string",
          "format": "uri-reference"
        },
        "$comment": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "default": true,
        "readOnly": {
          "type": "boolean",
          "default": false
        },
        "examples": {
          "type": "array",
          "items": true
        },
        "multipleOf": {
          "type": "number",
          "exclusiveMinimum": 0
        },
        "maximum": {
          "type": "number"
        },
        "exclusiveMaximum": {
          "type": "number"
        },
        "minimum": {
          "type": "number"
        },
        "exclusiveMinimum": {
          "type": "number"
        },
        "maxLength": { "$ref": "#/definitions/nonNegativeInteger" },
        "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
        "pattern": {
          "type": "string",
          "format": "regex"
        },
        "additionalItems": { "$ref": "#" },
        "items": {
          "anyOf": [
            { "$ref": "#" },
            { "$ref": "#/definitions/schemaArray" }
          ],
          "default": true
        },
        "maxItems": { "$ref": "#/definitions/nonNegativeInteger" },
        "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
        "uniqueItems": {
          "type": "boolean",
          "default": false
        },
        "contains": { "$ref": "#" },
        "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },
        "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
        "required": { "$ref": "#/definitions/stringArray" },
        "additionalProperties": { "$ref": "#" },
        "definitions": {
          "type": "object",
          "additionalProperties": { "$ref": "#" },
          "default": {}
        },
        "properties": {
          "type": "object",
          "additionalProperties": { "$ref": "#" },
          "default": {}
        },
        "patternProperties": {
          "type": "object",
          "additionalProperties": { "$ref": "#" },
          "propertyNames": { "format": "regex" },
          "default": {}
        },
        "dependencies": {
          "type": "object",
          "additionalProperties": {
            "anyOf": [
              { "$ref": "#" },
              { "$ref": "#/definitions/stringArray" }
            ]
          }
        },
        "propertyNames": { "$ref": "#" },
        "const": true,
        "enum": {
          "type": "array",
          "items": true,
          "minItems": 1,
          "uniqueItems": true
        },
        "type": {
          "anyOf": [
            { "$ref": "#/definitions/simpleTypes" },
            {
              "type": "array",
              "items": { "$ref": "#/definitions/simpleTypes" },
              "minItems": 1,
              "uniqueItems": true
            }
          ]
        },
        "format": { "type": "string" },
        "contentMediaType": { "type": "string" },
        "contentEncoding": { "type": "string" },
        "if": { "$ref": "#" },
        "then": { "$ref": "#" },
        "else": { "$ref": "#" },
        "allOf": { "$ref": "#/definitions/schemaArray" },
        "anyOf": { "$ref": "#/definitions/schemaArray" },
        "oneOf": { "$ref": "#/definitions/schemaArray" },
        "not": { "$ref": "#" }
      },
      "default": true
    }
      ;
  }, {}], "GIYw": [function (require, module, exports) {
    'use strict';

    var metaSchema = require('./refs/json-schema-draft-07.json');

    module.exports = {
      $id: 'https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js',
      definitions: {
        simpleTypes: metaSchema.definitions.simpleTypes
      },
      type: 'object',
      dependencies: {
        schema: ['validate'],
        $data: ['validate'],
        statements: ['inline'],
        valid: { not: { required: ['macro'] } }
      },
      properties: {
        type: metaSchema.properties.type,
        schema: { type: 'boolean' },
        statements: { type: 'boolean' },
        dependencies: {
          type: 'array',
          items: { type: 'string' }
        },
        metaSchema: { type: 'object' },
        modifying: { type: 'boolean' },
        valid: { type: 'boolean' },
        $data: { type: 'boolean' },
        async: { type: 'boolean' },
        errors: {
          anyOf: [
            { type: 'boolean' },
            { const: 'full' }
          ]
        }
      }
    };

  }, { "./refs/json-schema-draft-07.json": "ve7q" }], "UVv5": [function (require, module, exports) {
    'use strict';

    var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
    var customRuleCode = require('./dotjs/custom');
    var definitionSchema = require('./definition_schema');

    module.exports = {
      add: addKeyword,
      get: getKeyword,
      remove: removeKeyword,
      validate: validateKeyword
    };


    /**
     * Define custom keyword
     * @this  Ajv
     * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
     * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
     * @return {Ajv} this for method chaining
     */
    function addKeyword(keyword, definition) {
      /* jshint validthis: true */
      /* eslint no-shadow: 0 */
      var RULES = this.RULES;
      if (RULES.keywords[keyword])
        throw new Error('Keyword ' + keyword + ' is already defined');

      if (!IDENTIFIER.test(keyword))
        throw new Error('Keyword ' + keyword + ' is not a valid identifier');

      if (definition) {
        this.validateKeyword(definition, true);

        var dataType = definition.type;
        if (Array.isArray(dataType)) {
          for (var i = 0; i < dataType.length; i++)
            _addRule(keyword, dataType[i], definition);
        } else {
          _addRule(keyword, dataType, definition);
        }

        var metaSchema = definition.metaSchema;
        if (metaSchema) {
          if (definition.$data && this._opts.$data) {
            metaSchema = {
              anyOf: [
                metaSchema,
                { '$ref': 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#' }
              ]
            };
          }
          definition.validateSchema = this.compile(metaSchema, true);
        }
      }

      RULES.keywords[keyword] = RULES.all[keyword] = true;


      function _addRule(keyword, dataType, definition) {
        var ruleGroup;
        for (var i = 0; i < RULES.length; i++) {
          var rg = RULES[i];
          if (rg.type == dataType) {
            ruleGroup = rg;
            break;
          }
        }

        if (!ruleGroup) {
          ruleGroup = { type: dataType, rules: [] };
          RULES.push(ruleGroup);
        }

        var rule = {
          keyword: keyword,
          definition: definition,
          custom: true,
          code: customRuleCode,
          implements: definition.implements
        };
        ruleGroup.rules.push(rule);
        RULES.custom[keyword] = rule;
      }

      return this;
    }


    /**
     * Get keyword
     * @this  Ajv
     * @param {String} keyword pre-defined or custom keyword.
     * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
     */
    function getKeyword(keyword) {
      /* jshint validthis: true */
      var rule = this.RULES.custom[keyword];
      return rule ? rule.definition : this.RULES.keywords[keyword] || false;
    }


    /**
     * Remove keyword
     * @this  Ajv
     * @param {String} keyword pre-defined or custom keyword.
     * @return {Ajv} this for method chaining
     */
    function removeKeyword(keyword) {
      /* jshint validthis: true */
      var RULES = this.RULES;
      delete RULES.keywords[keyword];
      delete RULES.all[keyword];
      delete RULES.custom[keyword];
      for (var i = 0; i < RULES.length; i++) {
        var rules = RULES[i].rules;
        for (var j = 0; j < rules.length; j++) {
          if (rules[j].keyword == keyword) {
            rules.splice(j, 1);
            break;
          }
        }
      }
      return this;
    }


    /**
     * Validate keyword definition
     * @this  Ajv
     * @param {Object} definition keyword definition object.
     * @param {Boolean} throwError true to throw exception if definition is invalid
     * @return {boolean} validation result
     */
    function validateKeyword(definition, throwError) {
      validateKeyword.errors = null;
      var v = this._validateKeyword = this._validateKeyword
        || this.compile(definitionSchema, true);

      if (v(definition)) return true;
      validateKeyword.errors = v.errors;
      if (throwError)
        throw new Error('custom keyword definition is invalid: ' + this.errorsText(v.errors));
      else
        return false;
    }

  }, { "./dotjs/custom": "Mzku", "./definition_schema": "GIYw" }], "xbmT": [function (require, module, exports) {
    module.exports = {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "$id": "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      "description": "Meta-schema for $data reference (JSON Schema extension proposal)",
      "type": "object",
      "required": ["$data"],
      "properties": {
        "$data": {
          "type": "string",
          "anyOf": [
            { "format": "relative-json-pointer" },
            { "format": "json-pointer" }
          ]
        }
      },
      "additionalProperties": false
    }
      ;
  }, {}], "hi5j": [function (require, module, exports) {
    'use strict';

    var compileSchema = require('./compile')
      , resolve = require('./compile/resolve')
      , Cache = require('./cache')
      , SchemaObject = require('./compile/schema_obj')
      , stableStringify = require('fast-json-stable-stringify')
      , formats = require('./compile/formats')
      , rules = require('./compile/rules')
      , $dataMetaSchema = require('./data')
      , util = require('./compile/util');

    module.exports = Ajv;

    Ajv.prototype.validate = validate;
    Ajv.prototype.compile = compile;
    Ajv.prototype.addSchema = addSchema;
    Ajv.prototype.addMetaSchema = addMetaSchema;
    Ajv.prototype.validateSchema = validateSchema;
    Ajv.prototype.getSchema = getSchema;
    Ajv.prototype.removeSchema = removeSchema;
    Ajv.prototype.addFormat = addFormat;
    Ajv.prototype.errorsText = errorsText;

    Ajv.prototype._addSchema = _addSchema;
    Ajv.prototype._compile = _compile;

    Ajv.prototype.compileAsync = require('./compile/async');
    var customKeyword = require('./keyword');
    Ajv.prototype.addKeyword = customKeyword.add;
    Ajv.prototype.getKeyword = customKeyword.get;
    Ajv.prototype.removeKeyword = customKeyword.remove;
    Ajv.prototype.validateKeyword = customKeyword.validate;

    var errorClasses = require('./compile/error_classes');
    Ajv.ValidationError = errorClasses.Validation;
    Ajv.MissingRefError = errorClasses.MissingRef;
    Ajv.$dataMetaSchema = $dataMetaSchema;

    var META_SCHEMA_ID = 'http://json-schema.org/draft-07/schema';

    var META_IGNORE_OPTIONS = ['removeAdditional', 'useDefaults', 'coerceTypes', 'strictDefaults'];
    var META_SUPPORT_DATA = ['/properties'];

    /**
     * Creates validator instance.
     * Usage: `Ajv(opts)`
     * @param {Object} opts optional options
     * @return {Object} ajv instance
     */
    function Ajv(opts) {
      if (!(this instanceof Ajv)) return new Ajv(opts);
      opts = this._opts = util.copy(opts) || {};
      setLogger(this);
      this._schemas = {};
      this._refs = {};
      this._fragments = {};
      this._formats = formats(opts.format);

      this._cache = opts.cache || new Cache;
      this._loadingSchemas = {};
      this._compilations = [];
      this.RULES = rules();
      this._getId = chooseGetId(opts);

      opts.loopRequired = opts.loopRequired || Infinity;
      if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;
      if (opts.serialize === undefined) opts.serialize = stableStringify;
      this._metaOpts = getMetaSchemaOptions(this);

      if (opts.formats) addInitialFormats(this);
      if (opts.keywords) addInitialKeywords(this);
      addDefaultMetaSchema(this);
      if (typeof opts.meta == 'object') this.addMetaSchema(opts.meta);
      if (opts.nullable) this.addKeyword('nullable', { metaSchema: { type: 'boolean' } });
      addInitialSchemas(this);
    }



    /**
     * Validate data using schema
     * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.
     * @this   Ajv
     * @param  {String|Object} schemaKeyRef key, ref or schema object
     * @param  {Any} data to be validated
     * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
     */
    function validate(schemaKeyRef, data) {
      var v;
      if (typeof schemaKeyRef == 'string') {
        v = this.getSchema(schemaKeyRef);
        if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
      } else {
        var schemaObj = this._addSchema(schemaKeyRef);
        v = schemaObj.validate || this._compile(schemaObj);
      }

      var valid = v(data);
      if (v.$async !== true) this.errors = v.errors;
      return valid;
    }


    /**
     * Create validating function for passed schema.
     * @this   Ajv
     * @param  {Object} schema schema object
     * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
     * @return {Function} validating function
     */
    function compile(schema, _meta) {
      var schemaObj = this._addSchema(schema, undefined, _meta);
      return schemaObj.validate || this._compile(schemaObj);
    }


    /**
     * Adds schema to the instance.
     * @this   Ajv
     * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
     * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
     * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
     * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
     * @return {Ajv} this for method chaining
     */
    function addSchema(schema, key, _skipValidation, _meta) {
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);
        return this;
      }
      var id = this._getId(schema);
      if (id !== undefined && typeof id != 'string')
        throw new Error('schema id must be string');
      key = resolve.normalizeId(key || id);
      checkUnique(this, key);
      this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
      return this;
    }


    /**
     * Add schema that will be used to validate other schemas
     * options in META_IGNORE_OPTIONS are alway set to false
     * @this   Ajv
     * @param {Object} schema schema object
     * @param {String} key optional schema key
     * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
     * @return {Ajv} this for method chaining
     */
    function addMetaSchema(schema, key, skipValidation) {
      this.addSchema(schema, key, skipValidation, true);
      return this;
    }


    /**
     * Validate schema
     * @this   Ajv
     * @param {Object} schema schema to validate
     * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
     * @return {Boolean} true if schema is valid
     */
    function validateSchema(schema, throwOrLogError) {
      var $schema = schema.$schema;
      if ($schema !== undefined && typeof $schema != 'string')
        throw new Error('$schema must be a string');
      $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
      if (!$schema) {
        this.logger.warn('meta-schema not available');
        this.errors = null;
        return true;
      }
      var valid = this.validate($schema, schema);
      if (!valid && throwOrLogError) {
        var message = 'schema is invalid: ' + this.errorsText();
        if (this._opts.validateSchema == 'log') this.logger.error(message);
        else throw new Error(message);
      }
      return valid;
    }


    function defaultMeta(self) {
      var meta = self._opts.meta;
      self._opts.defaultMeta = typeof meta == 'object'
        ? self._getId(meta) || meta
        : self.getSchema(META_SCHEMA_ID)
          ? META_SCHEMA_ID
          : undefined;
      return self._opts.defaultMeta;
    }


    /**
     * Get compiled schema from the instance by `key` or `ref`.
     * @this   Ajv
     * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
     * @return {Function} schema validating function (with property `schema`).
     */
    function getSchema(keyRef) {
      var schemaObj = _getSchemaObj(this, keyRef);
      switch (typeof schemaObj) {
        case 'object': return schemaObj.validate || this._compile(schemaObj);
        case 'string': return this.getSchema(schemaObj);
        case 'undefined': return _getSchemaFragment(this, keyRef);
      }
    }


    function _getSchemaFragment(self, ref) {
      var res = resolve.schema.call(self, { schema: {} }, ref);
      if (res) {
        var schema = res.schema
          , root = res.root
          , baseId = res.baseId;
        var v = compileSchema.call(self, schema, root, undefined, baseId);
        self._fragments[ref] = new SchemaObject({
          ref: ref,
          fragment: true,
          schema: schema,
          root: root,
          baseId: baseId,
          validate: v
        });
        return v;
      }
    }


    function _getSchemaObj(self, keyRef) {
      keyRef = resolve.normalizeId(keyRef);
      return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
    }


    /**
     * Remove cached schema(s).
     * If no parameter is passed all schemas but meta-schemas are removed.
     * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
     * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
     * @this   Ajv
     * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
     * @return {Ajv} this for method chaining
     */
    function removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        _removeAllSchemas(this, this._schemas, schemaKeyRef);
        _removeAllSchemas(this, this._refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case 'undefined':
          _removeAllSchemas(this, this._schemas);
          _removeAllSchemas(this, this._refs);
          this._cache.clear();
          return this;
        case 'string':
          var schemaObj = _getSchemaObj(this, schemaKeyRef);
          if (schemaObj) this._cache.del(schemaObj.cacheKey);
          delete this._schemas[schemaKeyRef];
          delete this._refs[schemaKeyRef];
          return this;
        case 'object':
          var serialize = this._opts.serialize;
          var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
          this._cache.del(cacheKey);
          var id = this._getId(schemaKeyRef);
          if (id) {
            id = resolve.normalizeId(id);
            delete this._schemas[id];
            delete this._refs[id];
          }
      }
      return this;
    }


    function _removeAllSchemas(self, schemas, regex) {
      for (var keyRef in schemas) {
        var schemaObj = schemas[keyRef];
        if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
          self._cache.del(schemaObj.cacheKey);
          delete schemas[keyRef];
        }
      }
    }


    /* @this   Ajv */
    function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
      if (typeof schema != 'object' && typeof schema != 'boolean')
        throw new Error('schema should be object or boolean');
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schema) : schema;
      var cached = this._cache.get(cacheKey);
      if (cached) return cached;

      shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;

      var id = resolve.normalizeId(this._getId(schema));
      if (id && shouldAddSchema) checkUnique(this, id);

      var willValidate = this._opts.validateSchema !== false && !skipValidation;
      var recursiveMeta;
      if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
        this.validateSchema(schema, true);

      var localRefs = resolve.ids.call(this, schema);

      var schemaObj = new SchemaObject({
        id: id,
        schema: schema,
        localRefs: localRefs,
        cacheKey: cacheKey,
        meta: meta
      });

      if (id[0] != '#' && shouldAddSchema) this._refs[id] = schemaObj;
      this._cache.put(cacheKey, schemaObj);

      if (willValidate && recursiveMeta) this.validateSchema(schema, true);

      return schemaObj;
    }


    /* @this   Ajv */
    function _compile(schemaObj, root) {
      if (schemaObj.compiling) {
        schemaObj.validate = callValidate;
        callValidate.schema = schemaObj.schema;
        callValidate.errors = null;
        callValidate.root = root ? root : callValidate;
        if (schemaObj.schema.$async === true)
          callValidate.$async = true;
        return callValidate;
      }
      schemaObj.compiling = true;

      var currentOpts;
      if (schemaObj.meta) {
        currentOpts = this._opts;
        this._opts = this._metaOpts;
      }

      var v;
      try { v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs); }
      catch (e) {
        delete schemaObj.validate;
        throw e;
      }
      finally {
        schemaObj.compiling = false;
        if (schemaObj.meta) this._opts = currentOpts;
      }

      schemaObj.validate = v;
      schemaObj.refs = v.refs;
      schemaObj.refVal = v.refVal;
      schemaObj.root = v.root;
      return v;


      /* @this   {*} - custom context, see passContext option */
      function callValidate() {
        /* jshint validthis: true */
        var _validate = schemaObj.validate;
        var result = _validate.apply(this, arguments);
        callValidate.errors = _validate.errors;
        return result;
      }
    }


    function chooseGetId(opts) {
      switch (opts.schemaId) {
        case 'auto': return _get$IdOrId;
        case 'id': return _getId;
        default: return _get$Id;
      }
    }

    /* @this   Ajv */
    function _getId(schema) {
      if (schema.$id) this.logger.warn('schema $id ignored', schema.$id);
      return schema.id;
    }

    /* @this   Ajv */
    function _get$Id(schema) {
      if (schema.id) this.logger.warn('schema id ignored', schema.id);
      return schema.$id;
    }


    function _get$IdOrId(schema) {
      if (schema.$id && schema.id && schema.$id != schema.id)
        throw new Error('schema $id is different from id');
      return schema.$id || schema.id;
    }


    /**
     * Convert array of error message objects to string
     * @this   Ajv
     * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
     * @param  {Object} options optional options with properties `separator` and `dataVar`.
     * @return {String} human readable string with all errors descriptions
     */
    function errorsText(errors, options) {
      errors = errors || this.errors;
      if (!errors) return 'No errors';
      options = options || {};
      var separator = options.separator === undefined ? ', ' : options.separator;
      var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;

      var text = '';
      for (var i = 0; i < errors.length; i++) {
        var e = errors[i];
        if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;
      }
      return text.slice(0, -separator.length);
    }


    /**
     * Add custom format
     * @this   Ajv
     * @param {String} name format name
     * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
     * @return {Ajv} this for method chaining
     */
    function addFormat(name, format) {
      if (typeof format == 'string') format = new RegExp(format);
      this._formats[name] = format;
      return this;
    }


    function addDefaultMetaSchema(self) {
      var $dataSchema;
      if (self._opts.$data) {
        $dataSchema = require('./refs/data.json');
        self.addMetaSchema($dataSchema, $dataSchema.$id, true);
      }
      if (self._opts.meta === false) return;
      var metaSchema = require('./refs/json-schema-draft-07.json');
      if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
      self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
      self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;
    }


    function addInitialSchemas(self) {
      var optsSchemas = self._opts.schemas;
      if (!optsSchemas) return;
      if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);
      else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
    }


    function addInitialFormats(self) {
      for (var name in self._opts.formats) {
        var format = self._opts.formats[name];
        self.addFormat(name, format);
      }
    }


    function addInitialKeywords(self) {
      for (var name in self._opts.keywords) {
        var keyword = self._opts.keywords[name];
        self.addKeyword(name, keyword);
      }
    }


    function checkUnique(self, id) {
      if (self._schemas[id] || self._refs[id])
        throw new Error('schema with key or id "' + id + '" already exists');
    }


    function getMetaSchemaOptions(self) {
      var metaOpts = util.copy(self._opts);
      for (var i = 0; i < META_IGNORE_OPTIONS.length; i++)
        delete metaOpts[META_IGNORE_OPTIONS[i]];
      return metaOpts;
    }


    function setLogger(self) {
      var logger = self._opts.logger;
      if (logger === false) {
        self.logger = { log: noop, warn: noop, error: noop };
      } else {
        if (logger === undefined) logger = console;
        if (!(typeof logger == 'object' && logger.log && logger.warn && logger.error))
          throw new Error('logger must implement log, warn and error methods');
        self.logger = logger;
      }
    }


    function noop() { }

  }, { "./compile": "qdYs", "./compile/resolve": "w10T", "./cache": "fXCy", "./compile/schema_obj": "HHLG", "fast-json-stable-stringify": "Xb3N", "./compile/formats": "dfAH", "./compile/rules": "vBP0", "./data": "BunE", "./compile/util": "Q1F7", "./compile/async": "mNRF", "./keyword": "UVv5", "./compile/error_classes": "OtNE", "./refs/data.json": "xbmT", "./refs/json-schema-draft-07.json": "ve7q" }], "dhP9": [function (require, module, exports) {
    var Buffer = require("buffer").Buffer;
    'use strict';

    var CONSTRUCTORS = {
      Object: Object,
      Array: Array,
      Function: Function,
      Number: Number,
      String: String,
      Date: Date,
      RegExp: RegExp
    };

    module.exports = function defFunc(ajv) {
      /* istanbul ignore else */
      if (typeof Buffer != 'undefined')
        CONSTRUCTORS.Buffer = Buffer;

      /* istanbul ignore else */
      if (typeof Promise != 'undefined')
        CONSTRUCTORS.Promise = Promise;

      defFunc.definition = {
        compile: function (schema) {
          if (typeof schema == 'string') {
            var Constructor = getConstructor(schema);
            return function (data) {
              return data instanceof Constructor;
            };
          }

          var constructors = schema.map(getConstructor);
          return function (data) {
            for (var i = 0; i < constructors.length; i++)
              if (data instanceof constructors[i]) return true;
            return false;
          };
        },
        CONSTRUCTORS: CONSTRUCTORS,
        metaSchema: {
          anyOf: [
            { type: 'string' },
            {
              type: 'array',
              items: { type: 'string' }
            }
          ]
        }
      };

      ajv.addKeyword('instanceof', defFunc.definition);
      return ajv;

      function getConstructor(c) {
        var Constructor = CONSTRUCTORS[c];
        if (Constructor) return Constructor;
        throw new Error('invalid "instanceof" keyword value ' + c);
      }
    };

  }, { "buffer": "dskh" }], "uBCt": [function (require, module, exports) {
    'use strict';

    module.exports = function defFunc(ajv) {
      defFunc.definition = {
        type: 'number',
        macro: function (schema, parentSchema) {
          var min = schema[0]
            , max = schema[1]
            , exclusive = parentSchema.exclusiveRange;

          validateRangeSchema(min, max, exclusive);

          return exclusive === true
            ? { exclusiveMinimum: min, exclusiveMaximum: max }
            : { minimum: min, maximum: max };
        },
        metaSchema: {
          type: 'array',
          minItems: 2,
          maxItems: 2,
          items: { type: 'number' }
        }
      };

      ajv.addKeyword('range', defFunc.definition);
      ajv.addKeyword('exclusiveRange');
      return ajv;

      function validateRangeSchema(min, max, exclusive) {
        if (exclusive !== undefined && typeof exclusive != 'boolean')
          throw new Error('Invalid schema for exclusiveRange keyword, should be boolean');

        if (min > max || (exclusive && min == max))
          throw new Error('There are no numbers in range');
      }
    };

  }, {}], "AtCq": [function (require, module, exports) {
    'use strict';

    module.exports = function defFunc(ajv) {
      defFunc.definition = {
        type: 'string',
        inline: function (it, keyword, schema) {
          return getRegExp() + '.test(data' + (it.dataLevel || '') + ')';

          function getRegExp() {
            try {
              if (typeof schema == 'object')
                return new RegExp(schema.pattern, schema.flags);

              var rx = schema.match(/^\/(.*)\/([gimuy]*)$/);
              if (rx) return new RegExp(rx[1], rx[2]);
              throw new Error('cannot parse string into RegExp');
            } catch (e) {
              console.error('regular expression', schema, 'is invalid');
              throw e;
            }
          }
        },
        metaSchema: {
          type: ['string', 'object'],
          properties: {
            pattern: { type: 'string' },
            flags: { type: 'string' }
          },
          required: ['pattern'],
          additionalProperties: false
        }
      };

      ajv.addKeyword('regexp', defFunc.definition);
      return ajv;
    };

  }, {}], "yoml": [function (require, module, exports) {
    'use strict';

    var KNOWN_TYPES = ['undefined', 'string', 'number', 'object', 'function', 'boolean', 'symbol'];

    module.exports = function defFunc(ajv) {
      defFunc.definition = {
        inline: function (it, keyword, schema) {
          var data = 'data' + (it.dataLevel || '');
          if (typeof schema == 'string') return 'typeof ' + data + ' == "' + schema + '"';
          schema = 'validate.schema' + it.schemaPath + '.' + keyword;
          return schema + '.indexOf(typeof ' + data + ') >= 0';
        },
        metaSchema: {
          anyOf: [
            {
              type: 'string',
              enum: KNOWN_TYPES
            },
            {
              type: 'array',
              items: {
                type: 'string',
                enum: KNOWN_TYPES
              }
            }
          ]
        }
      };

      ajv.addKeyword('typeof', defFunc.definition);
      return ajv;
    };

  }, {}], "FbE8": [function (require, module, exports) {
    'use strict';

    var sequences = {};

    var DEFAULTS = {
      timestamp: function () { return Date.now(); },
      datetime: function () { return (new Date).toISOString(); },
      date: function () { return (new Date).toISOString().slice(0, 10); },
      time: function () { return (new Date).toISOString().slice(11); },
      random: function () { return Math.random(); },
      randomint: function (args) {
        var limit = args && args.max || 2;
        return function () { return Math.floor(Math.random() * limit); };
      },
      seq: function (args) {
        var name = args && args.name || '';
        sequences[name] = sequences[name] || 0;
        return function () { return sequences[name]++; };
      }
    };

    module.exports = function defFunc(ajv) {
      defFunc.definition = {
        compile: function (schema, parentSchema, it) {
          var funcs = {};

          for (var key in schema) {
            var d = schema[key];
            var func = getDefault(typeof d == 'string' ? d : d.func);
            funcs[key] = func.length ? func(d.args) : func;
          }

          return it.opts.useDefaults && !it.compositeRule
            ? assignDefaults
            : noop;

          function assignDefaults(data) {
            for (var prop in schema) {
              if (data[prop] === undefined
                || (it.opts.useDefaults == 'empty'
                  && (data[prop] === null || data[prop] === '')))
                data[prop] = funcs[prop]();
            }
            return true;
          }

          function noop() { return true; }
        },
        DEFAULTS: DEFAULTS,
        metaSchema: {
          type: 'object',
          additionalProperties: {
            type: ['string', 'object'],
            additionalProperties: false,
            required: ['func', 'args'],
            properties: {
              func: { type: 'string' },
              args: { type: 'object' }
            }
          }
        }
      };

      ajv.addKeyword('dynamicDefaults', defFunc.definition);
      return ajv;

      function getDefault(d) {
        var def = DEFAULTS[d];
        if (def) return def;
        throw new Error('invalid "dynamicDefaults" keyword property value: ' + d);
      }
    };

  }, {}], "CJDR": [function (require, module, exports) {
    'use strict';

    module.exports = function defFunc(ajv) {
      defFunc.definition = {
        type: 'object',
        macro: function (schema, parentSchema) {
          if (!schema) return true;
          var properties = Object.keys(parentSchema.properties);
          if (properties.length == 0) return true;
          return { required: properties };
        },
        metaSchema: { type: 'boolean' },
        dependencies: ['properties']
      };

      ajv.addKeyword('allRequired', defFunc.definition);
      return ajv;
    };

  }, {}], "n1DR": [function (require, module, exports) {
    'use strict';

    module.exports = function defFunc(ajv) {
      defFunc.definition = {
        type: 'object',
        macro: function (schema) {
          if (schema.length == 0) return true;
          if (schema.length == 1) return { required: schema };
          var schemas = schema.map(function (prop) {
            return { required: [prop] };
          });
          return { anyOf: schemas };
        },
        metaSchema: {
          type: 'array',
          items: {
            type: 'string'
          }
        }
      };

      ajv.addKeyword('anyRequired', defFunc.definition);
      return ajv;
    };

  }, {}], "XrCF": [function (require, module, exports) {
    'use strict';

    module.exports = function defFunc(ajv) {
      defFunc.definition = {
        type: 'object',
        macro: function (schema) {
          if (schema.length == 0) return true;
          if (schema.length == 1) return { required: schema };
          var schemas = schema.map(function (prop) {
            return { required: [prop] };
          });
          return { oneOf: schemas };
        },
        metaSchema: {
          type: 'array',
          items: {
            type: 'string'
          }
        }
      };

      ajv.addKeyword('oneRequired', defFunc.definition);
      return ajv;
    };

  }, {}], "MFGI": [function (require, module, exports) {
    'use strict';

    module.exports = function defFunc(ajv) {
      defFunc.definition = {
        type: 'object',
        macro: function (schema) {
          if (schema.length == 0) return true;
          if (schema.length == 1) return { not: { required: schema } };
          var schemas = schema.map(function (prop) {
            return { required: [prop] };
          });
          return { not: { anyOf: schemas } };
        },
        metaSchema: {
          type: 'array',
          items: {
            type: 'string'
          }
        }
      };

      ajv.addKeyword('prohibited', defFunc.definition);
      return ajv;
    };

  }, {}], "m7Ap": [function (require, module, exports) {
    'use strict';

    var SCALAR_TYPES = ['number', 'integer', 'string', 'boolean', 'null'];

    module.exports = function defFunc(ajv) {
      defFunc.definition = {
        type: 'array',
        compile: function (keys, parentSchema, it) {
          var equal = it.util.equal;
          var scalar = getScalarKeys(keys, parentSchema);

          return function (data) {
            if (data.length > 1) {
              for (var k = 0; k < keys.length; k++) {
                var i, key = keys[k];
                if (scalar[k]) {
                  var hash = {};
                  for (i = data.length; i--;) {
                    if (!data[i] || typeof data[i] != 'object') continue;
                    var prop = data[i][key];
                    if (prop && typeof prop == 'object') continue;
                    if (typeof prop == 'string') prop = '"' + prop;
                    if (hash[prop]) return false;
                    hash[prop] = true;
                  }
                } else {
                  for (i = data.length; i--;) {
                    if (!data[i] || typeof data[i] != 'object') continue;
                    for (var j = i; j--;) {
                      if (data[j] && typeof data[j] == 'object' && equal(data[i][key], data[j][key]))
                        return false;
                    }
                  }
                }
              }
            }
            return true;
          };
        },
        metaSchema: {
          type: 'array',
          items: { type: 'string' }
        }
      };

      ajv.addKeyword('uniqueItemProperties', defFunc.definition);
      return ajv;
    };


    function getScalarKeys(keys, schema) {
      return keys.map(function (key) {
        var properties = schema.items && schema.items.properties;
        var propType = properties && properties[key] && properties[key].type;
        return Array.isArray(propType)
          ? propType.indexOf('object') < 0 && propType.indexOf('array') < 0
          : SCALAR_TYPES.indexOf(propType) >= 0;
      });
    }

  }, {}], "R4Fp": [function (require, module, exports) {
    'use strict';

    module.exports = {
      metaSchemaRef: metaSchemaRef
    };

    var META_SCHEMA_ID = 'http://json-schema.org/draft-07/schema';

    function metaSchemaRef(ajv) {
      var defaultMeta = ajv._opts.defaultMeta;
      if (typeof defaultMeta == 'string') return { $ref: defaultMeta };
      if (ajv.getSchema(META_SCHEMA_ID)) return { $ref: META_SCHEMA_ID };
      console.warn('meta schema not defined');
      return {};
    }

  }, {}], "kIuQ": [function (require, module, exports) {
    'use strict';

    var util = require('./_util');

    module.exports = function defFunc(ajv) {
      defFunc.definition = {
        type: 'object',
        macro: function (schema) {
          var schemas = [];
          for (var pointer in schema)
            schemas.push(getSchema(pointer, schema[pointer]));
          return { 'allOf': schemas };
        },
        metaSchema: {
          type: 'object',
          propertyNames: {
            type: 'string',
            format: 'json-pointer'
          },
          additionalProperties: util.metaSchemaRef(ajv)
        }
      };

      ajv.addKeyword('deepProperties', defFunc.definition);
      return ajv;
    };


    function getSchema(jsonPointer, schema) {
      var segments = jsonPointer.split('/');
      var rootSchema = {};
      var pointerSchema = rootSchema;
      for (var i = 1; i < segments.length; i++) {
        var segment = segments[i];
        var isLast = i == segments.length - 1;
        segment = unescapeJsonPointer(segment);
        var properties = pointerSchema.properties = {};
        var items = undefined;
        if (/[0-9]+/.test(segment)) {
          var count = +segment;
          items = pointerSchema.items = [];
          while (count--) items.push({});
        }
        pointerSchema = isLast ? schema : {};
        properties[segment] = pointerSchema;
        if (items) items.push(pointerSchema);
      }
      return rootSchema;
    }


    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, '/').replace(/~0/g, '~');
    }

  }, { "./_util": "R4Fp" }], "KB8y": [function (require, module, exports) {
    'use strict';

    module.exports = function defFunc(ajv) {
      defFunc.definition = {
        type: 'object',
        inline: function (it, keyword, schema) {
          var expr = '';
          for (var i = 0; i < schema.length; i++) {
            if (i) expr += ' && ';
            expr += '(' + getData(schema[i], it.dataLevel) + ' !== undefined)';
          }
          return expr;
        },
        metaSchema: {
          type: 'array',
          items: {
            type: 'string',
            format: 'json-pointer'
          }
        }
      };

      ajv.addKeyword('deepRequired', defFunc.definition);
      return ajv;
    };


    function getData(jsonPointer, lvl) {
      var data = 'data' + (lvl || '');
      if (!jsonPointer) return data;

      var expr = data;
      var segments = jsonPointer.split('/');
      for (var i = 1; i < segments.length; i++) {
        var segment = segments[i];
        data += getProperty(unescapeJsonPointer(segment));
        expr += ' && ' + data;
      }
      return expr;
    }


    var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var INTEGER = /^[0-9]+$/;
    var SINGLE_QUOTE = /'|\\/g;
    function getProperty(key) {
      return INTEGER.test(key)
        ? '[' + key + ']'
        : IDENTIFIER.test(key)
          ? '.' + key
          : "['" + key.replace(SINGLE_QUOTE, '\\$&') + "']";
    }


    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, '/').replace(/~0/g, '~');
    }

  }, {}], "KeB4": [function (require, module, exports) {
    'use strict';
    module.exports = function generate__formatLimit(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      out += 'var ' + ($valid) + ' = undefined;';
      if (it.opts.format === false) {
        out += ' ' + ($valid) + ' = true; ';
        return out;
      }
      var $schemaFormat = it.schema.format,
        $isDataFormat = it.opts.$data && $schemaFormat.$data,
        $closingBraces = '';
      if ($isDataFormat) {
        var $schemaValueFormat = it.util.getData($schemaFormat.$data, $dataLvl, it.dataPathArr),
          $format = 'format' + $lvl,
          $compare = 'compare' + $lvl;
        out += ' var ' + ($format) + ' = formats[' + ($schemaValueFormat) + '] , ' + ($compare) + ' = ' + ($format) + ' && ' + ($format) + '.compare;';
      } else {
        var $format = it.formats[$schemaFormat];
        if (!($format && $format.compare)) {
          out += '  ' + ($valid) + ' = true; ';
          return out;
        }
        var $compare = 'formats' + it.util.getProperty($schemaFormat) + '.compare';
      }
      var $isMax = $keyword == 'formatMaximum',
        $exclusiveKeyword = 'formatExclusive' + ($isMax ? 'Maximum' : 'Minimum'),
        $schemaExcl = it.schema[$exclusiveKeyword],
        $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,
        $op = $isMax ? '<' : '>',
        $result = 'result' + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data,
        $schemaValue;
      if ($isData) {
        out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if ($isDataExcl) {
        var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
          $exclusive = 'exclusive' + $lvl,
          $opExpr = 'op' + $lvl,
          $opStr = '\' + ' + $opExpr + ' + \'';
        out += ' var schemaExcl' + ($lvl) + ' = ' + ($schemaValueExcl) + '; ';
        $schemaValueExcl = 'schemaExcl' + $lvl;
        out += ' if (typeof ' + ($schemaValueExcl) + ' != \'boolean\' && ' + ($schemaValueExcl) + ' !== undefined) { ' + ($valid) + ' = false; ';
        var $errorKeyword = $exclusiveKeyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || '_formatExclusiveLimit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
          if (it.opts.messages !== false) {
            out += ' , message: \'' + ($exclusiveKeyword) + ' should be boolean\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' }  ';
        if ($breakOnError) {
          $closingBraces += '}';
          out += ' else { ';
        }
        if ($isData) {
          out += ' if (' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \'string\') ' + ($valid) + ' = false; else { ';
          $closingBraces += '}';
        }
        if ($isDataFormat) {
          out += ' if (!' + ($compare) + ') ' + ($valid) + ' = true; else { ';
          $closingBraces += '}';
        }
        out += ' var ' + ($result) + ' = ' + ($compare) + '(' + ($data) + ',  ';
        if ($isData) {
          out += '' + ($schemaValue);
        } else {
          out += '' + (it.util.toQuotedString($schema));
        }
        out += ' ); if (' + ($result) + ' === undefined) ' + ($valid) + ' = false; var ' + ($exclusive) + ' = ' + ($schemaValueExcl) + ' === true; if (' + ($valid) + ' === undefined) { ' + ($valid) + ' = ' + ($exclusive) + ' ? ' + ($result) + ' ' + ($op) + ' 0 : ' + ($result) + ' ' + ($op) + '= 0; } if (!' + ($valid) + ') var op' + ($lvl) + ' = ' + ($exclusive) + ' ? \'' + ($op) + '\' : \'' + ($op) + '=\';';
      } else {
        var $exclusive = $schemaExcl === true,
          $opStr = $op;
        if (!$exclusive) $opStr += '=';
        var $opExpr = '\'' + $opStr + '\'';
        if ($isData) {
          out += ' if (' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \'string\') ' + ($valid) + ' = false; else { ';
          $closingBraces += '}';
        }
        if ($isDataFormat) {
          out += ' if (!' + ($compare) + ') ' + ($valid) + ' = true; else { ';
          $closingBraces += '}';
        }
        out += ' var ' + ($result) + ' = ' + ($compare) + '(' + ($data) + ',  ';
        if ($isData) {
          out += '' + ($schemaValue);
        } else {
          out += '' + (it.util.toQuotedString($schema));
        }
        out += ' ); if (' + ($result) + ' === undefined) ' + ($valid) + ' = false; if (' + ($valid) + ' === undefined) ' + ($valid) + ' = ' + ($result) + ' ' + ($op);
        if (!$exclusive) {
          out += '=';
        }
        out += ' 0;';
      }
      out += '' + ($closingBraces) + 'if (!' + ($valid) + ') { ';
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || '_formatLimit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { comparison: ' + ($opExpr) + ', limit:  ';
        if ($isData) {
          out += '' + ($schemaValue);
        } else {
          out += '' + (it.util.toQuotedString($schema));
        }
        out += ' , exclusive: ' + ($exclusive) + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should be ' + ($opStr) + ' "';
          if ($isData) {
            out += '\' + ' + ($schemaValue) + ' + \'';
          } else {
            out += '' + (it.util.escapeQuotes($schema));
          }
          out += '"\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema:  ';
          if ($isData) {
            out += 'validate.schema' + ($schemaPath);
          } else {
            out += '' + (it.util.toQuotedString($schema));
          }
          out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += '}';
      return out;
    }

  }, {}], "mYD7": [function (require, module, exports) {
    'use strict';

    var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d:\d\d)?$/i;
    var DATE_TIME_SEPARATOR = /t|\s/i;

    var COMPARE_FORMATS = {
      date: compareDate,
      time: compareTime,
      'date-time': compareDateTime
    };

    var $dataMetaSchema = {
      type: 'object',
      required: ['$data'],
      properties: {
        $data: {
          type: 'string',
          anyOf: [
            { format: 'relative-json-pointer' },
            { format: 'json-pointer' }
          ]
        }
      },
      additionalProperties: false
    };

    module.exports = function (minMax) {
      var keyword = 'format' + minMax;
      return function defFunc(ajv) {
        defFunc.definition = {
          type: 'string',
          inline: require('./dotjs/_formatLimit'),
          statements: true,
          errors: 'full',
          dependencies: ['format'],
          metaSchema: {
            anyOf: [
              { type: 'string' },
              $dataMetaSchema
            ]
          }
        };

        ajv.addKeyword(keyword, defFunc.definition);
        ajv.addKeyword('formatExclusive' + minMax, {
          dependencies: ['format' + minMax],
          metaSchema: {
            anyOf: [
              { type: 'boolean' },
              $dataMetaSchema
            ]
          }
        });
        extendFormats(ajv);
        return ajv;
      };
    };


    function extendFormats(ajv) {
      var formats = ajv._formats;
      for (var name in COMPARE_FORMATS) {
        var format = formats[name];
        // the last condition is needed if it's RegExp from another window
        if (typeof format != 'object' || format instanceof RegExp || !format.validate)
          format = formats[name] = { validate: format };
        if (!format.compare)
          format.compare = COMPARE_FORMATS[name];
      }
    }


    function compareDate(d1, d2) {
      if (!(d1 && d2)) return;
      if (d1 > d2) return 1;
      if (d1 < d2) return -1;
      if (d1 === d2) return 0;
    }


    function compareTime(t1, t2) {
      if (!(t1 && t2)) return;
      t1 = t1.match(TIME);
      t2 = t2.match(TIME);
      if (!(t1 && t2)) return;
      t1 = t1[1] + t1[2] + t1[3] + (t1[4] || '');
      t2 = t2[1] + t2[2] + t2[3] + (t2[4] || '');
      if (t1 > t2) return 1;
      if (t1 < t2) return -1;
      if (t1 === t2) return 0;
    }


    function compareDateTime(dt1, dt2) {
      if (!(dt1 && dt2)) return;
      dt1 = dt1.split(DATE_TIME_SEPARATOR);
      dt2 = dt2.split(DATE_TIME_SEPARATOR);
      var res = compareDate(dt1[0], dt2[0]);
      if (res === undefined) return;
      return res || compareTime(dt1[1], dt2[1]);
    }

  }, { "./dotjs/_formatLimit": "KeB4" }], "J927": [function (require, module, exports) {
    'use strict';

    module.exports = require('./_formatLimit')('Minimum');

  }, { "./_formatLimit": "mYD7" }], "dgLz": [function (require, module, exports) {
    'use strict';

    module.exports = require('./_formatLimit')('Maximum');

  }, { "./_formatLimit": "mYD7" }], "OTUE": [function (require, module, exports) {
    'use strict';
    module.exports = function generate_patternRequired(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $key = 'key' + $lvl,
        $idx = 'idx' + $lvl,
        $matched = 'patternMatched' + $lvl,
        $dataProperties = 'dataProperties' + $lvl,
        $closingBraces = '',
        $ownProperties = it.opts.ownProperties;
      out += 'var ' + ($valid) + ' = true;';
      if ($ownProperties) {
        out += ' var ' + ($dataProperties) + ' = undefined;';
      }
      var arr1 = $schema;
      if (arr1) {
        var $pProperty, i1 = -1,
          l1 = arr1.length - 1;
        while (i1 < l1) {
          $pProperty = arr1[i1 += 1];
          out += ' var ' + ($matched) + ' = false;  ';
          if ($ownProperties) {
            out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
          } else {
            out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
          }
          out += ' ' + ($matched) + ' = ' + (it.usePattern($pProperty)) + '.test(' + ($key) + '); if (' + ($matched) + ') break; } ';
          var $missingPattern = it.util.escapeQuotes($pProperty);
          out += ' if (!' + ($matched) + ') { ' + ($valid) + ' = false;  var err =   '; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ('patternRequired') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingPattern: \'' + ($missingPattern) + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'should have property matching pattern \\\'' + ($missingPattern) + '\\\'\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; }   ';
          if ($breakOnError) {
            $closingBraces += '}';
            out += ' else { ';
          }
        }
      }
      out += '' + ($closingBraces);
      return out;
    }

  }, {}], "u2zM": [function (require, module, exports) {
    'use strict';

    module.exports = function defFunc(ajv) {
      defFunc.definition = {
        type: 'object',
        inline: require('./dotjs/patternRequired'),
        statements: true,
        errors: 'full',
        metaSchema: {
          type: 'array',
          items: {
            type: 'string',
            format: 'regex'
          },
          uniqueItems: true
        }
      };

      ajv.addKeyword('patternRequired', defFunc.definition);
      return ajv;
    };

  }, { "./dotjs/patternRequired": "OTUE" }], "mlCb": [function (require, module, exports) {
    'use strict';
    module.exports = function generate_switch(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $errs = 'errs__' + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = '';
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      var $ifPassed = 'ifPassed' + it.level,
        $currentBaseId = $it.baseId,
        $shouldContinue;
      out += 'var ' + ($ifPassed) + ';';
      var arr1 = $schema;
      if (arr1) {
        var $sch, $caseIndex = -1,
          l1 = arr1.length - 1;
        while ($caseIndex < l1) {
          $sch = arr1[$caseIndex += 1];
          if ($caseIndex && !$shouldContinue) {
            out += ' if (!' + ($ifPassed) + ') { ';
            $closingBraces += '}';
          }
          if ($sch.if && (it.opts.strictKeywords ? typeof $sch.if == 'object' && Object.keys($sch.if).length > 0 : it.util.schemaHasRules($sch.if, it.RULES.all))) {
            out += ' var ' + ($errs) + ' = errors;   ';
            var $wasComposite = it.compositeRule;
            it.compositeRule = $it.compositeRule = true;
            $it.createErrors = false;
            $it.schema = $sch.if;
            $it.schemaPath = $schemaPath + '[' + $caseIndex + '].if';
            $it.errSchemaPath = $errSchemaPath + '/' + $caseIndex + '/if';
            out += '  ' + (it.validate($it)) + ' ';
            $it.baseId = $currentBaseId;
            $it.createErrors = true;
            it.compositeRule = $it.compositeRule = $wasComposite;
            out += ' ' + ($ifPassed) + ' = ' + ($nextValid) + '; if (' + ($ifPassed) + ') {  ';
            if (typeof $sch.then == 'boolean') {
              if ($sch.then === false) {
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ''; /* istanbul ignore else */
                if (it.createErrors !== false) {
                  out += ' { keyword: \'' + ('switch') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { caseIndex: ' + ($caseIndex) + ' } ';
                  if (it.opts.messages !== false) {
                    out += ' , message: \'should pass "switch" keyword validation\' ';
                  }
                  if (it.opts.verbose) {
                    out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                  }
                  out += ' } ';
                } else {
                  out += ' {} ';
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                  /* istanbul ignore if */
                  if (it.async) {
                    out += ' throw new ValidationError([' + (__err) + ']); ';
                  } else {
                    out += ' validate.errors = [' + (__err) + ']; return false; ';
                  }
                } else {
                  out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                }
              }
              out += ' var ' + ($nextValid) + ' = ' + ($sch.then) + '; ';
            } else {
              $it.schema = $sch.then;
              $it.schemaPath = $schemaPath + '[' + $caseIndex + '].then';
              $it.errSchemaPath = $errSchemaPath + '/' + $caseIndex + '/then';
              out += '  ' + (it.validate($it)) + ' ';
              $it.baseId = $currentBaseId;
            }
            out += '  } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } } ';
          } else {
            out += ' ' + ($ifPassed) + ' = true;  ';
            if (typeof $sch.then == 'boolean') {
              if ($sch.then === false) {
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ''; /* istanbul ignore else */
                if (it.createErrors !== false) {
                  out += ' { keyword: \'' + ('switch') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { caseIndex: ' + ($caseIndex) + ' } ';
                  if (it.opts.messages !== false) {
                    out += ' , message: \'should pass "switch" keyword validation\' ';
                  }
                  if (it.opts.verbose) {
                    out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                  }
                  out += ' } ';
                } else {
                  out += ' {} ';
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) {
                  /* istanbul ignore if */
                  if (it.async) {
                    out += ' throw new ValidationError([' + (__err) + ']); ';
                  } else {
                    out += ' validate.errors = [' + (__err) + ']; return false; ';
                  }
                } else {
                  out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                }
              }
              out += ' var ' + ($nextValid) + ' = ' + ($sch.then) + '; ';
            } else {
              $it.schema = $sch.then;
              $it.schemaPath = $schemaPath + '[' + $caseIndex + '].then';
              $it.errSchemaPath = $errSchemaPath + '/' + $caseIndex + '/then';
              out += '  ' + (it.validate($it)) + ' ';
              $it.baseId = $currentBaseId;
            }
          }
          $shouldContinue = $sch.continue
        }
      }
      out += '' + ($closingBraces) + 'var ' + ($valid) + ' = ' + ($nextValid) + ';';
      return out;
    }

  }, {}], "KC2b": [function (require, module, exports) {
    'use strict';

    var util = require('./_util');

    module.exports = function defFunc(ajv) {
      if (ajv.RULES.keywords.switch && ajv.RULES.keywords.if) return;

      var metaSchemaRef = util.metaSchemaRef(ajv);

      defFunc.definition = {
        inline: require('./dotjs/switch'),
        statements: true,
        errors: 'full',
        metaSchema: {
          type: 'array',
          items: {
            required: ['then'],
            properties: {
              'if': metaSchemaRef,
              'then': {
                anyOf: [
                  { type: 'boolean' },
                  metaSchemaRef
                ]
              },
              'continue': { type: 'boolean' }
            },
            additionalProperties: false,
            dependencies: {
              'continue': ['if']
            }
          }
        }
      };

      ajv.addKeyword('switch', defFunc.definition);
      return ajv;
    };

  }, { "./_util": "R4Fp", "./dotjs/switch": "mlCb" }], "mwue": [function (require, module, exports) {
    'use strict';

    var util = require('./_util');

    module.exports = function defFunc(ajv) {
      if (!ajv._opts.$data) {
        console.warn('keyword select requires $data option');
        return ajv;
      }
      var metaSchemaRef = util.metaSchemaRef(ajv);
      var compiledCaseSchemas = [];

      defFunc.definition = {
        validate: function v(schema, data, parentSchema) {
          if (parentSchema.selectCases === undefined)
            throw new Error('keyword "selectCases" is absent');
          var compiled = getCompiledSchemas(parentSchema, false);
          var validate = compiled.cases[schema];
          if (validate === undefined) validate = compiled.default;
          if (typeof validate == 'boolean') return validate;
          var valid = validate(data);
          if (!valid) v.errors = validate.errors;
          return valid;
        },
        $data: true,
        metaSchema: { type: ['string', 'number', 'boolean', 'null'] }
      };

      ajv.addKeyword('select', defFunc.definition);
      ajv.addKeyword('selectCases', {
        compile: function (schemas, parentSchema) {
          var compiled = getCompiledSchemas(parentSchema);
          for (var value in schemas)
            compiled.cases[value] = compileOrBoolean(schemas[value]);
          return function () { return true; };
        },
        valid: true,
        metaSchema: {
          type: 'object',
          additionalProperties: metaSchemaRef
        }
      });
      ajv.addKeyword('selectDefault', {
        compile: function (schema, parentSchema) {
          var compiled = getCompiledSchemas(parentSchema);
          compiled.default = compileOrBoolean(schema);
          return function () { return true; };
        },
        valid: true,
        metaSchema: metaSchemaRef
      });
      return ajv;


      function getCompiledSchemas(parentSchema, create) {
        var compiled;
        compiledCaseSchemas.some(function (c) {
          if (c.parentSchema === parentSchema) {
            compiled = c;
            return true;
          }
        });
        if (!compiled && create !== false) {
          compiled = {
            parentSchema: parentSchema,
            cases: {},
            default: true
          };
          compiledCaseSchemas.push(compiled);
        }
        return compiled;
      }

      function compileOrBoolean(schema) {
        return typeof schema == 'boolean'
          ? schema
          : ajv.compile(schema);
      }
    };

  }, { "./_util": "R4Fp" }], "selR": [function (require, module, exports) {
    'use strict';

    module.exports = function defFunc(ajv) {
      var transform = {
        trimLeft: function (value) {
          return value.replace(/^[\s]+/, '');
        },
        trimRight: function (value) {
          return value.replace(/[\s]+$/, '');
        },
        trim: function (value) {
          return value.trim();
        },
        toLowerCase: function (value) {
          return value.toLowerCase();
        },
        toUpperCase: function (value) {
          return value.toUpperCase();
        },
        toEnumCase: function (value, cfg) {
          return cfg.hash[makeHashTableKey(value)] || value;
        }
      };

      defFunc.definition = {
        type: 'string',
        errors: false,
        modifying: true,
        valid: true,
        compile: function (schema, parentSchema) {
          var cfg;

          if (schema.indexOf('toEnumCase') !== -1) {
            // build hash table to enum values
            cfg = { hash: {} };

            // requires `enum` in schema
            if (!parentSchema.enum)
              throw new Error('Missing enum. To use `transform:["toEnumCase"]`, `enum:[...]` is required.');
            for (var i = parentSchema.enum.length; i--; i) {
              var v = parentSchema.enum[i];
              if (typeof v !== 'string') continue;
              var k = makeHashTableKey(v);
              // requires all `enum` values have unique keys
              if (cfg.hash[k])
                throw new Error('Invalid enum uniqueness. To use `transform:["toEnumCase"]`, all values must be unique when case insensitive.');
              cfg.hash[k] = v;
            }
          }

          return function (data, dataPath, object, key) {
            // skip if value only
            if (!object) return;

            // apply transform in order provided
            for (var j = 0, l = schema.length; j < l; j++)
              data = transform[schema[j]](data, cfg);

            object[key] = data;
          };
        },
        metaSchema: {
          type: 'array',
          items: {
            type: 'string',
            enum: [
              'trimLeft', 'trimRight', 'trim',
              'toLowerCase', 'toUpperCase', 'toEnumCase'
            ]
          }
        }
      };

      ajv.addKeyword('transform', defFunc.definition);
      return ajv;

      function makeHashTableKey(value) {
        return value.toLowerCase();
      }
    };

  }, {}], "KP4Q": [function (require, module, exports) {
    'use strict';

    module.exports = {
      'instanceof': require('./instanceof'),
      range: require('./range'),
      regexp: require('./regexp'),
      'typeof': require('./typeof'),
      dynamicDefaults: require('./dynamicDefaults'),
      allRequired: require('./allRequired'),
      anyRequired: require('./anyRequired'),
      oneRequired: require('./oneRequired'),
      prohibited: require('./prohibited'),
      uniqueItemProperties: require('./uniqueItemProperties'),
      deepProperties: require('./deepProperties'),
      deepRequired: require('./deepRequired'),
      formatMinimum: require('./formatMinimum'),
      formatMaximum: require('./formatMaximum'),
      patternRequired: require('./patternRequired'),
      'switch': require('./switch'),
      select: require('./select'),
      transform: require('./transform')
    };

  }, { "./instanceof": "dhP9", "./range": "uBCt", "./regexp": "AtCq", "./typeof": "yoml", "./dynamicDefaults": "FbE8", "./allRequired": "CJDR", "./anyRequired": "n1DR", "./oneRequired": "XrCF", "./prohibited": "MFGI", "./uniqueItemProperties": "m7Ap", "./deepProperties": "kIuQ", "./deepRequired": "KB8y", "./formatMinimum": "J927", "./formatMaximum": "dgLz", "./patternRequired": "u2zM", "./switch": "KC2b", "./select": "mwue", "./transform": "selR" }], "n1A8": [function (require, module, exports) {
    'use strict';

    var KEYWORDS = require('./keywords');

    module.exports = defineKeywords;


    /**
     * Defines one or several keywords in ajv instance
     * @param  {Ajv} ajv validator instance
     * @param  {String|Array<String>|undefined} keyword keyword(s) to define
     * @return {Ajv} ajv instance (for chaining)
     */
    function defineKeywords(ajv, keyword) {
      if (Array.isArray(keyword)) {
        for (var i = 0; i < keyword.length; i++)
          get(keyword[i])(ajv);
        return ajv;
      }
      if (keyword) {
        get(keyword)(ajv);
        return ajv;
      }
      for (keyword in KEYWORDS) get(keyword)(ajv);
      return ajv;
    }


    defineKeywords.get = get;

    function get(keyword) {
      var defFunc = KEYWORDS[keyword];
      if (!defFunc) throw new Error('Unknown keyword ' + keyword);
      return defFunc;
    }

  }, { "./keywords": "KP4Q" }], "STvH": [function (require, module, exports) {
    "use strict";

    function _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() { }; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

    function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

    function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

    function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

    function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

    function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

    function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.validate = validate;
    Object.defineProperty(exports, "ValidationError", {
      enumerable: true,
      get: function get() {
        return _ValidationError.default;
      }
    });

    var _absolutePath = _interopRequireDefault(require("./keywords/absolutePath"));

    var _ValidationError = _interopRequireDefault(require("./ValidationError"));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    } // Use CommonJS require for ajv libs so TypeScript consumers aren't locked into esModuleInterop (see #110).


    var Ajv = require("ajv");

    var ajvKeywords = require("ajv-keywords");
    /** @typedef {import("json-schema").JSONSchema4} JSONSchema4 */

    /** @typedef {import("json-schema").JSONSchema6} JSONSchema6 */

    /** @typedef {import("json-schema").JSONSchema7} JSONSchema7 */

    /** @typedef {import("ajv").ErrorObject} ErrorObject */

    /**
     * @typedef {Object} Extend
     * @property {number=} formatMinimum
     * @property {number=} formatMaximum
     * @property {boolean=} formatExclusiveMinimum
     * @property {boolean=} formatExclusiveMaximum
     * @property {string=} link
     */

    /** @typedef {(JSONSchema4 | JSONSchema6 | JSONSchema7) & Extend} Schema */

    /** @typedef {ErrorObject & { children?: Array<ErrorObject>}} SchemaUtilErrorObject */

    /**
     * @callback PostFormatter
     * @param {string} formattedError
     * @param {SchemaUtilErrorObject} error
     * @returns {string}
     */

    /**
     * @typedef {Object} ValidationErrorConfiguration
     * @property {string=} name
     * @property {string=} baseDataPath
     * @property {PostFormatter=} postFormatter
     */


    var ajv = new Ajv({
      allErrors: true,
      verbose: true,
      $data: true
    });
    ajvKeywords(ajv, ["instanceof", "formatMinimum", "formatMaximum", "patternRequired"]); // Custom keywords

    (0, _absolutePath.default)(ajv);
    /**
     * @param {Schema} schema
     * @param {Array<object> | object} options
     * @param {ValidationErrorConfiguration=} configuration
     * @returns {void}
     */

    function validate(schema, options, configuration) {
      var errors = [];

      if (Array.isArray(options)) {
        errors = Array.from(options, function (nestedOptions) {
          return validateObject(schema, nestedOptions);
        });
        errors.forEach(function (list, idx) {
          var applyPrefix =
            /**
             * @param {SchemaUtilErrorObject} error
             */
            function applyPrefix(error) {
              // eslint-disable-next-line no-param-reassign
              error.dataPath = "[".concat(idx, "]").concat(error.dataPath);

              if (error.children) {
                error.children.forEach(applyPrefix);
              }
            };

          list.forEach(applyPrefix);
        });
        errors = errors.reduce(function (arr, items) {
          arr.push.apply(arr, _toConsumableArray(items));
          return arr;
        }, []);
      } else {
        errors = validateObject(schema, options);
      }

      if (errors.length > 0) {
        throw new _ValidationError.default(errors, schema, configuration);
      }
    }
    /**
     * @param {Schema} schema
     * @param {Array<object> | object} options
     * @returns {Array<SchemaUtilErrorObject>}
     */


    function validateObject(schema, options) {
      var compiledSchema = ajv.compile(schema);
      var valid = compiledSchema(options);
      if (valid) return [];
      return compiledSchema.errors ? filterErrors(compiledSchema.errors) : [];
    }
    /**
     * @param {Array<ErrorObject>} errors
     * @returns {Array<SchemaUtilErrorObject>}
     */


    function filterErrors(errors) {
      /** @type {Array<SchemaUtilErrorObject>} */
      var newErrors = [];

      var _iterator = _createForOfIteratorHelper(
        /** @type {Array<SchemaUtilErrorObject>} */
        errors),
        _step;

      try {
        var _loop = function _loop() {
          var error = _step.value;
          var dataPath = error.dataPath;
          /** @type {Array<SchemaUtilErrorObject>} */

          var children = [];
          newErrors = newErrors.filter(function (oldError) {
            if (oldError.dataPath.includes(dataPath)) {
              if (oldError.children) {
                children = children.concat(oldError.children.slice(0));
              } // eslint-disable-next-line no-undefined, no-param-reassign


              oldError.children = undefined;
              children.push(oldError);
              return false;
            }

            return true;
          });

          if (children.length) {
            error.children = children;
          }

          newErrors.push(error);
        };

        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return newErrors;
    }
  }, { "./keywords/absolutePath": "iIhC", "./ValidationError": "ySUA", "ajv": "hi5j", "ajv-keywords": "n1A8" }], "pA46": [function (require, module, exports) {
    "use strict";

    var _require = require("./validate"),
      validate = _require.validate,
      ValidationError = _require.ValidationError;

    module.exports = {
      validate: validate,
      ValidationError: ValidationError
    };
  }, { "./validate": "STvH" }], "t7hQ": [function (require, module, exports) {
    function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

    function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

    function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

    function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

    function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

    function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

    var _require = require('schema-utils'),
      validate = _require.validate;

    function validateOptions(options, schema) {
      validate(schema, options);
    }

    function processOptions(options, processors) {
      var processedOptions = {};

      for (var _i = 0, _Object$entries = Object.entries(processors); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          property = _Object$entries$_i[0],
          processor = _Object$entries$_i[1];

        processedOptions[property] = options[property];

        if (processedOptions[property] === undefined) {
          processedOptions[property] = processor.default;
        }

        if (processor.process) {
          processedOptions[property] = processor.process(processedOptions[property]);
        }
      }

      return processedOptions;
    }

    module.exports = {
      validateOptions: validateOptions,
      processOptions: processOptions
    };
  }, { "schema-utils": "pA46" }], "uYXM": [function (require, module, exports) {
    module.exports = {
      type: 'object',
      properties: {
        filerDir: {
          type: 'string'
        },
        shimsDir: {
          type: 'string'
        },
        shimFs: {
          type: 'boolean'
        },
        shimPath: {
          type: 'boolean'
        },
        fsProvider: {
          type: 'string'
        },
        fsProviderDir: {
          type: 'string'
        }
      }
    };
  }, {}], "qUtu": [function (require, module, exports) {
    var process = require("process");
    var path = require('path');

    var ROOT_DIR_TAG = '<rootDir>';
    var CWD = process.cwd();
    module.exports = {
      filerDir: {
        process: function process(value) {
          if (!value) {
            return path.join(CWD, 'node_modules', 'filer');
          }

          return path.resolve(value.replace(ROOT_DIR_TAG, CWD));
        }
      },
      shimsDir: {
        process: function process(value) {
          if (!value) {
            return path.join(CWD, 'node_modules', 'filer', 'shims');
          }

          return path.resolve(value.replace(ROOT_DIR_TAG, CWD));
        }
      },
      fsProviderDir: {
        process: function process(value) {
          if (!value) {
            return path.join(CWD, 'node_modules', 'filer', 'shims', 'providers');
          }

          return path.resolve(value.replace(ROOT_DIR_TAG, CWD));
        }
      },
      shimFs: {
        default: true
      },
      shimPath: {
        default: true
      },
      fsProvider: {
        default: 'default'
      }
    };
  }, { "path": "UUq2", "process": "pBGv" }], "Ge14": [function (require, module, exports) {
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

    var path = require('path');

    var utils = require('./utils');

    var PLUGIN_NAME = 'filer-webpack-plugin';

    var OPTIONS_SCHEMA = require('./schema');

    var OPTIONS_PROCESSORS = require('./processors');

    module.exports = /*#__PURE__*/function () {
      function FilerWebpackPlugin() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, FilerWebpackPlugin);

        utils.validateOptions(options, OPTIONS_SCHEMA);
        this.options = utils.processOptions(options, OPTIONS_PROCESSORS);
      }

      _createClass(FilerWebpackPlugin, [{
        key: "apply",
        value: function apply(compiler) {
          var _this = this;

          compiler.hooks.normalModuleFactory.tap(PLUGIN_NAME, function (factory) {
            factory.hooks.resolve.tap(PLUGIN_NAME, function (resolveData) {
              // Resolve fsProvider if required
              if (resolveData.request === 'fsProvider' && resolveData.context === _this.options.shimsDir) {
                return _this.resolveFsProvider(resolveData);
              } // Ignore filer files (these should resolve modules normally)


              if (resolveData.context.startsWith(_this.options.filerDir)) return; // Apply fs, path and buffer shims if required

              switch (resolveData.request) {
                case 'fs':
                  if (!_this.options.shimFs) return;
                  return _this.applyFsShim(resolveData);

                case 'path':
                  if (!_this.options.shimPath) return;
                  return _this.applyPathShim(resolveData);

                default:
                  return;
              }
            });
          });
        }
      }, {
        key: "resolveFsProvider",
        value: function resolveFsProvider(resolveData) {
          switch (this.options.fsProvider) {
            case 'default':
              resolveData.request = path.join(this.options.fsProviderDir, 'default.js');
              break;

            case 'indexeddb':
              resolveData.request = path.join(this.options.fsProviderDir, 'indexeddb.js');
              break;

            case 'memory':
              resolveData.request = path.join(this.options.fsProviderDir, 'memory.js');
              break;

            case 'custom':
              resolveData.request = path.join(this.options.fsProviderDir, 'custom.js');
              break;

            default:
              throw new Error(['Invalid option for fsProvider.', 'fsProvider must be one of \'default\', \'indexeddb\', \'memory\' or \'custom\'.', 'If using a custom fsProvider, you must also provide the fsProviderDir option.'].join(' '));
          }
        }
      }, {
        key: "applyFsShim",
        value: function applyFsShim(resolveData) {
          resolveData.request = path.join(this.options.shimsDir, 'fs.js');
        }
      }, {
        key: "applyPathShim",
        value: function applyPathShim(resolveData) {
          resolveData.request = path.join(this.options.shimsDir, 'path.js');
        }
      }]);

      return FilerWebpackPlugin;
    }();
  }, { "path": "UUq2", "./utils": "t7hQ", "./schema": "uYXM", "./processors": "qUtu" }], "Focm": [function (require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var fs = null;
    var Filer = null;
    module.exports = Filer = {
      FileSystem: require('./filesystem/interface.js'),
      Buffer: Buffer,
      // We previously called this Path, but node calls it path. Do both
      Path: require('./path.js'),
      path: require('./path.js'),
      Errors: require('./errors.js'),
      Shell: require('./shell/shell.js'),

      /**
       * @deprecated Importing filer from your webpack config is not recommended.
       * 
       * The filer `FilerWebpackPlugin` class is exposed directly. 
       * 
       * ```
       * const { FilerWebpackPlugin } = require('filer/webpack');
       * ```
       */
      FilerWebpackPlugin: require('./webpack-plugin')
    }; // Add a getter for the `fs` instance, which returns
    // a Filer FileSystem instance, using the default provider/flags.

    Object.defineProperty(Filer, 'fs', {
      enumerable: true,
      get: function get() {
        if (!fs) {
          fs = new Filer.FileSystem();
        }

        return fs;
      }
    });
  }, { "./filesystem/interface.js": "GMi4", "./path.js": "UzoP", "./errors.js": "p8GN", "./shell/shell.js": "D1Ra", "./webpack-plugin": "Ge14", "buffer": "dskh" }]
}, {}, ["Focm"], "Filer")
//# sourceMappingURL=/filer.js.map

const { FileSystem, Path, Buffer } =  __exports.Filer;
export { FileSystem, Path, Buffer };